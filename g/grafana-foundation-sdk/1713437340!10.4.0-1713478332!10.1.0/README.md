# Comparing `tmp/grafana_foundation_sdk-1713437340!10.4.0.tar.gz` & `tmp/grafana_foundation_sdk-1713478332!10.1.0.tar.gz`

## Comparing `grafana_foundation_sdk-1713437340!10.4.0.tar` & `grafana_foundation_sdk-1713478332!10.1.0.tar`

### file list

```diff
@@ -1,101 +1,105 @@
--rw-r--r--   0        0        0       70 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/__init__.py
--rw-r--r--   0        0        0       74 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/__init__.py
--rw-r--r--   0        0        0     3929 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/accesspolicy.py
--rw-r--r--   0        0        0    17729 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/alertgroups.py
--rw-r--r--   0        0        0    19740 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/annotationslist.py
--rw-r--r--   0        0        0    27840 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/azuremonitor.py
--rw-r--r--   0        0        0    38901 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/barchart.py
--rw-r--r--   0        0        0    20553 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/bargauge.py
--rw-r--r--   0        0        0    49298 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/candlestick.py
--rw-r--r--   0        0        0    18587 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/canvas.py
--rw-r--r--   0        0        0    29739 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/cloudwatch.py
--rw-r--r--   0        0        0    49658 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/common.py
--rw-r--r--   0        0        0    68663 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/dashboard.py
--rw-r--r--   0        0        0    20077 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/dashboardlist.py
--rw-r--r--   0        0        0    16879 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/datagrid.py
--rw-r--r--   0        0        0    17078 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/debug.py
--rw-r--r--   0        0        0    62617 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/elasticsearch.py
--rw-r--r--   0        0        0    19451 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/gauge.py
--rw-r--r--   0        0        0    18310 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/geomap.py
--rw-r--r--   0        0        0    20087 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/googlecloudmonitoring.py
--rw-r--r--   0        0        0     1737 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/grafanapyroscope.py
--rw-r--r--   0        0        0    24485 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/heatmap.py
--rw-r--r--   0        0        0    32689 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/histogram.py
--rw-r--r--   0        0        0    12829 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/librarypanel.py
--rw-r--r--   0        0        0    19670 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/logs.py
--rw-r--r--   0        0        0     2028 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/loki.py
--rw-r--r--   0        0        0    17154 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/news.py
--rw-r--r--   0        0        0    17103 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/nodegraph.py
--rw-r--r--   0        0        0     1238 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/parca.py
--rw-r--r--   0        0        0    20174 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/piechart.py
--rw-r--r--   0        0        0     3634 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/preferences.py
--rw-r--r--   0        0        0     3144 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/prometheus.py
--rw-r--r--   0        0        0     1927 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/publicdashboard.py
--rw-r--r--   0        0        0     1388 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/role.py
--rw-r--r--   0        0        0     2671 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/rolebinding.py
--rw-r--r--   0        0        0    19772 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/stat.py
--rw-r--r--   0        0        0    22520 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/statetimeline.py
--rw-r--r--   0        0        0    22215 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/statushistory.py
--rw-r--r--   0        0        0    27521 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/table.py
--rw-r--r--   0        0        0      762 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/team.py
--rw-r--r--   0        0        0     7333 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/tempo.py
--rw-r--r--   0        0        0    11497 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/testdata.py
--rw-r--r--   0        0        0    17372 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/text.py
--rw-r--r--   0        0        0    46858 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/timeseries.py
--rw-r--r--   0        0        0    46581 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/trend.py
--rw-r--r--   0        0        0    36463 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/xychart.py
--rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/__init__.py
--rw-r--r--   0        0        0      235 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/builder.py
--rw-r--r--   0        0        0      336 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/encoder.py
--rw-r--r--   0        0        0     3656 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/plugins.py
--rw-r--r--   0        0        0     2523 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/runtime.py
--rw-r--r--   0        0        0      104 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/variants.py
--rw-r--r--   0        0        0       72 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/__init__.py
--rw-r--r--   0        0        0     4388 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/accesspolicy.py
--rw-r--r--   0        0        0     1402 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/alertgroups.py
--rw-r--r--   0        0        0     2966 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/annotationslist.py
--rw-r--r--   0        0        0    40749 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/azuremonitor.py
--rw-r--r--   0        0        0    11975 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/barchart.py
--rw-r--r--   0        0        0     3985 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/bargauge.py
--rw-r--r--   0        0        0     6594 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/candlestick.py
--rw-r--r--   0        0        0    14128 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/canvas.py
--rw-r--r--   0        0        0    39904 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/cloudwatch.py
--rw-r--r--   0        0        0    87408 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/common.py
--rw-r--r--   0        0        0    86939 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/dashboard.py
--rw-r--r--   0        0        0     3237 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/dashboardlist.py
--rw-r--r--   0        0        0      876 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/datagrid.py
--rw-r--r--   0        0        0     2322 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/debug.py
--rw-r--r--   0        0        0    90714 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/elasticsearch.py
--rw-r--r--   0        0        0     3067 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/gauge.py
--rw-r--r--   0        0        0     8247 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/geomap.py
--rw-r--r--   0        0        0    27783 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/googlecloudmonitoring.py
--rw-r--r--   0        0        0     3435 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/grafanapyroscope.py
--rw-r--r--   0        0        0    21480 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/heatmap.py
--rw-r--r--   0        0        0     8134 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/histogram.py
--rw-r--r--   0        0        0    16344 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/librarypanel.py
--rw-r--r--   0        0        0     3188 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/logs.py
--rw-r--r--   0        0        0     4427 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/loki.py
--rw-r--r--   0        0        0     1233 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/news.py
--rw-r--r--   0        0        0     4899 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/nodegraph.py
--rw-r--r--   0        0        0     2529 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/parca.py
--rw-r--r--   0        0        0     6752 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/piechart.py
--rw-r--r--   0        0        0     4959 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/preferences.py
--rw-r--r--   0        0        0     5578 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/prometheus.py
--rw-r--r--   0        0        0     2222 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/publicdashboard.py
--rw-r--r--   0        0        0     1813 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/role.py
--rw-r--r--   0        0        0     3364 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/rolebinding.py
--rw-r--r--   0        0        0     3525 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/stat.py
--rw-r--r--   0        0        0     4328 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/statetimeline.py
--rw-r--r--   0        0        0     3828 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/statushistory.py
--rw-r--r--   0        0        0     2912 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/table.py
--rw-r--r--   0        0        0      838 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/team.py
--rw-r--r--   0        0        0    10814 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/tempo.py
--rw-r--r--   0        0        0    20662 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/testdata.py
--rw-r--r--   0        0        0     2892 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/text.py
--rw-r--r--   0        0        0     1676 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/timeseries.py
--rw-r--r--   0        0        0     1772 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/trend.py
--rw-r--r--   0        0        0    18310 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/xychart.py
--rw-r--r--   0        0        0    10802 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/LICENSE.md
--rw-r--r--   0        0        0     9594 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/README.md
--rw-r--r--   0        0        0     1100 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/pyproject.toml
--rw-r--r--   0        0        0    10613 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713437340!10.4.0/PKG-INFO
+-rw-r--r--   0        0        0       70 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/__init__.py
+-rw-r--r--   0        0        0       74 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/__init__.py
+-rw-r--r--   0        0        0     3904 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/accesspolicy.py
+-rw-r--r--   0        0        0    16488 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/alertgroups.py
+-rw-r--r--   0        0        0    18475 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/annotationslist.py
+-rw-r--r--   0        0        0    27073 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/azuremonitor.py
+-rw-r--r--   0        0        0    36550 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/barchart.py
+-rw-r--r--   0        0        0    18213 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/bargauge.py
+-rw-r--r--   0        0        0    46386 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/candlestick.py
+-rw-r--r--   0        0        0    16550 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/canvas.py
+-rw-r--r--   0        0        0    29609 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/cloudwatch.py
+-rw-r--r--   0        0        0    48403 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/common.py
+-rw-r--r--   0        0        0    71911 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/dashboard.py
+-rw-r--r--   0        0        0    18357 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/dashboardlist.py
+-rw-r--r--   0        0        0    15646 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/datagrid.py
+-rw-r--r--   0        0        0    15841 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/debug.py
+-rw-r--r--   0        0        0    62126 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/elasticsearch.py
+-rw-r--r--   0        0        0     1114 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/folder.py
+-rw-r--r--   0        0        0    17170 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/gauge.py
+-rw-r--r--   0        0        0    17061 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/geomap.py
+-rw-r--r--   0        0        0    22978 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/googlecloudmonitoring.py
+-rw-r--r--   0        0        0     1564 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/grafanapyroscope.py
+-rw-r--r--   0        0        0    23184 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/heatmap.py
+-rw-r--r--   0        0        0    29881 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/histogram.py
+-rw-r--r--   0        0        0    12062 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/librarypanel.py
+-rw-r--r--   0        0        0    18024 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/logs.py
+-rw-r--r--   0        0        0     2013 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/loki.py
+-rw-r--r--   0        0        0    15917 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/news.py
+-rw-r--r--   0        0        0    15866 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/nodegraph.py
+-rw-r--r--   0        0        0     1229 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/parca.py
+-rw-r--r--   0        0        0    18907 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/piechart.py
+-rw-r--r--   0        0        0     3083 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/playlist.py
+-rw-r--r--   0        0        0     3508 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/preferences.py
+-rw-r--r--   0        0        0     2432 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/prometheus.py
+-rw-r--r--   0        0        0     1918 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/publicdashboard.py
+-rw-r--r--   0        0        0     1380 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/role.py
+-rw-r--r--   0        0        0     2651 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/rolebinding.py
+-rw-r--r--   0        0        0    17809 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/stat.py
+-rw-r--r--   0        0        0    21233 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/statetimeline.py
+-rw-r--r--   0        0        0    20932 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/statushistory.py
+-rw-r--r--   0        0        0    17923 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/table.py
+-rw-r--r--   0        0        0      756 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/team.py
+-rw-r--r--   0        0        0     6324 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/tempo.py
+-rw-r--r--   0        0        0    11092 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/testdata.py
+-rw-r--r--   0        0        0    16131 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/text.py
+-rw-r--r--   0        0        0    44391 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/timeseries.py
+-rw-r--r--   0        0        0    44124 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/trend.py
+-rw-r--r--   0        0        0    34002 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/xychart.py
+-rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/__init__.py
+-rw-r--r--   0        0        0      235 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/builder.py
+-rw-r--r--   0        0        0      336 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/encoder.py
+-rw-r--r--   0        0        0     3656 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/plugins.py
+-rw-r--r--   0        0        0     2523 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/runtime.py
+-rw-r--r--   0        0        0      104 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/variants.py
+-rw-r--r--   0        0        0       72 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/__init__.py
+-rw-r--r--   0        0        0     4388 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/accesspolicy.py
+-rw-r--r--   0        0        0     1402 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/alertgroups.py
+-rw-r--r--   0        0        0     2966 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/annotationslist.py
+-rw-r--r--   0        0        0    39868 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/azuremonitor.py
+-rw-r--r--   0        0        0    11627 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/barchart.py
+-rw-r--r--   0        0        0     3089 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/bargauge.py
+-rw-r--r--   0        0        0     6262 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/candlestick.py
+-rw-r--r--   0        0        0    13569 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/canvas.py
+-rw-r--r--   0        0        0    39904 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/cloudwatch.py
+-rw-r--r--   0        0        0    84365 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/common.py
+-rw-r--r--   0        0        0    87845 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/dashboard.py
+-rw-r--r--   0        0        0     2878 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/dashboardlist.py
+-rw-r--r--   0        0        0      876 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/datagrid.py
+-rw-r--r--   0        0        0     2322 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/debug.py
+-rw-r--r--   0        0        0    90714 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/elasticsearch.py
+-rw-r--r--   0        0        0     1206 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/folder.py
+-rw-r--r--   0        0        0     2322 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/gauge.py
+-rw-r--r--   0        0        0     8247 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/geomap.py
+-rw-r--r--   0        0        0    32434 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/googlecloudmonitoring.py
+-rw-r--r--   0        0        0     3101 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/grafanapyroscope.py
+-rw-r--r--   0        0        0    20031 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/heatmap.py
+-rw-r--r--   0        0        0     7447 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/histogram.py
+-rw-r--r--   0        0        0    15098 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/librarypanel.py
+-rw-r--r--   0        0        0     2868 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/logs.py
+-rw-r--r--   0        0        0     4388 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/loki.py
+-rw-r--r--   0        0        0     1233 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/news.py
+-rw-r--r--   0        0        0     4899 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/nodegraph.py
+-rw-r--r--   0        0        0     2529 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/parca.py
+-rw-r--r--   0        0        0     6752 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/piechart.py
+-rw-r--r--   0        0        0     3409 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/playlist.py
+-rw-r--r--   0        0        0     4857 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/preferences.py
+-rw-r--r--   0        0        0     4717 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/prometheus.py
+-rw-r--r--   0        0        0     2222 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/publicdashboard.py
+-rw-r--r--   0        0        0     1813 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/role.py
+-rw-r--r--   0        0        0     3364 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/rolebinding.py
+-rw-r--r--   0        0        0     3021 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/stat.py
+-rw-r--r--   0        0        0     4328 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/statetimeline.py
+-rw-r--r--   0        0        0     3828 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/statushistory.py
+-rw-r--r--   0        0        0     2851 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/table.py
+-rw-r--r--   0        0        0      838 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/team.py
+-rw-r--r--   0        0        0     9313 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/tempo.py
+-rw-r--r--   0        0        0    20019 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/testdata.py
+-rw-r--r--   0        0        0     2892 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/text.py
+-rw-r--r--   0        0        0     1676 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/timeseries.py
+-rw-r--r--   0        0        0     1772 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/trend.py
+-rw-r--r--   0        0        0    17220 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/xychart.py
+-rw-r--r--   0        0        0    10802 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/LICENSE.md
+-rw-r--r--   0        0        0     9473 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/README.md
+-rw-r--r--   0        0        0     1100 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/pyproject.toml
+-rw-r--r--   0        0        0    10492 2020-02-02 00:00:00.000000 grafana_foundation_sdk-1713478332!10.1.0/PKG-INFO
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/accesspolicy.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/accesspolicy.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,137 +2,137 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import accesspolicy
 
 
 class AccessPolicy(cogbuilder.Builder[accesspolicy.AccessPolicy]):    
-    __internal: accesspolicy.AccessPolicy
+    _internal: accesspolicy.AccessPolicy
 
     def __init__(self):
-        self.__internal = accesspolicy.AccessPolicy()
+        self._internal = accesspolicy.AccessPolicy()
 
     def build(self) -> accesspolicy.AccessPolicy:
-        return self.__internal    
+        return self._internal    
     
     def scope(self, scope: cogbuilder.Builder[accesspolicy.ResourceRef]) -> typing.Self:    
         """
         The scope where these policies should apply
         """
             
         scope_resource = scope.build()
-        self.__internal.scope = scope_resource
+        self._internal.scope = scope_resource
     
         return self
     
     def role(self, role: cogbuilder.Builder[accesspolicy.RoleRef]) -> typing.Self:    
         """
         The role that must apply this policy
         """
             
         role_resource = role.build()
-        self.__internal.role = role_resource
+        self._internal.role = role_resource
     
         return self
     
     def rules(self, rules: cogbuilder.Builder[accesspolicy.AccessRule]) -> typing.Self:    
         """
         The set of rules to apply.  Note that * is required to modify
         access policy rules, and that "none" will reject all actions
         """
             
-        if self.__internal.rules is None:
-            self.__internal.rules = []
+        if self._internal.rules is None:
+            self._internal.rules = []
         
         rules_resource = rules.build()
-        self.__internal.rules.append(rules_resource)
+        self._internal.rules.append(rules_resource)
     
         return self
     
 
 class RoleRef(cogbuilder.Builder[accesspolicy.RoleRef]):    
-    __internal: accesspolicy.RoleRef
+    _internal: accesspolicy.RoleRef
 
     def __init__(self):
-        self.__internal = accesspolicy.RoleRef()
+        self._internal = accesspolicy.RoleRef()
 
     def build(self) -> accesspolicy.RoleRef:
-        return self.__internal    
+        return self._internal    
     
     def kind(self, kind: typing.Literal["Role", "BuiltinRole", "Team", "User"]) -> typing.Self:    
         """
         Policies can apply to roles, teams, or users
         Applying policies to individual users is supported, but discouraged
         """
             
-        self.__internal.kind = kind
+        self._internal.kind = kind
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def xname(self, xname: str) -> typing.Self:        
-        self.__internal.xname = xname
+        self._internal.xname = xname
     
         return self
     
 
 class ResourceRef(cogbuilder.Builder[accesspolicy.ResourceRef]):    
-    __internal: accesspolicy.ResourceRef
+    _internal: accesspolicy.ResourceRef
 
     def __init__(self):
-        self.__internal = accesspolicy.ResourceRef()
+        self._internal = accesspolicy.ResourceRef()
 
     def build(self) -> accesspolicy.ResourceRef:
-        return self.__internal    
+        return self._internal    
     
     def kind(self, kind: str) -> typing.Self:        
-        self.__internal.kind = kind
+        self._internal.kind = kind
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
 
 class AccessRule(cogbuilder.Builder[accesspolicy.AccessRule]):    
-    __internal: accesspolicy.AccessRule
+    _internal: accesspolicy.AccessRule
 
     def __init__(self):
-        self.__internal = accesspolicy.AccessRule()
+        self._internal = accesspolicy.AccessRule()
 
     def build(self) -> accesspolicy.AccessRule:
-        return self.__internal    
+        return self._internal    
     
     def kind(self, kind: typing.Union[typing.Literal["*"]]) -> typing.Self:    
         """
         The kind this rule applies to (dashboards, alert, etc)
         """
             
-        self.__internal.kind = kind
+        self._internal.kind = kind
     
         return self
     
     def verb(self, verb: typing.Union[typing.Literal["*"]]) -> typing.Self:    
         """
         READ, WRITE, CREATE, DELETE, ...
         should move to k8s style verbs like: "get", "list", "watch", "create", "update", "patch", "delete"
         """
             
-        self.__internal.verb = verb
+        self._internal.verb = verb
     
         return self
     
     def target(self, target: str) -> typing.Self:    
         """
         Specific sub-elements like "alert.rules" or "dashboard.permissions"????
         """
             
-        self.__internal.target = target
+        self._internal.target = target
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/alertgroups.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/statetimeline.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,193 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import alertgroups
+from ..models import statetimeline
 from ..cog import variants as cogvariants
+from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "alertGroups"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "state-timeline"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,201 +244,314 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def labels(self, labels: str) -> typing.Self:    
+    def show_value(self, show_value: common.VisibilityMode) -> typing.Self:    
+        """
+        Show timeline values on chart
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
+        
+        assert isinstance(self._internal.options, statetimeline.Options)
+        
+        self._internal.options.show_value = show_value
+    
+        return self
+    
+    def row_height(self, row_height: float) -> typing.Self:    
         """
-        Comma-separated list of values used to filter alert results
+        Controls the row height
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = alertgroups.Options()
+        if not row_height <= 1:
+            raise ValueError("row_height must be <= 1")
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
         
-        assert isinstance(self.__internal.options, alertgroups.Options)
+        assert isinstance(self._internal.options, statetimeline.Options)
         
-        self.__internal.options.labels = labels
+        self._internal.options.row_height = row_height
     
         return self
     
-    def alertmanager(self, alertmanager: str) -> typing.Self:    
+    def merge_values(self, merge_values: bool) -> typing.Self:    
         """
-        Name of the alertmanager used as a source for alerts
+        Merge equal consecutive values
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = alertgroups.Options()
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
+        
+        assert isinstance(self._internal.options, statetimeline.Options)
+        
+        self._internal.options.merge_values = merge_values
+    
+        return self
+    
+    def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
         
-        assert isinstance(self.__internal.options, alertgroups.Options)
+        assert isinstance(self._internal.options, statetimeline.Options)
         
-        self.__internal.options.alertmanager = alertmanager
+        legend_resource = legend.build()
+        self._internal.options.legend = legend_resource
     
         return self
     
-    def expand_all(self, expand_all: bool) -> typing.Self:    
+    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
+        
+        assert isinstance(self._internal.options, statetimeline.Options)
+        
+        tooltip_resource = tooltip.build()
+        self._internal.options.tooltip = tooltip_resource
+    
+        return self
+    
+    def timezone(self, timezone: list[common.TimeZone]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
+        
+        assert isinstance(self._internal.options, statetimeline.Options)
+        
+        self._internal.options.timezone = timezone
+    
+        return self
+    
+    def align_value(self, align_value: common.TimelineValueAlignment) -> typing.Self:    
         """
-        Expand all alert groups by default
+        Controls value alignment on the timelines
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = alertgroups.Options()
+        if self._internal.options is None:
+            self._internal.options = statetimeline.Options()
+        
+        assert isinstance(self._internal.options, statetimeline.Options)
+        
+        self._internal.options.align_value = align_value
+    
+        return self
+    
+    def line_width(self, line_width: int) -> typing.Self:        
+        if not line_width <= 10:
+            raise ValueError("line_width must be <= 10")
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statetimeline.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults.custom, statetimeline.FieldConfig)
+        
+        self._internal.field_config.defaults.custom.line_width = line_width
+    
+        return self
+    
+    def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statetimeline.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults.custom, statetimeline.FieldConfig)
+        
+        hide_from_resource = hide_from.build()
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
+    
+        return self
+    
+    def fill_opacity(self, fill_opacity: int) -> typing.Self:        
+        if not fill_opacity <= 100:
+            raise ValueError("fill_opacity must be <= 100")
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statetimeline.FieldConfig()
         
-        assert isinstance(self.__internal.options, alertgroups.Options)
+        assert isinstance(self._internal.field_config.defaults.custom, statetimeline.FieldConfig)
         
-        self.__internal.options.expand_all = expand_all
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/annotationslist.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/annotationslist.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,186 +8,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "annolist"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "annolist"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,249 +243,249 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def only_from_this_dashboard(self, only_from_this_dashboard: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.only_from_this_dashboard = only_from_this_dashboard
+        self._internal.options.only_from_this_dashboard = only_from_this_dashboard
     
         return self
     
     def only_in_time_range(self, only_in_time_range: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.only_in_time_range = only_in_time_range
+        self._internal.options.only_in_time_range = only_in_time_range
     
         return self
     
     def limit(self, limit: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.limit = limit
+        self._internal.options.limit = limit
     
         return self
     
     def show_user(self, show_user: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.show_user = show_user
+        self._internal.options.show_user = show_user
     
         return self
     
     def show_time(self, show_time: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.show_time = show_time
+        self._internal.options.show_time = show_time
     
         return self
     
     def show_tags(self, show_tags: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.show_tags = show_tags
+        self._internal.options.show_tags = show_tags
     
         return self
     
     def navigate_to_panel(self, navigate_to_panel: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.navigate_to_panel = navigate_to_panel
+        self._internal.options.navigate_to_panel = navigate_to_panel
     
         return self
     
     def navigate_before(self, navigate_before: str) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.navigate_before = navigate_before
+        self._internal.options.navigate_before = navigate_before
     
         return self
     
     def navigate_after(self, navigate_after: str) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = annotationslist.Options()
+        if self._internal.options is None:
+            self._internal.options = annotationslist.Options()
         
-        assert isinstance(self.__internal.options, annotationslist.Options)
+        assert isinstance(self._internal.options, annotationslist.Options)
         
-        self.__internal.options.navigate_after = navigate_after
+        self._internal.options.navigate_after = navigate_after
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/azuremonitor.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/azuremonitor.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,901 +2,883 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import azuremonitor
 
 
 class AzureMonitorQuery(cogbuilder.Builder[azuremonitor.AzureMonitorQuery]):    
-    __internal: azuremonitor.AzureMonitorQuery
+    _internal: azuremonitor.AzureMonitorQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureMonitorQuery()
+        self._internal = azuremonitor.AzureMonitorQuery()
 
     def build(self) -> azuremonitor.AzureMonitorQuery:
-        return self.__internal    
+        return self._internal    
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:    
         """
         Azure subscription containing the resource(s) to be queried.
         """
             
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def subscriptions(self, subscriptions: list[str]) -> typing.Self:    
         """
         Subscriptions to be queried via Azure Resource Graph.
         """
             
-        self.__internal.subscriptions = subscriptions
+        self._internal.subscriptions = subscriptions
     
         return self
     
     def azure_monitor(self, azure_monitor: cogbuilder.Builder[azuremonitor.AzureMetricQuery]) -> typing.Self:    
         """
         Azure Monitor Metrics sub-query properties.
         """
             
         azure_monitor_resource = azure_monitor.build()
-        self.__internal.azure_monitor = azure_monitor_resource
+        self._internal.azure_monitor = azure_monitor_resource
     
         return self
     
     def azure_log_analytics(self, azure_log_analytics: cogbuilder.Builder[azuremonitor.AzureLogsQuery]) -> typing.Self:    
         """
         Azure Monitor Logs sub-query properties.
         """
             
         azure_log_analytics_resource = azure_log_analytics.build()
-        self.__internal.azure_log_analytics = azure_log_analytics_resource
+        self._internal.azure_log_analytics = azure_log_analytics_resource
     
         return self
     
     def azure_resource_graph(self, azure_resource_graph: cogbuilder.Builder[azuremonitor.AzureResourceGraphQuery]) -> typing.Self:    
         """
         Azure Resource Graph sub-query properties.
         """
             
         azure_resource_graph_resource = azure_resource_graph.build()
-        self.__internal.azure_resource_graph = azure_resource_graph_resource
+        self._internal.azure_resource_graph = azure_resource_graph_resource
     
         return self
     
     def azure_traces(self, azure_traces: cogbuilder.Builder[azuremonitor.AzureTracesQuery]) -> typing.Self:    
         """
         Application Insights Traces sub-query properties.
         """
             
         azure_traces_resource = azure_traces.build()
-        self.__internal.azure_traces = azure_traces_resource
+        self._internal.azure_traces = azure_traces_resource
     
         return self
     
     def grafana_template_variable_fn(self, grafana_template_variable_fn: azuremonitor.GrafanaTemplateVariableQuery) -> typing.Self:    
         """
         @deprecated Legacy template variable support.
         """
             
-        self.__internal.grafana_template_variable_fn = grafana_template_variable_fn
+        self._internal.grafana_template_variable_fn = grafana_template_variable_fn
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:    
         """
         Template variables params. These exist for backwards compatiblity with legacy template variables.
         """
             
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def namespace(self, namespace: str) -> typing.Self:        
-        self.__internal.namespace = namespace
+        self._internal.namespace = namespace
     
         return self
     
     def resource(self, resource: str) -> typing.Self:        
-        self.__internal.resource = resource
+        self._internal.resource = resource
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def region(self, region: str) -> typing.Self:    
         """
         Azure Monitor query type.
         queryType: #AzureQueryType
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
 
 class AzureMetricQuery(cogbuilder.Builder[azuremonitor.AzureMetricQuery]):    
-    __internal: azuremonitor.AzureMetricQuery
+    _internal: azuremonitor.AzureMetricQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureMetricQuery()
+        self._internal = azuremonitor.AzureMetricQuery()
 
     def build(self) -> azuremonitor.AzureMetricQuery:
-        return self.__internal    
+        return self._internal    
     
     def resources(self, resources: list[cogbuilder.Builder[azuremonitor.AzureMonitorResource]]) -> typing.Self:    
         """
         Array of resource URIs to be queried.
         """
             
         resources_resources = [r1.build() for r1 in resources]
-        self.__internal.resources = resources_resources
+        self._internal.resources = resources_resources
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:    
         """
         metricNamespace is used as the resource type (or resource namespace).
         It's usually equal to the target metric namespace. e.g. microsoft.storage/storageaccounts
         Kept the name of the variable as metricNamespace to avoid backward incompatibility issues.
         """
             
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
     def custom_namespace(self, custom_namespace: str) -> typing.Self:    
         """
         Used as the value for the metricNamespace property when it's different from the resource namespace.
         """
             
-        self.__internal.custom_namespace = custom_namespace
+        self._internal.custom_namespace = custom_namespace
     
         return self
     
     def metric_name(self, metric_name: str) -> typing.Self:    
         """
         The metric to query data for within the specified metricNamespace. e.g. UsedCapacity
         """
             
-        self.__internal.metric_name = metric_name
+        self._internal.metric_name = metric_name
     
         return self
     
     def region(self, region: str) -> typing.Self:    
         """
         The Azure region containing the resource(s).
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
     def time_grain(self, time_grain: str) -> typing.Self:    
         """
         The granularity of data points to be queried. Defaults to auto.
         """
             
-        self.__internal.time_grain = time_grain
+        self._internal.time_grain = time_grain
     
         return self
     
     def aggregation(self, aggregation: str) -> typing.Self:    
         """
         The aggregation to be used within the query. Defaults to the primaryAggregationType defined by the metric.
         """
             
-        self.__internal.aggregation = aggregation
+        self._internal.aggregation = aggregation
     
         return self
     
     def dimension_filters(self, dimension_filters: list[cogbuilder.Builder[azuremonitor.AzureMetricDimension]]) -> typing.Self:    
         """
         Filters to reduce the set of data returned. Dimensions that can be filtered on are defined by the metric.
         """
             
         dimension_filters_resources = [r1.build() for r1 in dimension_filters]
-        self.__internal.dimension_filters = dimension_filters_resources
+        self._internal.dimension_filters = dimension_filters_resources
     
         return self
     
     def top(self, top: str) -> typing.Self:    
         """
         Maximum number of records to return. Defaults to 10.
         """
             
-        self.__internal.top = top
+        self._internal.top = top
     
         return self
     
     def allowed_time_grains_ms(self, allowed_time_grains_ms: list[int]) -> typing.Self:    
         """
         Time grains that are supported by the metric.
         """
             
-        self.__internal.allowed_time_grains_ms = allowed_time_grains_ms
+        self._internal.allowed_time_grains_ms = allowed_time_grains_ms
     
         return self
     
     def alias(self, alias: str) -> typing.Self:    
         """
         Aliases can be set to modify the legend labels. e.g. {{ resourceGroup }}. See docs for more detail.
         """
             
-        self.__internal.alias = alias
+        self._internal.alias = alias
     
         return self
     
     def time_grain_unit(self, time_grain_unit: str) -> typing.Self:    
         """
         @deprecated
         """
             
-        self.__internal.time_grain_unit = time_grain_unit
+        self._internal.time_grain_unit = time_grain_unit
     
         return self
     
     def dimension(self, dimension: str) -> typing.Self:    
         """
         @deprecated This property was migrated to dimensionFilters and should only be accessed in the migration
         """
             
-        self.__internal.dimension = dimension
+        self._internal.dimension = dimension
     
         return self
     
     def dimension_filter(self, dimension_filter: str) -> typing.Self:    
         """
         @deprecated This property was migrated to dimensionFilters and should only be accessed in the migration
         """
             
-        self.__internal.dimension_filter = dimension_filter
+        self._internal.dimension_filter = dimension_filter
     
         return self
     
     def metric_definition(self, metric_definition: str) -> typing.Self:    
         """
         @deprecated Use metricNamespace instead
         """
             
-        self.__internal.metric_definition = metric_definition
+        self._internal.metric_definition = metric_definition
     
         return self
     
     def resource_uri(self, resource_uri: str) -> typing.Self:    
         """
         @deprecated Use resourceGroup, resourceName and metricNamespace instead
         """
             
-        self.__internal.resource_uri = resource_uri
+        self._internal.resource_uri = resource_uri
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:    
         """
         @deprecated Use resources instead
         """
             
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def resource_name(self, resource_name: str) -> typing.Self:    
         """
         @deprecated Use resources instead
         """
             
-        self.__internal.resource_name = resource_name
+        self._internal.resource_name = resource_name
     
         return self
     
 
 class AzureLogsQuery(cogbuilder.Builder[azuremonitor.AzureLogsQuery]):    
     """
     Azure Monitor Logs sub-query properties
     """
     
-    __internal: azuremonitor.AzureLogsQuery
+    _internal: azuremonitor.AzureLogsQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureLogsQuery()
+        self._internal = azuremonitor.AzureLogsQuery()
 
     def build(self) -> azuremonitor.AzureLogsQuery:
-        return self.__internal    
+        return self._internal    
     
     def query(self, query: str) -> typing.Self:    
         """
         KQL query to be executed.
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def result_format(self, result_format: azuremonitor.ResultFormat) -> typing.Self:    
         """
         Specifies the format results should be returned as.
         """
             
-        self.__internal.result_format = result_format
+        self._internal.result_format = result_format
     
         return self
     
     def resources(self, resources: list[str]) -> typing.Self:    
         """
         Array of resource URIs to be queried.
         """
             
-        self.__internal.resources = resources
+        self._internal.resources = resources
     
         return self
     
-    def dashboard_time(self, dashboard_time: bool) -> typing.Self:    
-        """
-        If set to true the dashboard time range will be used as a filter for the query. Otherwise the query time ranges will be used. Defaults to false.
-        """
-            
-        self.__internal.dashboard_time = dashboard_time
-    
-        return self
-    
-    def time_column(self, time_column: str) -> typing.Self:    
+    def intersect_time(self, intersect_time: bool) -> typing.Self:    
         """
-        If dashboardTime is set to true this value dictates which column the time filter will be applied to. Defaults to the first tables timeSpan column, the first datetime column found, or TimeGenerated
+        If set to true the intersection of time ranges specified in the query and Grafana will be used. Otherwise the query time ranges will be used. Defaults to false
         """
             
-        self.__internal.time_column = time_column
+        self._internal.intersect_time = intersect_time
     
         return self
     
     def workspace(self, workspace: str) -> typing.Self:    
         """
-        Workspace ID. This was removed in Grafana 8, but remains for backwards compat.
+        Workspace ID. This was removed in Grafana 8, but remains for backwards compat
         """
             
-        self.__internal.workspace = workspace
+        self._internal.workspace = workspace
     
         return self
     
     def resource(self, resource: str) -> typing.Self:    
         """
         @deprecated Use resources instead
         """
             
-        self.__internal.resource = resource
-    
-        return self
-    
-    def intersect_time(self, intersect_time: bool) -> typing.Self:    
-        """
-        @deprecated Use dashboardTime instead
-        """
-            
-        self.__internal.intersect_time = intersect_time
+        self._internal.resource = resource
     
         return self
     
 
 class AzureTracesQuery(cogbuilder.Builder[azuremonitor.AzureTracesQuery]):    
     """
     Application Insights Traces sub-query properties
     """
     
-    __internal: azuremonitor.AzureTracesQuery
+    _internal: azuremonitor.AzureTracesQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureTracesQuery()
+        self._internal = azuremonitor.AzureTracesQuery()
 
     def build(self) -> azuremonitor.AzureTracesQuery:
-        return self.__internal    
+        return self._internal    
     
     def result_format(self, result_format: azuremonitor.ResultFormat) -> typing.Self:    
         """
         Specifies the format results should be returned as.
         """
             
-        self.__internal.result_format = result_format
+        self._internal.result_format = result_format
     
         return self
     
     def resources(self, resources: list[str]) -> typing.Self:    
         """
         Array of resource URIs to be queried.
         """
             
-        self.__internal.resources = resources
+        self._internal.resources = resources
     
         return self
     
     def operation_id(self, operation_id: str) -> typing.Self:    
         """
         Operation ID. Used only for Traces queries.
         """
             
-        self.__internal.operation_id = operation_id
+        self._internal.operation_id = operation_id
     
         return self
     
     def trace_types(self, trace_types: list[str]) -> typing.Self:    
         """
         Types of events to filter by.
         """
             
-        self.__internal.trace_types = trace_types
+        self._internal.trace_types = trace_types
     
         return self
     
     def filters(self, filters: list[cogbuilder.Builder[azuremonitor.AzureTracesFilter]]) -> typing.Self:    
         """
         Filters for property values.
         """
             
         filters_resources = [r1.build() for r1 in filters]
-        self.__internal.filters = filters_resources
+        self._internal.filters = filters_resources
     
         return self
     
     def query(self, query: str) -> typing.Self:    
         """
         KQL query to be executed.
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
 
 class AzureTracesFilter(cogbuilder.Builder[azuremonitor.AzureTracesFilter]):    
-    __internal: azuremonitor.AzureTracesFilter
+    _internal: azuremonitor.AzureTracesFilter
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureTracesFilter()
+        self._internal = azuremonitor.AzureTracesFilter()
 
     def build(self) -> azuremonitor.AzureTracesFilter:
-        return self.__internal    
+        return self._internal    
     
     def property_val(self, property_val: str) -> typing.Self:    
         """
         Property name, auto-populated based on available traces.
         """
             
-        self.__internal.property_val = property_val
+        self._internal.property_val = property_val
     
         return self
     
     def operation(self, operation: str) -> typing.Self:    
         """
         Comparison operator to use. Either equals or not equals.
         """
             
-        self.__internal.operation = operation
+        self._internal.operation = operation
     
         return self
     
     def filters(self, filters: list[str]) -> typing.Self:    
         """
         Values to filter by.
         """
             
-        self.__internal.filters = filters
+        self._internal.filters = filters
     
         return self
     
 
 class AzureResourceGraphQuery(cogbuilder.Builder[azuremonitor.AzureResourceGraphQuery]):    
-    __internal: azuremonitor.AzureResourceGraphQuery
+    _internal: azuremonitor.AzureResourceGraphQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureResourceGraphQuery()
+        self._internal = azuremonitor.AzureResourceGraphQuery()
 
     def build(self) -> azuremonitor.AzureResourceGraphQuery:
-        return self.__internal    
+        return self._internal    
     
     def query(self, query: str) -> typing.Self:    
         """
         Azure Resource Graph KQL query to be executed.
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def result_format(self, result_format: str) -> typing.Self:    
         """
         Specifies the format results should be returned as. Defaults to table.
         """
             
-        self.__internal.result_format = result_format
+        self._internal.result_format = result_format
     
         return self
     
 
 class AzureMonitorResource(cogbuilder.Builder[azuremonitor.AzureMonitorResource]):    
-    __internal: azuremonitor.AzureMonitorResource
+    _internal: azuremonitor.AzureMonitorResource
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureMonitorResource()
+        self._internal = azuremonitor.AzureMonitorResource()
 
     def build(self) -> azuremonitor.AzureMonitorResource:
-        return self.__internal    
+        return self._internal    
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:        
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def resource_name(self, resource_name: str) -> typing.Self:        
-        self.__internal.resource_name = resource_name
+        self._internal.resource_name = resource_name
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:        
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
     def region(self, region: str) -> typing.Self:        
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
 
 class AzureMetricDimension(cogbuilder.Builder[azuremonitor.AzureMetricDimension]):    
-    __internal: azuremonitor.AzureMetricDimension
+    _internal: azuremonitor.AzureMetricDimension
 
     def __init__(self):
-        self.__internal = azuremonitor.AzureMetricDimension()
+        self._internal = azuremonitor.AzureMetricDimension()
 
     def build(self) -> azuremonitor.AzureMetricDimension:
-        return self.__internal    
+        return self._internal    
     
     def dimension(self, dimension: str) -> typing.Self:    
         """
         Name of Dimension to be filtered on.
         """
             
-        self.__internal.dimension = dimension
+        self._internal.dimension = dimension
     
         return self
     
     def operator(self, operator: str) -> typing.Self:    
         """
         String denoting the filter operation. Supports 'eq' - equals,'ne' - not equals, 'sw' - starts with. Note that some dimensions may not support all operators.
         """
             
-        self.__internal.operator = operator
+        self._internal.operator = operator
     
         return self
     
     def filters(self, filters: list[str]) -> typing.Self:    
         """
         Values to match with the filter.
         """
             
-        self.__internal.filters = filters
+        self._internal.filters = filters
     
         return self
     
     def filter_val(self, filter_val: str) -> typing.Self:    
         """
         @deprecated filter is deprecated in favour of filters to support multiselect.
         """
             
-        self.__internal.filter_val = filter_val
+        self._internal.filter_val = filter_val
     
         return self
     
 
 class BaseGrafanaTemplateVariableQuery(cogbuilder.Builder[azuremonitor.BaseGrafanaTemplateVariableQuery]):    
-    __internal: azuremonitor.BaseGrafanaTemplateVariableQuery
+    _internal: azuremonitor.BaseGrafanaTemplateVariableQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.BaseGrafanaTemplateVariableQuery()
+        self._internal = azuremonitor.BaseGrafanaTemplateVariableQuery()
 
     def build(self) -> azuremonitor.BaseGrafanaTemplateVariableQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
 
 class UnknownQuery(cogbuilder.Builder[azuremonitor.UnknownQuery]):    
-    __internal: azuremonitor.UnknownQuery
+    _internal: azuremonitor.UnknownQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.UnknownQuery()        
-        self.__internal.kind = "UnknownQuery"
+        self._internal = azuremonitor.UnknownQuery()        
+        self._internal.kind = "UnknownQuery"
 
     def build(self) -> azuremonitor.UnknownQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
 
 class AppInsightsMetricNameQuery(cogbuilder.Builder[azuremonitor.AppInsightsMetricNameQuery]):    
-    __internal: azuremonitor.AppInsightsMetricNameQuery
+    _internal: azuremonitor.AppInsightsMetricNameQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AppInsightsMetricNameQuery()        
-        self.__internal.kind = "AppInsightsMetricNameQuery"
+        self._internal = azuremonitor.AppInsightsMetricNameQuery()        
+        self._internal.kind = "AppInsightsMetricNameQuery"
 
     def build(self) -> azuremonitor.AppInsightsMetricNameQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
 
 class AppInsightsGroupByQuery(cogbuilder.Builder[azuremonitor.AppInsightsGroupByQuery]):    
-    __internal: azuremonitor.AppInsightsGroupByQuery
+    _internal: azuremonitor.AppInsightsGroupByQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.AppInsightsGroupByQuery()        
-        self.__internal.kind = "AppInsightsGroupByQuery"
+        self._internal = azuremonitor.AppInsightsGroupByQuery()        
+        self._internal.kind = "AppInsightsGroupByQuery"
 
     def build(self) -> azuremonitor.AppInsightsGroupByQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def metric_name(self, metric_name: str) -> typing.Self:        
-        self.__internal.metric_name = metric_name
+        self._internal.metric_name = metric_name
     
         return self
     
 
 class SubscriptionsQuery(cogbuilder.Builder[azuremonitor.SubscriptionsQuery]):    
-    __internal: azuremonitor.SubscriptionsQuery
+    _internal: azuremonitor.SubscriptionsQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.SubscriptionsQuery()        
-        self.__internal.kind = "SubscriptionsQuery"
+        self._internal = azuremonitor.SubscriptionsQuery()        
+        self._internal.kind = "SubscriptionsQuery"
 
     def build(self) -> azuremonitor.SubscriptionsQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
 
 class ResourceGroupsQuery(cogbuilder.Builder[azuremonitor.ResourceGroupsQuery]):    
-    __internal: azuremonitor.ResourceGroupsQuery
+    _internal: azuremonitor.ResourceGroupsQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.ResourceGroupsQuery()        
-        self.__internal.kind = "ResourceGroupsQuery"
+        self._internal = azuremonitor.ResourceGroupsQuery()        
+        self._internal.kind = "ResourceGroupsQuery"
 
     def build(self) -> azuremonitor.ResourceGroupsQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
 
 class ResourceNamesQuery(cogbuilder.Builder[azuremonitor.ResourceNamesQuery]):    
-    __internal: azuremonitor.ResourceNamesQuery
+    _internal: azuremonitor.ResourceNamesQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.ResourceNamesQuery()        
-        self.__internal.kind = "ResourceNamesQuery"
+        self._internal = azuremonitor.ResourceNamesQuery()        
+        self._internal.kind = "ResourceNamesQuery"
 
     def build(self) -> azuremonitor.ResourceNamesQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:        
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:        
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
 
 class MetricNamespaceQuery(cogbuilder.Builder[azuremonitor.MetricNamespaceQuery]):    
-    __internal: azuremonitor.MetricNamespaceQuery
+    _internal: azuremonitor.MetricNamespaceQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.MetricNamespaceQuery()        
-        self.__internal.kind = "MetricNamespaceQuery"
+        self._internal = azuremonitor.MetricNamespaceQuery()        
+        self._internal.kind = "MetricNamespaceQuery"
 
     def build(self) -> azuremonitor.MetricNamespaceQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:        
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:        
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
     def resource_name(self, resource_name: str) -> typing.Self:        
-        self.__internal.resource_name = resource_name
+        self._internal.resource_name = resource_name
     
         return self
     
 
 class MetricDefinitionsQuery(cogbuilder.Builder[azuremonitor.MetricDefinitionsQuery]):    
     """
     @deprecated Use MetricNamespaceQuery instead
     """
     
-    __internal: azuremonitor.MetricDefinitionsQuery
+    _internal: azuremonitor.MetricDefinitionsQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.MetricDefinitionsQuery()        
-        self.__internal.kind = "MetricDefinitionsQuery"
+        self._internal = azuremonitor.MetricDefinitionsQuery()        
+        self._internal.kind = "MetricDefinitionsQuery"
 
     def build(self) -> azuremonitor.MetricDefinitionsQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:        
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:        
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
     def resource_name(self, resource_name: str) -> typing.Self:        
-        self.__internal.resource_name = resource_name
+        self._internal.resource_name = resource_name
     
         return self
     
 
 class MetricNamesQuery(cogbuilder.Builder[azuremonitor.MetricNamesQuery]):    
-    __internal: azuremonitor.MetricNamesQuery
+    _internal: azuremonitor.MetricNamesQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.MetricNamesQuery()        
-        self.__internal.kind = "MetricNamesQuery"
+        self._internal = azuremonitor.MetricNamesQuery()        
+        self._internal.kind = "MetricNamesQuery"
 
     def build(self) -> azuremonitor.MetricNamesQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
     
     def resource_group(self, resource_group: str) -> typing.Self:        
-        self.__internal.resource_group = resource_group
+        self._internal.resource_group = resource_group
     
         return self
     
     def resource_name(self, resource_name: str) -> typing.Self:        
-        self.__internal.resource_name = resource_name
+        self._internal.resource_name = resource_name
     
         return self
     
     def metric_namespace(self, metric_namespace: str) -> typing.Self:        
-        self.__internal.metric_namespace = metric_namespace
+        self._internal.metric_namespace = metric_namespace
     
         return self
     
 
 class WorkspacesQuery(cogbuilder.Builder[azuremonitor.WorkspacesQuery]):    
-    __internal: azuremonitor.WorkspacesQuery
+    _internal: azuremonitor.WorkspacesQuery
 
     def __init__(self):
-        self.__internal = azuremonitor.WorkspacesQuery()        
-        self.__internal.kind = "WorkspacesQuery"
+        self._internal = azuremonitor.WorkspacesQuery()        
+        self._internal.kind = "WorkspacesQuery"
 
     def build(self) -> azuremonitor.WorkspacesQuery:
-        return self.__internal    
+        return self._internal    
     
     def raw_query(self, raw_query: str) -> typing.Self:        
-        self.__internal.raw_query = raw_query
+        self._internal.raw_query = raw_query
     
         return self
     
     def subscription(self, subscription: str) -> typing.Self:        
-        self.__internal.subscription = subscription
+        self._internal.subscription = subscription
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/barchart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/barchart.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "barchart"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "barchart"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,704 +244,684 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def x_field(self, x_field: str) -> typing.Self:    
         """
         Manually select which field from the dataset to represent the x field.
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.x_field = x_field
+        self._internal.options.x_field = x_field
     
         return self
     
     def color_by_field(self, color_by_field: str) -> typing.Self:    
         """
         Use the color value for a sibling field to color each bar value.
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.color_by_field = color_by_field
+        self._internal.options.color_by_field = color_by_field
     
         return self
     
     def orientation(self, orientation: common.VizOrientation) -> typing.Self:    
         """
         Controls the orientation of the bar chart, either vertical or horizontal.
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.orientation = orientation
+        self._internal.options.orientation = orientation
     
         return self
     
     def bar_radius(self, bar_radius: float) -> typing.Self:    
         """
         Controls the radius of each bar.
         """
             
         if not bar_radius >= 0:
             raise ValueError("bar_radius must be >= 0")
         if not bar_radius <= 0.5:
             raise ValueError("bar_radius must be <= 0.5")
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.bar_radius = bar_radius
+        self._internal.options.bar_radius = bar_radius
     
         return self
     
     def x_tick_label_rotation(self, x_tick_label_rotation: int) -> typing.Self:    
         """
         Controls the rotation of the x axis labels.
         """
             
         if not x_tick_label_rotation >= -90:
             raise ValueError("x_tick_label_rotation must be >= -90")
         if not x_tick_label_rotation <= 90:
             raise ValueError("x_tick_label_rotation must be <= 90")
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.x_tick_label_rotation = x_tick_label_rotation
+        self._internal.options.x_tick_label_rotation = x_tick_label_rotation
     
         return self
     
     def x_tick_label_max_length(self, x_tick_label_max_length: int) -> typing.Self:    
         """
         Sets the max length that a label can have before it is truncated.
         """
             
         if not x_tick_label_max_length >= 0:
             raise ValueError("x_tick_label_max_length must be >= 0")
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.x_tick_label_max_length = x_tick_label_max_length
+        self._internal.options.x_tick_label_max_length = x_tick_label_max_length
     
         return self
     
     def x_tick_label_spacing(self, x_tick_label_spacing: int) -> typing.Self:    
         """
         Controls the spacing between x axis labels.
         negative values indicate backwards skipping behavior
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.x_tick_label_spacing = x_tick_label_spacing
+        self._internal.options.x_tick_label_spacing = x_tick_label_spacing
     
         return self
     
     def stacking(self, stacking: common.StackingMode) -> typing.Self:    
         """
         Controls whether bars are stacked or not, either normally or in percent mode.
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.stacking = stacking
+        self._internal.options.stacking = stacking
     
         return self
     
     def show_value(self, show_value: common.VisibilityMode) -> typing.Self:    
         """
         This controls whether values are shown on top or to the left of bars.
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.show_value = show_value
+        self._internal.options.show_value = show_value
     
         return self
     
     def bar_width(self, bar_width: float) -> typing.Self:    
         """
         Controls the width of bars. 1 = Max width, 0 = Min width.
         """
             
         if not bar_width >= 0:
             raise ValueError("bar_width must be >= 0")
         if not bar_width <= 1:
             raise ValueError("bar_width must be <= 1")
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.bar_width = bar_width
+        self._internal.options.bar_width = bar_width
     
         return self
     
     def group_width(self, group_width: float) -> typing.Self:    
         """
         Controls the width of groups. 1 = max with, 0 = min width.
         """
             
         if not group_width >= 0:
             raise ValueError("group_width must be >= 0")
         if not group_width <= 1:
             raise ValueError("group_width must be <= 1")
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.group_width = group_width
+        self._internal.options.group_width = group_width
     
         return self
     
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
         legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.legend = legend_resource
     
         return self
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
         tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
     def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
         text_resource = text.build()
-        self.__internal.options.text = text_resource
+        self._internal.options.text = text_resource
     
         return self
     
     def full_highlight(self, full_highlight: bool) -> typing.Self:    
         """
         Enables mode which highlights the entire bar area and shows tooltip when cursor
         hovers over highlighted area
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = barchart.Options()
+        if self._internal.options is None:
+            self._internal.options = barchart.Options()
         
-        assert isinstance(self.__internal.options, barchart.Options)
+        assert isinstance(self._internal.options, barchart.Options)
         
-        self.__internal.options.full_highlight = full_highlight
+        self._internal.options.full_highlight = full_highlight
     
         return self
     
     def line_width(self, line_width: int) -> typing.Self:    
         """
         Controls line width of the bars.
         """
             
         if not line_width <= 10:
             raise ValueError("line_width must be <= 10")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def fill_opacity(self, fill_opacity: int) -> typing.Self:    
         """
         Controls the fill opacity of the bars.
         """
             
         if not fill_opacity <= 100:
             raise ValueError("fill_opacity must be <= 100")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:    
         """
         Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.
         Gradient appearance is influenced by the Fill opacity setting.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.gradient_mode = gradient_mode
+        self._internal.field_config.defaults.custom.gradient_mode = gradient_mode
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:    
         """
         Threshold rendering
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
+        self._internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = barchart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = barchart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, barchart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, barchart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/bargauge.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/bargauge.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "bargauge"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "bargauge"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,271 +244,241 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def display_mode(self, display_mode: common.BarGaugeDisplayMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.display_mode = display_mode
+        self._internal.options.display_mode = display_mode
     
         return self
     
     def value_mode(self, value_mode: common.BarGaugeValueMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
-        
-        assert isinstance(self.__internal.options, bargauge.Options)
-        
-        self.__internal.options.value_mode = value_mode
-    
-        return self
-    
-    def name_placement(self, name_placement: common.BarGaugeNamePlacement) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.name_placement = name_placement
+        self._internal.options.value_mode = value_mode
     
         return self
     
     def show_unfilled(self, show_unfilled: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
-        
-        assert isinstance(self.__internal.options, bargauge.Options)
-        
-        self.__internal.options.show_unfilled = show_unfilled
-    
-        return self
-    
-    def sizing(self, sizing: common.BarGaugeSizing) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.sizing = sizing
+        self._internal.options.show_unfilled = show_unfilled
     
         return self
     
     def min_viz_width(self, min_viz_width: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
-        
-        assert isinstance(self.__internal.options, bargauge.Options)
-        
-        self.__internal.options.min_viz_width = min_viz_width
-    
-        return self
-    
-    def min_viz_height(self, min_viz_height: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.min_viz_height = min_viz_height
+        self._internal.options.min_viz_width = min_viz_width
     
         return self
     
     def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
         reduce_options_resource = reduce_options.build()
-        self.__internal.options.reduce_options = reduce_options_resource
+        self._internal.options.reduce_options = reduce_options_resource
     
         return self
     
     def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
         text_resource = text.build()
-        self.__internal.options.text = text_resource
+        self._internal.options.text = text_resource
     
         return self
     
-    def max_viz_height(self, max_viz_height: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+    def min_viz_height(self, min_viz_height: int) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.max_viz_height = max_viz_height
+        self._internal.options.min_viz_height = min_viz_height
     
         return self
     
     def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = bargauge.Options()
+        if self._internal.options is None:
+            self._internal.options = bargauge.Options()
         
-        assert isinstance(self.__internal.options, bargauge.Options)
+        assert isinstance(self._internal.options, bargauge.Options)
         
-        self.__internal.options.orientation = orientation
+        self._internal.options.orientation = orientation
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/candlestick.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/trend.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import candlestick
+from ..models import trend
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "candlestick"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "trend"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,896 +244,806 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def mode(self, mode: candlestick.VizDisplayMode) -> typing.Self:    
-        """
-        Sets which dimensions are used for the visualization
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
-        
-        assert isinstance(self.__internal.options, candlestick.Options)
-        
-        self.__internal.options.mode = mode
-    
-        return self
-    
-    def candle_style(self, candle_style: candlestick.CandleStyle) -> typing.Self:    
-        """
-        Sets the style of the candlesticks
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
-        
-        assert isinstance(self.__internal.options, candlestick.Options)
-        
-        self.__internal.options.candle_style = candle_style
-    
-        return self
-    
-    def color_strategy(self, color_strategy: candlestick.ColorStrategy) -> typing.Self:    
-        """
-        Sets the color strategy for the candlesticks
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
-        
-        assert isinstance(self.__internal.options, candlestick.Options)
-        
-        self.__internal.options.color_strategy = color_strategy
-    
-        return self
-    
-    def fields(self, fields: candlestick.CandlestickFieldMap) -> typing.Self:    
-        """
-        Map fields to appropriate dimension
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
-        
-        assert isinstance(self.__internal.options, candlestick.Options)
-        
-        self.__internal.options.fields = fields
-    
-        return self
-    
-    def colors(self, colors: candlestick.CandlestickColors) -> typing.Self:    
-        """
-        Set which colors are used when the price movement is up or down
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
-        
-        assert isinstance(self.__internal.options, candlestick.Options)
-        
-        self.__internal.options.colors = colors
-    
-        return self
-    
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
+        if self._internal.options is None:
+            self._internal.options = trend.Options()
         
-        assert isinstance(self.__internal.options, candlestick.Options)
+        assert isinstance(self._internal.options, trend.Options)
         
         legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.legend = legend_resource
     
         return self
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
+        if self._internal.options is None:
+            self._internal.options = trend.Options()
         
-        assert isinstance(self.__internal.options, candlestick.Options)
+        assert isinstance(self._internal.options, trend.Options)
         
         tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
-    def include_all_fields(self, include_all_fields: bool) -> typing.Self:    
+    def x_field(self, x_field: str) -> typing.Self:    
         """
-        When enabled, all fields will be sent to the graph
+        Name of the x field to use (defaults to first number)
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = candlestick.Options()
+        if self._internal.options is None:
+            self._internal.options = trend.Options()
         
-        assert isinstance(self.__internal.options, candlestick.Options)
+        assert isinstance(self._internal.options, trend.Options)
         
-        self.__internal.options.include_all_fields = include_all_fields
+        self._internal.options.x_field = x_field
     
         return self
     
     def draw_style(self, draw_style: common.GraphDrawStyle) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.draw_style = draw_style
+        self._internal.field_config.defaults.custom.draw_style = draw_style
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.gradient_mode = gradient_mode
+        self._internal.field_config.defaults.custom.gradient_mode = gradient_mode
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
+        self._internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
     
         return self
     
     def line_color(self, line_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_color = line_color
+        self._internal.field_config.defaults.custom.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_interpolation = line_interpolation
+        self._internal.field_config.defaults.custom.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
         line_style_resource = line_style.build()
-        self.__internal.field_config.defaults.custom.line_style = line_style_resource
+        self._internal.field_config.defaults.custom.line_style = line_style_resource
     
         return self
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_color = fill_color
+        self._internal.field_config.defaults.custom.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.show_points = show_points
+        self._internal.field_config.defaults.custom.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_size = point_size
+        self._internal.field_config.defaults.custom.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_color = point_color
+        self._internal.field_config.defaults.custom.point_color = point_color
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_alignment = bar_alignment
+        self._internal.field_config.defaults.custom.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
+        self._internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
     
         return self
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
         stacking_resource = stacking.build()
-        self.__internal.field_config.defaults.custom.stacking = stacking_resource
+        self._internal.field_config.defaults.custom.stacking = stacking_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def transform(self, transform: common.GraphTransform) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.transform = transform
+        self._internal.field_config.defaults.custom.transform = transform
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.span_nulls = span_nulls
+        self._internal.field_config.defaults.custom.span_nulls = span_nulls
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_below_to = fill_below_to
+        self._internal.field_config.defaults.custom.fill_below_to = fill_below_to
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_symbol = point_symbol
+        self._internal.field_config.defaults.custom.point_symbol = point_symbol
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = candlestick.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = trend.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, candlestick.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, trend.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_max_width = bar_max_width
+        self._internal.field_config.defaults.custom.bar_max_width = bar_max_width
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/canvas.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/canvas.py`

 * *Files 17% similar despite different names*

```diff
@@ -8,186 +8,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "canvas"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "canvas"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,230 +243,202 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def inline_editing(self, inline_editing: bool) -> typing.Self:    
         """
         Enable inline editing
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = canvas.Options()
+        if self._internal.options is None:
+            self._internal.options = canvas.Options()
         
-        assert isinstance(self.__internal.options, canvas.Options)
+        assert isinstance(self._internal.options, canvas.Options)
         
-        self.__internal.options.inline_editing = inline_editing
+        self._internal.options.inline_editing = inline_editing
     
         return self
     
     def show_advanced_types(self, show_advanced_types: bool) -> typing.Self:    
         """
         Show all available element types
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = canvas.Options()
-        
-        assert isinstance(self.__internal.options, canvas.Options)
-        
-        self.__internal.options.show_advanced_types = show_advanced_types
-    
-        return self
-    
-    def pan_zoom(self, pan_zoom: bool) -> typing.Self:    
-        """
-        Enable pan and zoom
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = canvas.Options()
-        
-        assert isinstance(self.__internal.options, canvas.Options)
-        
-        self.__internal.options.pan_zoom = pan_zoom
-    
-        return self
-    
-    def infinite_pan(self, infinite_pan: bool) -> typing.Self:    
-        """
-        Enable infinite pan
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = canvas.Options()
+        if self._internal.options is None:
+            self._internal.options = canvas.Options()
         
-        assert isinstance(self.__internal.options, canvas.Options)
+        assert isinstance(self._internal.options, canvas.Options)
         
-        self.__internal.options.infinite_pan = infinite_pan
+        self._internal.options.show_advanced_types = show_advanced_types
     
         return self
     
     def root(self, root: canvas.CanvasOptionsRoot) -> typing.Self:    
         """
         The root element of canvas (frame), where all canvas elements are nested
         TODO: Figure out how to define a default value for this
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = canvas.Options()
+        if self._internal.options is None:
+            self._internal.options = canvas.Options()
         
-        assert isinstance(self.__internal.options, canvas.Options)
+        assert isinstance(self._internal.options, canvas.Options)
         
-        self.__internal.options.root = root
+        self._internal.options.root = root
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/cloudwatch.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/cloudwatch.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,906 +2,906 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import cloudwatch
 
 
 class MetricStat(cogbuilder.Builder[cloudwatch.MetricStat]):    
-    __internal: cloudwatch.MetricStat
+    _internal: cloudwatch.MetricStat
 
     def __init__(self):
-        self.__internal = cloudwatch.MetricStat()
+        self._internal = cloudwatch.MetricStat()
 
     def build(self) -> cloudwatch.MetricStat:
-        return self.__internal    
+        return self._internal    
     
     def region(self, region: str) -> typing.Self:    
         """
         AWS region to query for the metric
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
     def namespace(self, namespace: str) -> typing.Self:    
         """
         A namespace is a container for CloudWatch metrics. Metrics in different namespaces are isolated from each other, so that metrics from different applications are not mistakenly aggregated into the same statistics. For example, Amazon EC2 uses the AWS/EC2 namespace.
         """
             
-        self.__internal.namespace = namespace
+        self._internal.namespace = namespace
     
         return self
     
     def metric_name(self, metric_name: str) -> typing.Self:    
         """
         Name of the metric
         """
             
-        self.__internal.metric_name = metric_name
+        self._internal.metric_name = metric_name
     
         return self
     
     def dimensions(self, dimensions: cloudwatch.Dimensions) -> typing.Self:    
         """
         The dimensions of the metric
         """
             
-        self.__internal.dimensions = dimensions
+        self._internal.dimensions = dimensions
     
         return self
     
     def match_exact(self, match_exact: bool) -> typing.Self:    
         """
         Only show metrics that exactly match all defined dimension names.
         """
             
-        self.__internal.match_exact = match_exact
+        self._internal.match_exact = match_exact
     
         return self
     
     def period(self, period: str) -> typing.Self:    
         """
         The length of time associated with a specific Amazon CloudWatch statistic. Can be specified by a number of seconds, 'auto', or as a duration string e.g. '15m' being 15 minutes
         """
             
-        self.__internal.period = period
+        self._internal.period = period
     
         return self
     
     def account_id(self, account_id: str) -> typing.Self:    
         """
         The ID of the AWS account to query for the metric, specifying `all` will query all accounts that the monitoring account is permitted to query.
         """
             
-        self.__internal.account_id = account_id
+        self._internal.account_id = account_id
     
         return self
     
     def statistic(self, statistic: str) -> typing.Self:    
         """
         Metric data aggregations over specified periods of time. For detailed definitions of the statistics supported by CloudWatch, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html.
         """
             
-        self.__internal.statistic = statistic
+        self._internal.statistic = statistic
     
         return self
     
     def statistics(self, statistics: list[str]) -> typing.Self:    
         """
         @deprecated use statistic
         """
             
-        self.__internal.statistics = statistics
+        self._internal.statistics = statistics
     
         return self
     
 
 class CloudWatchMetricsQuery(cogbuilder.Builder[cloudwatch.CloudWatchMetricsQuery]):    
     """
     Shape of a CloudWatch Metrics query
     """
     
-    __internal: cloudwatch.CloudWatchMetricsQuery
+    _internal: cloudwatch.CloudWatchMetricsQuery
 
     def __init__(self):
-        self.__internal = cloudwatch.CloudWatchMetricsQuery()
+        self._internal = cloudwatch.CloudWatchMetricsQuery()
 
     def build(self) -> cloudwatch.CloudWatchMetricsQuery:
-        return self.__internal    
+        return self._internal    
     
     def query_mode(self, query_mode: cloudwatch.CloudWatchQueryMode) -> typing.Self:    
         """
         Whether a query is a Metrics, Logs, or Annotations query
         """
             
-        self.__internal.query_mode = query_mode
+        self._internal.query_mode = query_mode
     
         return self
     
     def metric_query_type(self, metric_query_type: cloudwatch.MetricQueryType) -> typing.Self:    
         """
         Whether to use a metric search or metric query. Metric query is referred to as "Metrics Insights" in the AWS console.
         """
             
-        self.__internal.metric_query_type = metric_query_type
+        self._internal.metric_query_type = metric_query_type
     
         return self
     
     def metric_editor_mode(self, metric_editor_mode: cloudwatch.MetricEditorMode) -> typing.Self:    
         """
         Whether to use the query builder or code editor to create the query
         """
             
-        self.__internal.metric_editor_mode = metric_editor_mode
+        self._internal.metric_editor_mode = metric_editor_mode
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:    
         """
         ID can be used to reference other queries in math expressions. The ID can include numbers, letters, and underscore, and must start with a lowercase letter.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def alias(self, alias: str) -> typing.Self:    
         """
         Deprecated: use label
         @deprecated use label
         """
             
-        self.__internal.alias = alias
+        self._internal.alias = alias
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Change the time series legend names using dynamic labels. See https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html for more details.
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def expression(self, expression: str) -> typing.Self:    
         """
         Math expression query
         """
             
-        self.__internal.expression = expression
+        self._internal.expression = expression
     
         return self
     
     def sql_expression(self, sql_expression: str) -> typing.Self:    
         """
         When the metric query type is `metricQueryType` is set to `Query`, this field is used to specify the query string.
         """
             
-        self.__internal.sql_expression = sql_expression
+        self._internal.sql_expression = sql_expression
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def region(self, region: str) -> typing.Self:    
         """
         AWS region to query for the metric
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
     def namespace(self, namespace: str) -> typing.Self:    
         """
         A namespace is a container for CloudWatch metrics. Metrics in different namespaces are isolated from each other, so that metrics from different applications are not mistakenly aggregated into the same statistics. For example, Amazon EC2 uses the AWS/EC2 namespace.
         """
             
-        self.__internal.namespace = namespace
+        self._internal.namespace = namespace
     
         return self
     
     def metric_name(self, metric_name: str) -> typing.Self:    
         """
         Name of the metric
         """
             
-        self.__internal.metric_name = metric_name
+        self._internal.metric_name = metric_name
     
         return self
     
     def dimensions(self, dimensions: cloudwatch.Dimensions) -> typing.Self:    
         """
         The dimensions of the metric
         """
             
-        self.__internal.dimensions = dimensions
+        self._internal.dimensions = dimensions
     
         return self
     
     def match_exact(self, match_exact: bool) -> typing.Self:    
         """
         Only show metrics that exactly match all defined dimension names.
         """
             
-        self.__internal.match_exact = match_exact
+        self._internal.match_exact = match_exact
     
         return self
     
     def period(self, period: str) -> typing.Self:    
         """
         The length of time associated with a specific Amazon CloudWatch statistic. Can be specified by a number of seconds, 'auto', or as a duration string e.g. '15m' being 15 minutes
         """
             
-        self.__internal.period = period
+        self._internal.period = period
     
         return self
     
     def account_id(self, account_id: str) -> typing.Self:    
         """
         The ID of the AWS account to query for the metric, specifying `all` will query all accounts that the monitoring account is permitted to query.
         """
             
-        self.__internal.account_id = account_id
+        self._internal.account_id = account_id
     
         return self
     
     def statistic(self, statistic: str) -> typing.Self:    
         """
         Metric data aggregations over specified periods of time. For detailed definitions of the statistics supported by CloudWatch, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html.
         """
             
-        self.__internal.statistic = statistic
+        self._internal.statistic = statistic
     
         return self
     
     def sql(self, sql: cogbuilder.Builder[cloudwatch.SQLExpression]) -> typing.Self:    
         """
         When the metric query type is `metricQueryType` is set to `Query` and the `metricEditorMode` is set to `Builder`, this field is used to build up an object representation of a SQL query.
         """
             
         sql_resource = sql.build()
-        self.__internal.sql = sql_resource
+        self._internal.sql = sql_resource
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def statistics(self, statistics: list[str]) -> typing.Self:    
         """
         @deprecated use statistic
         """
             
-        self.__internal.statistics = statistics
+        self._internal.statistics = statistics
     
         return self
     
 
 class SQLExpression(cogbuilder.Builder[cloudwatch.SQLExpression]):    
-    __internal: cloudwatch.SQLExpression
+    _internal: cloudwatch.SQLExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.SQLExpression()
+        self._internal = cloudwatch.SQLExpression()
 
     def build(self) -> cloudwatch.SQLExpression:
-        return self.__internal    
+        return self._internal    
     
     def select(self, select: cogbuilder.Builder[cloudwatch.QueryEditorFunctionExpression]) -> typing.Self:    
         """
         SELECT part of the SQL expression
         """
             
         select_resource = select.build()
-        self.__internal.select = select_resource
+        self._internal.select = select_resource
     
         return self
     
     def from_val(self, from_val: typing.Union[cogbuilder.Builder[cloudwatch.QueryEditorPropertyExpression], cogbuilder.Builder[cloudwatch.QueryEditorFunctionExpression]]) -> typing.Self:    
         """
         FROM part of the SQL expression
         """
             
         from_val_resource = from_val.build()
-        self.__internal.from_val = from_val_resource
+        self._internal.from_val = from_val_resource
     
         return self
     
     def where(self, where: cogbuilder.Builder[cloudwatch.QueryEditorArrayExpression]) -> typing.Self:    
         """
         WHERE part of the SQL expression
         """
             
         where_resource = where.build()
-        self.__internal.where = where_resource
+        self._internal.where = where_resource
     
         return self
     
     def group_by(self, group_by: cogbuilder.Builder[cloudwatch.QueryEditorArrayExpression]) -> typing.Self:    
         """
         GROUP BY part of the SQL expression
         """
             
         group_by_resource = group_by.build()
-        self.__internal.group_by = group_by_resource
+        self._internal.group_by = group_by_resource
     
         return self
     
     def order_by(self, order_by: cogbuilder.Builder[cloudwatch.QueryEditorFunctionExpression]) -> typing.Self:    
         """
         ORDER BY part of the SQL expression
         """
             
         order_by_resource = order_by.build()
-        self.__internal.order_by = order_by_resource
+        self._internal.order_by = order_by_resource
     
         return self
     
     def order_by_direction(self, order_by_direction: str) -> typing.Self:    
         """
         The sort order of the SQL expression, `ASC` or `DESC`
         """
             
-        self.__internal.order_by_direction = order_by_direction
+        self._internal.order_by_direction = order_by_direction
     
         return self
     
     def limit(self, limit: int) -> typing.Self:    
         """
         LIMIT part of the SQL expression
         """
             
-        self.__internal.limit = limit
+        self._internal.limit = limit
     
         return self
     
 
 class QueryEditorFunctionExpression(cogbuilder.Builder[cloudwatch.QueryEditorFunctionExpression]):    
-    __internal: cloudwatch.QueryEditorFunctionExpression
+    _internal: cloudwatch.QueryEditorFunctionExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorFunctionExpression()        
-        self.__internal.type_val = "function"
+        self._internal = cloudwatch.QueryEditorFunctionExpression()        
+        self._internal.type_val = "function"
 
     def build(self) -> cloudwatch.QueryEditorFunctionExpression:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def parameters(self, parameters: list[cogbuilder.Builder[cloudwatch.QueryEditorFunctionParameterExpression]]) -> typing.Self:        
         parameters_resources = [r1.build() for r1 in parameters]
-        self.__internal.parameters = parameters_resources
+        self._internal.parameters = parameters_resources
     
         return self
     
 
 class QueryEditorFunctionParameterExpression(cogbuilder.Builder[cloudwatch.QueryEditorFunctionParameterExpression]):    
-    __internal: cloudwatch.QueryEditorFunctionParameterExpression
+    _internal: cloudwatch.QueryEditorFunctionParameterExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorFunctionParameterExpression()        
-        self.__internal.type_val = "functionParameter"
+        self._internal = cloudwatch.QueryEditorFunctionParameterExpression()        
+        self._internal.type_val = "functionParameter"
 
     def build(self) -> cloudwatch.QueryEditorFunctionParameterExpression:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
 
 class QueryEditorPropertyExpression(cogbuilder.Builder[cloudwatch.QueryEditorPropertyExpression]):    
-    __internal: cloudwatch.QueryEditorPropertyExpression
+    _internal: cloudwatch.QueryEditorPropertyExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorPropertyExpression()        
-        self.__internal.type_val = "property"
+        self._internal = cloudwatch.QueryEditorPropertyExpression()        
+        self._internal.type_val = "property"
 
     def build(self) -> cloudwatch.QueryEditorPropertyExpression:
-        return self.__internal    
+        return self._internal    
     
     def property_val(self, property_val: cogbuilder.Builder[cloudwatch.QueryEditorProperty]) -> typing.Self:        
         property_val_resource = property_val.build()
-        self.__internal.property_val = property_val_resource
+        self._internal.property_val = property_val_resource
     
         return self
     
 
 class QueryEditorGroupByExpression(cogbuilder.Builder[cloudwatch.QueryEditorGroupByExpression]):    
-    __internal: cloudwatch.QueryEditorGroupByExpression
+    _internal: cloudwatch.QueryEditorGroupByExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorGroupByExpression()        
-        self.__internal.type_val = "groupBy"
+        self._internal = cloudwatch.QueryEditorGroupByExpression()        
+        self._internal.type_val = "groupBy"
 
     def build(self) -> cloudwatch.QueryEditorGroupByExpression:
-        return self.__internal    
+        return self._internal    
     
     def property_val(self, property_val: cogbuilder.Builder[cloudwatch.QueryEditorProperty]) -> typing.Self:        
         property_val_resource = property_val.build()
-        self.__internal.property_val = property_val_resource
+        self._internal.property_val = property_val_resource
     
         return self
     
 
 class QueryEditorOperatorExpression(cogbuilder.Builder[cloudwatch.QueryEditorOperatorExpression]):    
-    __internal: cloudwatch.QueryEditorOperatorExpression
+    _internal: cloudwatch.QueryEditorOperatorExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorOperatorExpression()        
-        self.__internal.type_val = "operator"
+        self._internal = cloudwatch.QueryEditorOperatorExpression()        
+        self._internal.type_val = "operator"
 
     def build(self) -> cloudwatch.QueryEditorOperatorExpression:
-        return self.__internal    
+        return self._internal    
     
     def property_val(self, property_val: cogbuilder.Builder[cloudwatch.QueryEditorProperty]) -> typing.Self:        
         property_val_resource = property_val.build()
-        self.__internal.property_val = property_val_resource
+        self._internal.property_val = property_val_resource
     
         return self
     
     def operator(self, operator: cogbuilder.Builder[cloudwatch.QueryEditorOperator]) -> typing.Self:    
         """
         TS type is operator: QueryEditorOperator<QueryEditorOperatorValueType>, extended in veneer
         """
             
         operator_resource = operator.build()
-        self.__internal.operator = operator_resource
+        self._internal.operator = operator_resource
     
         return self
     
 
 class QueryEditorOperator(cogbuilder.Builder[cloudwatch.QueryEditorOperator]):    
     """
     TS type is QueryEditorOperator<T extends QueryEditorOperatorValueType>, extended in veneer
     """
     
-    __internal: cloudwatch.QueryEditorOperator
+    _internal: cloudwatch.QueryEditorOperator
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorOperator()
+        self._internal = cloudwatch.QueryEditorOperator()
 
     def build(self) -> cloudwatch.QueryEditorOperator:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def value(self, value: typing.Union[str, bool, int, list[cloudwatch.QueryEditorOperatorType]]) -> typing.Self:        
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
 
 class QueryEditorProperty(cogbuilder.Builder[cloudwatch.QueryEditorProperty]):    
-    __internal: cloudwatch.QueryEditorProperty
+    _internal: cloudwatch.QueryEditorProperty
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorProperty()
+        self._internal = cloudwatch.QueryEditorProperty()
 
     def build(self) -> cloudwatch.QueryEditorProperty:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: cloudwatch.QueryEditorPropertyType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
 
 class QueryEditorArrayExpression(cogbuilder.Builder[cloudwatch.QueryEditorArrayExpression]):    
-    __internal: cloudwatch.QueryEditorArrayExpression
+    _internal: cloudwatch.QueryEditorArrayExpression
 
     def __init__(self):
-        self.__internal = cloudwatch.QueryEditorArrayExpression()
+        self._internal = cloudwatch.QueryEditorArrayExpression()
 
     def build(self) -> cloudwatch.QueryEditorArrayExpression:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: typing.Literal["and", "or"]) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def expressions(self, expressions: list[cloudwatch.QueryEditorExpression]) -> typing.Self:        
-        self.__internal.expressions = expressions
+        self._internal.expressions = expressions
     
         return self
     
 
 class CloudWatchLogsQuery(cogbuilder.Builder[cloudwatch.CloudWatchLogsQuery]):    
     """
     Shape of a CloudWatch Logs query
     """
     
-    __internal: cloudwatch.CloudWatchLogsQuery
+    _internal: cloudwatch.CloudWatchLogsQuery
 
     def __init__(self):
-        self.__internal = cloudwatch.CloudWatchLogsQuery()
+        self._internal = cloudwatch.CloudWatchLogsQuery()
 
     def build(self) -> cloudwatch.CloudWatchLogsQuery:
-        return self.__internal    
+        return self._internal    
     
     def query_mode(self, query_mode: cloudwatch.CloudWatchQueryMode) -> typing.Self:    
         """
         Whether a query is a Metrics, Logs, or Annotations query
         """
             
-        self.__internal.query_mode = query_mode
+        self._internal.query_mode = query_mode
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def region(self, region: str) -> typing.Self:    
         """
         AWS region to query for the logs
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
     def expression(self, expression: str) -> typing.Self:    
         """
         The CloudWatch Logs Insights query to execute
         """
             
-        self.__internal.expression = expression
+        self._internal.expression = expression
     
         return self
     
     def stats_groups(self, stats_groups: list[str]) -> typing.Self:    
         """
         Fields to group the results by, this field is automatically populated whenever the query is updated
         """
             
-        self.__internal.stats_groups = stats_groups
+        self._internal.stats_groups = stats_groups
     
         return self
     
     def log_groups(self, log_groups: list[cogbuilder.Builder[cloudwatch.LogGroup]]) -> typing.Self:    
         """
         Log groups to query
         """
             
         log_groups_resources = [r1.build() for r1 in log_groups]
-        self.__internal.log_groups = log_groups_resources
+        self._internal.log_groups = log_groups_resources
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def log_group_names(self, log_group_names: list[str]) -> typing.Self:    
         """
         @deprecated use logGroups
         """
             
-        self.__internal.log_group_names = log_group_names
+        self._internal.log_group_names = log_group_names
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
 
 class LogGroup(cogbuilder.Builder[cloudwatch.LogGroup]):    
-    __internal: cloudwatch.LogGroup
+    _internal: cloudwatch.LogGroup
 
     def __init__(self):
-        self.__internal = cloudwatch.LogGroup()
+        self._internal = cloudwatch.LogGroup()
 
     def build(self) -> cloudwatch.LogGroup:
-        return self.__internal    
+        return self._internal    
     
     def arn(self, arn: str) -> typing.Self:    
         """
         ARN of the log group
         """
             
-        self.__internal.arn = arn
+        self._internal.arn = arn
     
         return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of the log group
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def account_id(self, account_id: str) -> typing.Self:    
         """
         AccountId of the log group
         """
             
-        self.__internal.account_id = account_id
+        self._internal.account_id = account_id
     
         return self
     
     def account_label(self, account_label: str) -> typing.Self:    
         """
         Label of the log group
         """
             
-        self.__internal.account_label = account_label
+        self._internal.account_label = account_label
     
         return self
     
 
 class CloudWatchAnnotationQuery(cogbuilder.Builder[cloudwatch.CloudWatchAnnotationQuery]):    
     """
     Shape of a CloudWatch Annotation query
     TS type is CloudWatchDefaultQuery = Omit<CloudWatchLogsQuery, 'queryMode'> & CloudWatchMetricsQuery, declared in veneer
     #CloudWatchDefaultQuery: #CloudWatchLogsQuery & #CloudWatchMetricsQuery @cuetsy(kind="type")
     """
     
-    __internal: cloudwatch.CloudWatchAnnotationQuery
+    _internal: cloudwatch.CloudWatchAnnotationQuery
 
     def __init__(self):
-        self.__internal = cloudwatch.CloudWatchAnnotationQuery()
+        self._internal = cloudwatch.CloudWatchAnnotationQuery()
 
     def build(self) -> cloudwatch.CloudWatchAnnotationQuery:
-        return self.__internal    
+        return self._internal    
     
     def query_mode(self, query_mode: cloudwatch.CloudWatchQueryMode) -> typing.Self:    
         """
         Whether a query is a Metrics, Logs, or Annotations query
         """
             
-        self.__internal.query_mode = query_mode
+        self._internal.query_mode = query_mode
     
         return self
     
     def prefix_matching(self, prefix_matching: bool) -> typing.Self:    
         """
         Enable matching on the prefix of the action name or alarm name, specify the prefixes with actionPrefix and/or alarmNamePrefix
         """
             
-        self.__internal.prefix_matching = prefix_matching
+        self._internal.prefix_matching = prefix_matching
     
         return self
     
     def action_prefix(self, action_prefix: str) -> typing.Self:    
         """
         Use this parameter to filter the results of the operation to only those alarms
         that use a certain alarm action. For example, you could specify the ARN of
         an SNS topic to find all alarms that send notifications to that topic.
         e.g. `arn:aws:sns:us-east-1:123456789012:my-app-` would match `arn:aws:sns:us-east-1:123456789012:my-app-action`
         but not match `arn:aws:sns:us-east-1:123456789012:your-app-action`
         """
             
-        self.__internal.action_prefix = action_prefix
+        self._internal.action_prefix = action_prefix
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def region(self, region: str) -> typing.Self:    
         """
         AWS region to query for the metric
         """
             
-        self.__internal.region = region
+        self._internal.region = region
     
         return self
     
     def namespace(self, namespace: str) -> typing.Self:    
         """
         A namespace is a container for CloudWatch metrics. Metrics in different namespaces are isolated from each other, so that metrics from different applications are not mistakenly aggregated into the same statistics. For example, Amazon EC2 uses the AWS/EC2 namespace.
         """
             
-        self.__internal.namespace = namespace
+        self._internal.namespace = namespace
     
         return self
     
     def metric_name(self, metric_name: str) -> typing.Self:    
         """
         Name of the metric
         """
             
-        self.__internal.metric_name = metric_name
+        self._internal.metric_name = metric_name
     
         return self
     
     def dimensions(self, dimensions: cloudwatch.Dimensions) -> typing.Self:    
         """
         The dimensions of the metric
         """
             
-        self.__internal.dimensions = dimensions
+        self._internal.dimensions = dimensions
     
         return self
     
     def match_exact(self, match_exact: bool) -> typing.Self:    
         """
         Only show metrics that exactly match all defined dimension names.
         """
             
-        self.__internal.match_exact = match_exact
+        self._internal.match_exact = match_exact
     
         return self
     
     def period(self, period: str) -> typing.Self:    
         """
         The length of time associated with a specific Amazon CloudWatch statistic. Can be specified by a number of seconds, 'auto', or as a duration string e.g. '15m' being 15 minutes
         """
             
-        self.__internal.period = period
+        self._internal.period = period
     
         return self
     
     def account_id(self, account_id: str) -> typing.Self:    
         """
         The ID of the AWS account to query for the metric, specifying `all` will query all accounts that the monitoring account is permitted to query.
         """
             
-        self.__internal.account_id = account_id
+        self._internal.account_id = account_id
     
         return self
     
     def statistic(self, statistic: str) -> typing.Self:    
         """
         Metric data aggregations over specified periods of time. For detailed definitions of the statistics supported by CloudWatch, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html.
         """
             
-        self.__internal.statistic = statistic
+        self._internal.statistic = statistic
     
         return self
     
     def alarm_name_prefix(self, alarm_name_prefix: str) -> typing.Self:    
         """
         An alarm name prefix. If you specify this parameter, you receive information
         about all alarms that have names that start with this prefix.
         e.g. `my-team-service-` would match `my-team-service-high-cpu` but not match `your-team-service-high-cpu`
         """
             
-        self.__internal.alarm_name_prefix = alarm_name_prefix
+        self._internal.alarm_name_prefix = alarm_name_prefix
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def statistics(self, statistics: list[str]) -> typing.Self:    
         """
         @deprecated use statistic
         """
             
-        self.__internal.statistics = statistics
+        self._internal.statistics = statistics
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/common.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/common.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,1723 +6,1693 @@
 
 
 class DataSourceJsonData(cogbuilder.Builder[common.DataSourceJsonData]):    
     """
     TODO docs
     """
     
-    __internal: common.DataSourceJsonData
+    _internal: common.DataSourceJsonData
 
     def __init__(self):
-        self.__internal = common.DataSourceJsonData()
+        self._internal = common.DataSourceJsonData()
 
     def build(self) -> common.DataSourceJsonData:
-        return self.__internal    
+        return self._internal    
     
     def auth_type(self, auth_type: str) -> typing.Self:        
-        self.__internal.auth_type = auth_type
+        self._internal.auth_type = auth_type
     
         return self
     
     def default_region(self, default_region: str) -> typing.Self:        
-        self.__internal.default_region = default_region
+        self._internal.default_region = default_region
     
         return self
     
     def profile(self, profile: str) -> typing.Self:        
-        self.__internal.profile = profile
+        self._internal.profile = profile
     
         return self
     
     def manage_alerts(self, manage_alerts: bool) -> typing.Self:        
-        self.__internal.manage_alerts = manage_alerts
+        self._internal.manage_alerts = manage_alerts
     
         return self
     
     def alertmanager_uid(self, alertmanager_uid: str) -> typing.Self:        
-        self.__internal.alertmanager_uid = alertmanager_uid
+        self._internal.alertmanager_uid = alertmanager_uid
     
         return self
     
 
 class DataQuery(cogbuilder.Builder[common.DataQuery]):    
     """
     These are the common properties available to all queries in all datasources.
     Specific implementations will *extend* this interface, adding the required
     properties for the given context.
     """
     
-    __internal: common.DataQuery
+    _internal: common.DataQuery
 
     def __init__(self):
-        self.__internal = common.DataQuery()
+        self._internal = common.DataQuery()
 
     def build(self) -> common.DataQuery:
-        return self.__internal    
+        return self._internal    
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
 
 class BaseDimensionConfig(cogbuilder.Builder[common.BaseDimensionConfig]):    
-    __internal: common.BaseDimensionConfig
+    _internal: common.BaseDimensionConfig
 
     def __init__(self):
-        self.__internal = common.BaseDimensionConfig()
+        self._internal = common.BaseDimensionConfig()
 
     def build(self) -> common.BaseDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
 
 class ScaleDimensionConfig(cogbuilder.Builder[common.ScaleDimensionConfig]):    
-    __internal: common.ScaleDimensionConfig
+    _internal: common.ScaleDimensionConfig
 
     def __init__(self):
-        self.__internal = common.ScaleDimensionConfig()
+        self._internal = common.ScaleDimensionConfig()
 
     def build(self) -> common.ScaleDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def min_val(self, min_val: float) -> typing.Self:        
-        self.__internal.min_val = min_val
+        self._internal.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:        
-        self.__internal.max_val = max_val
+        self._internal.max_val = max_val
     
         return self
     
     def fixed(self, fixed: float) -> typing.Self:        
-        self.__internal.fixed = fixed
+        self._internal.fixed = fixed
     
         return self
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def mode(self, mode: common.ScaleDimensionMode) -> typing.Self:    
         """
         | *"linear"
         """
             
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
 
 class ColorDimensionConfig(cogbuilder.Builder[common.ColorDimensionConfig]):    
-    __internal: common.ColorDimensionConfig
+    _internal: common.ColorDimensionConfig
 
     def __init__(self):
-        self.__internal = common.ColorDimensionConfig()
+        self._internal = common.ColorDimensionConfig()
 
     def build(self) -> common.ColorDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def fixed(self, fixed: str) -> typing.Self:    
         """
         color value
         """
             
-        self.__internal.fixed = fixed
+        self._internal.fixed = fixed
     
         return self
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
 
 class ScalarDimensionConfig(cogbuilder.Builder[common.ScalarDimensionConfig]):    
-    __internal: common.ScalarDimensionConfig
+    _internal: common.ScalarDimensionConfig
 
     def __init__(self):
-        self.__internal = common.ScalarDimensionConfig()
+        self._internal = common.ScalarDimensionConfig()
 
     def build(self) -> common.ScalarDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def min_val(self, min_val: float) -> typing.Self:        
-        self.__internal.min_val = min_val
+        self._internal.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:        
-        self.__internal.max_val = max_val
+        self._internal.max_val = max_val
     
         return self
     
     def fixed(self, fixed: float) -> typing.Self:        
-        self.__internal.fixed = fixed
+        self._internal.fixed = fixed
     
         return self
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def mode(self, mode: common.ScalarDimensionMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
 
 class TextDimensionConfig(cogbuilder.Builder[common.TextDimensionConfig]):    
-    __internal: common.TextDimensionConfig
+    _internal: common.TextDimensionConfig
 
     def __init__(self):
-        self.__internal = common.TextDimensionConfig()
+        self._internal = common.TextDimensionConfig()
 
     def build(self) -> common.TextDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.TextDimensionMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def fixed(self, fixed: str) -> typing.Self:        
-        self.__internal.fixed = fixed
+        self._internal.fixed = fixed
     
         return self
     
 
 class MapLayerOptions(cogbuilder.Builder[common.MapLayerOptions]):    
-    __internal: common.MapLayerOptions
+    _internal: common.MapLayerOptions
 
     def __init__(self):
-        self.__internal = common.MapLayerOptions()
+        self._internal = common.MapLayerOptions()
 
     def build(self) -> common.MapLayerOptions:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: str) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def name(self, name: str) -> typing.Self:    
         """
         configured unique display name
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def config(self, config: object) -> typing.Self:    
         """
         Custom options depending on the type
         """
             
-        self.__internal.config = config
+        self._internal.config = config
     
         return self
     
     def location(self, location: cogbuilder.Builder[common.FrameGeometrySource]) -> typing.Self:    
         """
         Common method to define geometry fields
         """
             
         location_resource = location.build()
-        self.__internal.location = location_resource
+        self._internal.location = location_resource
     
         return self
     
     def filter_data(self, filter_data: object) -> typing.Self:    
         """
         Defines a frame MatcherConfig that may filter data for the given layer
         """
             
-        self.__internal.filter_data = filter_data
+        self._internal.filter_data = filter_data
     
         return self
     
     def opacity(self, opacity: int) -> typing.Self:    
         """
         Common properties:
         https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html
         Layer opacity (0-1)
         """
             
-        self.__internal.opacity = opacity
+        self._internal.opacity = opacity
     
         return self
     
     def tooltip(self, tooltip: bool) -> typing.Self:    
         """
         Check tooltip (defaults to true)
         """
             
-        self.__internal.tooltip = tooltip
+        self._internal.tooltip = tooltip
     
         return self
     
 
 class HeatmapCalculationBucketConfig(cogbuilder.Builder[common.HeatmapCalculationBucketConfig]):    
-    __internal: common.HeatmapCalculationBucketConfig
+    _internal: common.HeatmapCalculationBucketConfig
 
     def __init__(self):
-        self.__internal = common.HeatmapCalculationBucketConfig()
+        self._internal = common.HeatmapCalculationBucketConfig()
 
     def build(self) -> common.HeatmapCalculationBucketConfig:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.HeatmapCalculationMode) -> typing.Self:    
         """
         Sets the bucket calculation mode
         """
             
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def value(self, value: str) -> typing.Self:    
         """
         The number of buckets to use for the axis in the heatmap
         """
             
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
     def scale(self, scale: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:    
         """
         Controls the scale of the buckets
         """
             
         scale_resource = scale.build()
-        self.__internal.scale = scale_resource
+        self._internal.scale = scale_resource
     
         return self
     
 
 class LineStyle(cogbuilder.Builder[common.LineStyle]):    
     """
     TODO docs
     """
     
-    __internal: common.LineStyle
+    _internal: common.LineStyle
 
     def __init__(self):
-        self.__internal = common.LineStyle()
+        self._internal = common.LineStyle()
 
     def build(self) -> common.LineStyle:
-        return self.__internal    
+        return self._internal    
     
     def fill(self, fill: typing.Literal["solid", "dash", "dot", "square"]) -> typing.Self:        
-        self.__internal.fill = fill
+        self._internal.fill = fill
     
         return self
     
     def dash(self, dash: list[float]) -> typing.Self:        
-        self.__internal.dash = dash
+        self._internal.dash = dash
     
         return self
     
 
 class LineConfig(cogbuilder.Builder[common.LineConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.LineConfig
+    _internal: common.LineConfig
 
     def __init__(self):
-        self.__internal = common.LineConfig()
+        self._internal = common.LineConfig()
 
     def build(self) -> common.LineConfig:
-        return self.__internal    
+        return self._internal    
     
     def line_color(self, line_color: str) -> typing.Self:        
-        self.__internal.line_color = line_color
+        self._internal.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        self.__internal.line_width = line_width
+        self._internal.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        self.__internal.line_interpolation = line_interpolation
+        self._internal.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
         line_style_resource = line_style.build()
-        self.__internal.line_style = line_style_resource
+        self._internal.line_style = line_style_resource
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        self.__internal.span_nulls = span_nulls
+        self._internal.span_nulls = span_nulls
     
         return self
     
 
 class BarConfig(cogbuilder.Builder[common.BarConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.BarConfig
+    _internal: common.BarConfig
 
     def __init__(self):
-        self.__internal = common.BarConfig()
+        self._internal = common.BarConfig()
 
     def build(self) -> common.BarConfig:
-        return self.__internal    
+        return self._internal    
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        self.__internal.bar_alignment = bar_alignment
+        self._internal.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        self.__internal.bar_width_factor = bar_width_factor
+        self._internal.bar_width_factor = bar_width_factor
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        self.__internal.bar_max_width = bar_max_width
+        self._internal.bar_max_width = bar_max_width
     
         return self
     
 
 class FillConfig(cogbuilder.Builder[common.FillConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.FillConfig
+    _internal: common.FillConfig
 
     def __init__(self):
-        self.__internal = common.FillConfig()
+        self._internal = common.FillConfig()
 
     def build(self) -> common.FillConfig:
-        return self.__internal    
+        return self._internal    
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        self.__internal.fill_color = fill_color
+        self._internal.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        self.__internal.fill_opacity = fill_opacity
+        self._internal.fill_opacity = fill_opacity
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        self.__internal.fill_below_to = fill_below_to
+        self._internal.fill_below_to = fill_below_to
     
         return self
     
 
 class PointsConfig(cogbuilder.Builder[common.PointsConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.PointsConfig
+    _internal: common.PointsConfig
 
     def __init__(self):
-        self.__internal = common.PointsConfig()
+        self._internal = common.PointsConfig()
 
     def build(self) -> common.PointsConfig:
-        return self.__internal    
+        return self._internal    
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        self.__internal.show_points = show_points
+        self._internal.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        self.__internal.point_size = point_size
+        self._internal.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        self.__internal.point_color = point_color
+        self._internal.point_color = point_color
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        self.__internal.point_symbol = point_symbol
+        self._internal.point_symbol = point_symbol
     
         return self
     
 
 class ScaleDistributionConfig(cogbuilder.Builder[common.ScaleDistributionConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.ScaleDistributionConfig
+    _internal: common.ScaleDistributionConfig
 
     def __init__(self):
-        self.__internal = common.ScaleDistributionConfig()
+        self._internal = common.ScaleDistributionConfig()
 
     def build(self) -> common.ScaleDistributionConfig:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: common.ScaleDistribution) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def log(self, log: float) -> typing.Self:        
-        self.__internal.log = log
+        self._internal.log = log
     
         return self
     
     def linear_threshold(self, linear_threshold: float) -> typing.Self:        
-        self.__internal.linear_threshold = linear_threshold
+        self._internal.linear_threshold = linear_threshold
     
         return self
     
 
 class AxisConfig(cogbuilder.Builder[common.AxisConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.AxisConfig
+    _internal: common.AxisConfig
 
     def __init__(self):
-        self.__internal = common.AxisConfig()
+        self._internal = common.AxisConfig()
 
     def build(self) -> common.AxisConfig:
-        return self.__internal    
+        return self._internal    
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        self.__internal.axis_placement = axis_placement
+        self._internal.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        self.__internal.axis_color_mode = axis_color_mode
+        self._internal.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        self.__internal.axis_label = axis_label
+        self._internal.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        self.__internal.axis_width = axis_width
+        self._internal.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        self.__internal.axis_soft_min = axis_soft_min
+        self._internal.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        self.__internal.axis_soft_max = axis_soft_max
+        self._internal.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        self.__internal.axis_grid_show = axis_grid_show
+        self._internal.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.scale_distribution = scale_distribution_resource
+        self._internal.scale_distribution = scale_distribution_resource
     
         return self
     
     def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        self.__internal.axis_centered_zero = axis_centered_zero
-    
-        return self
-    
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        self.__internal.axis_border_show = axis_border_show
+        self._internal.axis_centered_zero = axis_centered_zero
     
         return self
     
 
 class HideSeriesConfig(cogbuilder.Builder[common.HideSeriesConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.HideSeriesConfig
+    _internal: common.HideSeriesConfig
 
     def __init__(self):
-        self.__internal = common.HideSeriesConfig()
+        self._internal = common.HideSeriesConfig()
 
     def build(self) -> common.HideSeriesConfig:
-        return self.__internal    
+        return self._internal    
     
     def tooltip(self, tooltip: bool) -> typing.Self:        
-        self.__internal.tooltip = tooltip
+        self._internal.tooltip = tooltip
     
         return self
     
     def legend(self, legend: bool) -> typing.Self:        
-        self.__internal.legend = legend
+        self._internal.legend = legend
     
         return self
     
     def viz(self, viz: bool) -> typing.Self:        
-        self.__internal.viz = viz
+        self._internal.viz = viz
     
         return self
     
 
 class StackingConfig(cogbuilder.Builder[common.StackingConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.StackingConfig
+    _internal: common.StackingConfig
 
     def __init__(self):
-        self.__internal = common.StackingConfig()
+        self._internal = common.StackingConfig()
 
     def build(self) -> common.StackingConfig:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.StackingMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def group(self, group: str) -> typing.Self:        
-        self.__internal.group = group
+        self._internal.group = group
     
         return self
     
 
 class StackableFieldConfig(cogbuilder.Builder[common.StackableFieldConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.StackableFieldConfig
+    _internal: common.StackableFieldConfig
 
     def __init__(self):
-        self.__internal = common.StackableFieldConfig()
+        self._internal = common.StackableFieldConfig()
 
     def build(self) -> common.StackableFieldConfig:
-        return self.__internal    
+        return self._internal    
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
         stacking_resource = stacking.build()
-        self.__internal.stacking = stacking_resource
+        self._internal.stacking = stacking_resource
     
         return self
     
 
 class HideableFieldConfig(cogbuilder.Builder[common.HideableFieldConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.HideableFieldConfig
+    _internal: common.HideableFieldConfig
 
     def __init__(self):
-        self.__internal = common.HideableFieldConfig()
+        self._internal = common.HideableFieldConfig()
 
     def build(self) -> common.HideableFieldConfig:
-        return self.__internal    
+        return self._internal    
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
         hide_from_resource = hide_from.build()
-        self.__internal.hide_from = hide_from_resource
+        self._internal.hide_from = hide_from_resource
     
         return self
     
 
 class GraphThresholdsStyleConfig(cogbuilder.Builder[common.GraphThresholdsStyleConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.GraphThresholdsStyleConfig
+    _internal: common.GraphThresholdsStyleConfig
 
     def __init__(self):
-        self.__internal = common.GraphThresholdsStyleConfig()
+        self._internal = common.GraphThresholdsStyleConfig()
 
     def build(self) -> common.GraphThresholdsStyleConfig:
-        return self.__internal    
+        return self._internal    
     
-    def mode(self, mode: common.GraphThresholdsStyleMode) -> typing.Self:        
-        self.__internal.mode = mode
+    def mode(self, mode: common.GraphTresholdsStyleMode) -> typing.Self:        
+        self._internal.mode = mode
     
         return self
     
 
 class SingleStatBaseOptions(cogbuilder.Builder[common.SingleStatBaseOptions]):    
     """
     TODO docs
     """
     
-    __internal: common.SingleStatBaseOptions
+    _internal: common.SingleStatBaseOptions
 
     def __init__(self):
-        self.__internal = common.SingleStatBaseOptions()
+        self._internal = common.SingleStatBaseOptions()
 
     def build(self) -> common.SingleStatBaseOptions:
-        return self.__internal    
+        return self._internal    
     
     def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
         reduce_options_resource = reduce_options.build()
-        self.__internal.reduce_options = reduce_options_resource
+        self._internal.reduce_options = reduce_options_resource
     
         return self
     
     def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
         text_resource = text.build()
-        self.__internal.text = text_resource
+        self._internal.text = text_resource
     
         return self
     
     def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
-        self.__internal.orientation = orientation
+        self._internal.orientation = orientation
     
         return self
     
 
 class ReduceDataOptions(cogbuilder.Builder[common.ReduceDataOptions]):    
     """
     TODO docs
     """
     
-    __internal: common.ReduceDataOptions
+    _internal: common.ReduceDataOptions
 
     def __init__(self):
-        self.__internal = common.ReduceDataOptions()
+        self._internal = common.ReduceDataOptions()
 
     def build(self) -> common.ReduceDataOptions:
-        return self.__internal    
+        return self._internal    
     
     def values(self, values: bool) -> typing.Self:    
         """
         If true show each row value
         """
             
-        self.__internal.values = values
+        self._internal.values = values
     
         return self
     
     def limit(self, limit: float) -> typing.Self:    
         """
         if showing all values limit
         """
             
-        self.__internal.limit = limit
+        self._internal.limit = limit
     
         return self
     
     def calcs(self, calcs: list[str]) -> typing.Self:    
         """
         When !values, pick one value for the whole field
         """
             
-        self.__internal.calcs = calcs
+        self._internal.calcs = calcs
     
         return self
     
     def fields(self, fields: str) -> typing.Self:    
         """
         Which fields to show.  By default this is only numeric fields
         """
             
-        self.__internal.fields = fields
+        self._internal.fields = fields
     
         return self
     
 
 class OptionsWithTooltip(cogbuilder.Builder[common.OptionsWithTooltip]):    
     """
     TODO docs
     """
     
-    __internal: common.OptionsWithTooltip
+    _internal: common.OptionsWithTooltip
 
     def __init__(self):
-        self.__internal = common.OptionsWithTooltip()
+        self._internal = common.OptionsWithTooltip()
 
     def build(self) -> common.OptionsWithTooltip:
-        return self.__internal    
+        return self._internal    
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
         tooltip_resource = tooltip.build()
-        self.__internal.tooltip = tooltip_resource
+        self._internal.tooltip = tooltip_resource
     
         return self
     
 
 class OptionsWithLegend(cogbuilder.Builder[common.OptionsWithLegend]):    
     """
     TODO docs
     """
     
-    __internal: common.OptionsWithLegend
+    _internal: common.OptionsWithLegend
 
     def __init__(self):
-        self.__internal = common.OptionsWithLegend()
+        self._internal = common.OptionsWithLegend()
 
     def build(self) -> common.OptionsWithLegend:
-        return self.__internal    
+        return self._internal    
     
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
         legend_resource = legend.build()
-        self.__internal.legend = legend_resource
+        self._internal.legend = legend_resource
     
         return self
     
 
 class OptionsWithTimezones(cogbuilder.Builder[common.OptionsWithTimezones]):    
     """
     TODO docs
     """
     
-    __internal: common.OptionsWithTimezones
+    _internal: common.OptionsWithTimezones
 
     def __init__(self):
-        self.__internal = common.OptionsWithTimezones()
+        self._internal = common.OptionsWithTimezones()
 
     def build(self) -> common.OptionsWithTimezones:
-        return self.__internal    
+        return self._internal    
     
     def timezone(self, timezone: list[common.TimeZone]) -> typing.Self:        
-        self.__internal.timezone = timezone
+        self._internal.timezone = timezone
     
         return self
     
 
 class OptionsWithTextFormatting(cogbuilder.Builder[common.OptionsWithTextFormatting]):    
     """
     TODO docs
     """
     
-    __internal: common.OptionsWithTextFormatting
+    _internal: common.OptionsWithTextFormatting
 
     def __init__(self):
-        self.__internal = common.OptionsWithTextFormatting()
+        self._internal = common.OptionsWithTextFormatting()
 
     def build(self) -> common.OptionsWithTextFormatting:
-        return self.__internal    
+        return self._internal    
     
     def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
         text_resource = text.build()
-        self.__internal.text = text_resource
+        self._internal.text = text_resource
     
         return self
     
 
 class VizTextDisplayOptions(cogbuilder.Builder[common.VizTextDisplayOptions]):    
     """
     TODO docs
     """
     
-    __internal: common.VizTextDisplayOptions
+    _internal: common.VizTextDisplayOptions
 
     def __init__(self):
-        self.__internal = common.VizTextDisplayOptions()
+        self._internal = common.VizTextDisplayOptions()
 
     def build(self) -> common.VizTextDisplayOptions:
-        return self.__internal    
+        return self._internal    
     
     def title_size(self, title_size: float) -> typing.Self:    
         """
         Explicit title text size
         """
             
-        self.__internal.title_size = title_size
+        self._internal.title_size = title_size
     
         return self
     
     def value_size(self, value_size: float) -> typing.Self:    
         """
         Explicit value text size
         """
             
-        self.__internal.value_size = value_size
+        self._internal.value_size = value_size
     
         return self
     
 
 class GraphFieldConfig(cogbuilder.Builder[common.GraphFieldConfig]):    
     """
     TODO docs
     """
     
-    __internal: common.GraphFieldConfig
+    _internal: common.GraphFieldConfig
 
     def __init__(self):
-        self.__internal = common.GraphFieldConfig()
+        self._internal = common.GraphFieldConfig()
 
     def build(self) -> common.GraphFieldConfig:
-        return self.__internal    
+        return self._internal    
     
     def draw_style(self, draw_style: common.GraphDrawStyle) -> typing.Self:        
-        self.__internal.draw_style = draw_style
+        self._internal.draw_style = draw_style
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:        
-        self.__internal.gradient_mode = gradient_mode
+        self._internal.gradient_mode = gradient_mode
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:        
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.thresholds_style = thresholds_style_resource
+        self._internal.thresholds_style = thresholds_style_resource
     
         return self
     
     def line_color(self, line_color: str) -> typing.Self:        
-        self.__internal.line_color = line_color
+        self._internal.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        self.__internal.line_width = line_width
+        self._internal.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        self.__internal.line_interpolation = line_interpolation
+        self._internal.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
         line_style_resource = line_style.build()
-        self.__internal.line_style = line_style_resource
+        self._internal.line_style = line_style_resource
     
         return self
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        self.__internal.fill_color = fill_color
+        self._internal.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        self.__internal.fill_opacity = fill_opacity
+        self._internal.fill_opacity = fill_opacity
     
         return self
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        self.__internal.show_points = show_points
+        self._internal.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        self.__internal.point_size = point_size
+        self._internal.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        self.__internal.point_color = point_color
+        self._internal.point_color = point_color
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        self.__internal.axis_placement = axis_placement
+        self._internal.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        self.__internal.axis_color_mode = axis_color_mode
+        self._internal.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        self.__internal.axis_label = axis_label
+        self._internal.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        self.__internal.axis_width = axis_width
+        self._internal.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        self.__internal.axis_soft_min = axis_soft_min
+        self._internal.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        self.__internal.axis_soft_max = axis_soft_max
+        self._internal.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        self.__internal.axis_grid_show = axis_grid_show
+        self._internal.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        self.__internal.axis_centered_zero = axis_centered_zero
+        self._internal.scale_distribution = scale_distribution_resource
     
         return self
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        self.__internal.bar_alignment = bar_alignment
+        self._internal.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        self.__internal.bar_width_factor = bar_width_factor
+        self._internal.bar_width_factor = bar_width_factor
     
         return self
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
         stacking_resource = stacking.build()
-        self.__internal.stacking = stacking_resource
+        self._internal.stacking = stacking_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
         hide_from_resource = hide_from.build()
-        self.__internal.hide_from = hide_from_resource
+        self._internal.hide_from = hide_from_resource
     
         return self
     
     def transform(self, transform: common.GraphTransform) -> typing.Self:        
-        self.__internal.transform = transform
+        self._internal.transform = transform
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        self.__internal.span_nulls = span_nulls
+        self._internal.span_nulls = span_nulls
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        self.__internal.fill_below_to = fill_below_to
+        self._internal.fill_below_to = fill_below_to
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        self.__internal.point_symbol = point_symbol
+        self._internal.point_symbol = point_symbol
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        self.__internal.axis_border_show = axis_border_show
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        self._internal.axis_centered_zero = axis_centered_zero
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        self.__internal.bar_max_width = bar_max_width
+        self._internal.bar_max_width = bar_max_width
     
         return self
     
 
 class VizLegendOptions(cogbuilder.Builder[common.VizLegendOptions]):    
     """
     TODO docs
     """
     
-    __internal: common.VizLegendOptions
+    _internal: common.VizLegendOptions
 
     def __init__(self):
-        self.__internal = common.VizLegendOptions()
+        self._internal = common.VizLegendOptions()
 
     def build(self) -> common.VizLegendOptions:
-        return self.__internal    
+        return self._internal    
     
     def display_mode(self, display_mode: common.LegendDisplayMode) -> typing.Self:        
-        self.__internal.display_mode = display_mode
+        self._internal.display_mode = display_mode
     
         return self
     
     def placement(self, placement: common.LegendPlacement) -> typing.Self:        
-        self.__internal.placement = placement
+        self._internal.placement = placement
     
         return self
     
     def show_legend(self, show_legend: bool) -> typing.Self:        
-        self.__internal.show_legend = show_legend
+        self._internal.show_legend = show_legend
     
         return self
     
     def as_table(self, as_table: bool) -> typing.Self:        
-        self.__internal.as_table = as_table
+        self._internal.as_table = as_table
     
         return self
     
     def is_visible(self, is_visible: bool) -> typing.Self:        
-        self.__internal.is_visible = is_visible
+        self._internal.is_visible = is_visible
     
         return self
     
     def sort_by(self, sort_by: str) -> typing.Self:        
-        self.__internal.sort_by = sort_by
+        self._internal.sort_by = sort_by
     
         return self
     
     def sort_desc(self, sort_desc: bool) -> typing.Self:        
-        self.__internal.sort_desc = sort_desc
+        self._internal.sort_desc = sort_desc
     
         return self
     
     def width(self, width: float) -> typing.Self:        
-        self.__internal.width = width
+        self._internal.width = width
     
         return self
     
     def calcs(self, calcs: list[str]) -> typing.Self:        
-        self.__internal.calcs = calcs
+        self._internal.calcs = calcs
     
         return self
     
 
 class VizTooltipOptions(cogbuilder.Builder[common.VizTooltipOptions]):    
     """
     TODO docs
     """
     
-    __internal: common.VizTooltipOptions
+    _internal: common.VizTooltipOptions
 
     def __init__(self):
-        self.__internal = common.VizTooltipOptions()
+        self._internal = common.VizTooltipOptions()
 
     def build(self) -> common.VizTooltipOptions:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.TooltipDisplayMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def sort(self, sort: common.SortOrder) -> typing.Self:        
-        self.__internal.sort = sort
-    
-        return self
-    
-    def max_width(self, max_width: float) -> typing.Self:        
-        self.__internal.max_width = max_width
-    
-        return self
-    
-    def max_height(self, max_height: float) -> typing.Self:        
-        self.__internal.max_height = max_height
+        self._internal.sort = sort
     
         return self
     
 
 class TableSortByFieldState(cogbuilder.Builder[common.TableSortByFieldState]):    
     """
     Sort by field state
     """
     
-    __internal: common.TableSortByFieldState
+    _internal: common.TableSortByFieldState
 
     def __init__(self):
-        self.__internal = common.TableSortByFieldState()
+        self._internal = common.TableSortByFieldState()
 
     def build(self) -> common.TableSortByFieldState:
-        return self.__internal    
+        return self._internal    
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         Sets the display name of the field to sort by
         """
             
-        self.__internal.display_name = display_name
+        self._internal.display_name = display_name
     
         return self
     
     def desc(self, desc: bool) -> typing.Self:    
         """
         Flag used to indicate descending sort order
         """
             
-        self.__internal.desc = desc
+        self._internal.desc = desc
     
         return self
     
 
 class TableFooterOptions(cogbuilder.Builder[common.TableFooterOptions]):    
     """
     Footer options
     """
     
-    __internal: common.TableFooterOptions
+    _internal: common.TableFooterOptions
 
     def __init__(self):
-        self.__internal = common.TableFooterOptions()
+        self._internal = common.TableFooterOptions()
 
     def build(self) -> common.TableFooterOptions:
-        return self.__internal    
+        return self._internal    
     
     def show(self, show: bool) -> typing.Self:        
-        self.__internal.show = show
+        self._internal.show = show
     
         return self
     
     def reducer(self, reducer: list[str]) -> typing.Self:    
         """
         actually 1 value
         """
             
-        self.__internal.reducer = reducer
+        self._internal.reducer = reducer
     
         return self
     
     def fields(self, fields: list[str]) -> typing.Self:        
-        self.__internal.fields = fields
+        self._internal.fields = fields
     
         return self
     
     def enable_pagination(self, enable_pagination: bool) -> typing.Self:        
-        self.__internal.enable_pagination = enable_pagination
+        self._internal.enable_pagination = enable_pagination
     
         return self
     
     def count_rows(self, count_rows: bool) -> typing.Self:        
-        self.__internal.count_rows = count_rows
+        self._internal.count_rows = count_rows
     
         return self
     
 
 class TableBarGaugeCellOptions(cogbuilder.Builder[common.TableBarGaugeCellOptions]):    
     """
     Gauge cell options
     """
     
-    __internal: common.TableBarGaugeCellOptions
+    _internal: common.TableBarGaugeCellOptions
 
     def __init__(self):
-        self.__internal = common.TableBarGaugeCellOptions()        
-        self.__internal.type_val = "gauge"
+        self._internal = common.TableBarGaugeCellOptions()        
+        self._internal.type_val = "gauge"
 
     def build(self) -> common.TableBarGaugeCellOptions:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.BarGaugeDisplayMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def value_display_mode(self, value_display_mode: common.BarGaugeValueMode) -> typing.Self:        
-        self.__internal.value_display_mode = value_display_mode
+        self._internal.value_display_mode = value_display_mode
     
         return self
     
 
 class TableSparklineCellOptions(cogbuilder.Builder[common.TableSparklineCellOptions]):    
     """
     Sparkline cell options
     """
     
-    __internal: common.TableSparklineCellOptions
+    _internal: common.TableSparklineCellOptions
 
     def __init__(self):
-        self.__internal = common.TableSparklineCellOptions()        
-        self.__internal.type_val = "sparkline"
+        self._internal = common.TableSparklineCellOptions()        
+        self._internal.type_val = "sparkline"
 
     def build(self) -> common.TableSparklineCellOptions:
-        return self.__internal    
+        return self._internal    
     
     def draw_style(self, draw_style: common.GraphDrawStyle) -> typing.Self:        
-        self.__internal.draw_style = draw_style
+        self._internal.draw_style = draw_style
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:        
-        self.__internal.gradient_mode = gradient_mode
+        self._internal.gradient_mode = gradient_mode
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:        
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.thresholds_style = thresholds_style_resource
+        self._internal.thresholds_style = thresholds_style_resource
     
         return self
     
     def line_color(self, line_color: str) -> typing.Self:        
-        self.__internal.line_color = line_color
+        self._internal.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        self.__internal.line_width = line_width
+        self._internal.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        self.__internal.line_interpolation = line_interpolation
+        self._internal.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
         line_style_resource = line_style.build()
-        self.__internal.line_style = line_style_resource
+        self._internal.line_style = line_style_resource
     
         return self
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        self.__internal.fill_color = fill_color
+        self._internal.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        self.__internal.fill_opacity = fill_opacity
+        self._internal.fill_opacity = fill_opacity
     
         return self
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        self.__internal.show_points = show_points
+        self._internal.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        self.__internal.point_size = point_size
+        self._internal.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        self.__internal.point_color = point_color
+        self._internal.point_color = point_color
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        self.__internal.axis_placement = axis_placement
+        self._internal.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        self.__internal.axis_color_mode = axis_color_mode
+        self._internal.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        self.__internal.axis_label = axis_label
+        self._internal.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        self.__internal.axis_width = axis_width
+        self._internal.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        self.__internal.axis_soft_min = axis_soft_min
+        self._internal.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        self.__internal.axis_soft_max = axis_soft_max
+        self._internal.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        self.__internal.axis_grid_show = axis_grid_show
+        self._internal.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        self.__internal.axis_centered_zero = axis_centered_zero
+        self._internal.scale_distribution = scale_distribution_resource
     
         return self
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        self.__internal.bar_alignment = bar_alignment
+        self._internal.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        self.__internal.bar_width_factor = bar_width_factor
+        self._internal.bar_width_factor = bar_width_factor
     
         return self
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
         stacking_resource = stacking.build()
-        self.__internal.stacking = stacking_resource
+        self._internal.stacking = stacking_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
         hide_from_resource = hide_from.build()
-        self.__internal.hide_from = hide_from_resource
-    
-        return self
-    
-    def hide_value(self, hide_value: bool) -> typing.Self:        
-        self.__internal.hide_value = hide_value
+        self._internal.hide_from = hide_from_resource
     
         return self
     
     def transform(self, transform: common.GraphTransform) -> typing.Self:        
-        self.__internal.transform = transform
+        self._internal.transform = transform
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        self.__internal.span_nulls = span_nulls
+        self._internal.span_nulls = span_nulls
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        self.__internal.fill_below_to = fill_below_to
+        self._internal.fill_below_to = fill_below_to
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        self.__internal.point_symbol = point_symbol
+        self._internal.point_symbol = point_symbol
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        self.__internal.axis_border_show = axis_border_show
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        self._internal.axis_centered_zero = axis_centered_zero
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        self.__internal.bar_max_width = bar_max_width
+        self._internal.bar_max_width = bar_max_width
     
         return self
     
 
 class TableColoredBackgroundCellOptions(cogbuilder.Builder[common.TableColoredBackgroundCellOptions]):    
     """
     Colored background cell options
     """
     
-    __internal: common.TableColoredBackgroundCellOptions
+    _internal: common.TableColoredBackgroundCellOptions
 
     def __init__(self):
-        self.__internal = common.TableColoredBackgroundCellOptions()        
-        self.__internal.type_val = "color-background"
+        self._internal = common.TableColoredBackgroundCellOptions()        
+        self._internal.type_val = "color-background"
 
     def build(self) -> common.TableColoredBackgroundCellOptions:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.TableCellBackgroundDisplayMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
 
 class DataSourceRef(cogbuilder.Builder[common.DataSourceRef]):    
-    __internal: common.DataSourceRef
+    _internal: common.DataSourceRef
 
     def __init__(self):
-        self.__internal = common.DataSourceRef()
+        self._internal = common.DataSourceRef()
 
     def build(self) -> common.DataSourceRef:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         The plugin type-id
         """
             
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def uid(self, uid: str) -> typing.Self:    
         """
         Specific datasource instance
         """
             
-        self.__internal.uid = uid
+        self._internal.uid = uid
     
         return self
     
 
 class ResourceDimensionConfig(cogbuilder.Builder[common.ResourceDimensionConfig]):    
     """
     Links to a resource (image/svg path)
     """
     
-    __internal: common.ResourceDimensionConfig
+    _internal: common.ResourceDimensionConfig
 
     def __init__(self):
-        self.__internal = common.ResourceDimensionConfig()
+        self._internal = common.ResourceDimensionConfig()
 
     def build(self) -> common.ResourceDimensionConfig:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.ResourceDimensionMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def field(self, field: str) -> typing.Self:    
         """
         fixed: T -- will be added by each element
         """
             
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def fixed(self, fixed: str) -> typing.Self:        
-        self.__internal.fixed = fixed
+        self._internal.fixed = fixed
     
         return self
     
 
 class FrameGeometrySource(cogbuilder.Builder[common.FrameGeometrySource]):    
-    __internal: common.FrameGeometrySource
+    _internal: common.FrameGeometrySource
 
     def __init__(self):
-        self.__internal = common.FrameGeometrySource()
+        self._internal = common.FrameGeometrySource()
 
     def build(self) -> common.FrameGeometrySource:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: common.FrameGeometrySourceMode) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def geohash(self, geohash: str) -> typing.Self:    
         """
         Field mappings
         """
             
-        self.__internal.geohash = geohash
+        self._internal.geohash = geohash
     
         return self
     
     def latitude(self, latitude: str) -> typing.Self:        
-        self.__internal.latitude = latitude
+        self._internal.latitude = latitude
     
         return self
     
     def longitude(self, longitude: str) -> typing.Self:        
-        self.__internal.longitude = longitude
+        self._internal.longitude = longitude
     
         return self
     
     def wkt(self, wkt: str) -> typing.Self:        
-        self.__internal.wkt = wkt
+        self._internal.wkt = wkt
     
         return self
     
     def lookup(self, lookup: str) -> typing.Self:        
-        self.__internal.lookup = lookup
+        self._internal.lookup = lookup
     
         return self
     
     def gazetteer(self, gazetteer: str) -> typing.Self:    
         """
         Path to Gazetteer
         """
             
-        self.__internal.gazetteer = gazetteer
+        self._internal.gazetteer = gazetteer
     
         return self
     
 
 class HeatmapCalculationOptions(cogbuilder.Builder[common.HeatmapCalculationOptions]):    
-    __internal: common.HeatmapCalculationOptions
+    _internal: common.HeatmapCalculationOptions
 
     def __init__(self):
-        self.__internal = common.HeatmapCalculationOptions()
+        self._internal = common.HeatmapCalculationOptions()
 
     def build(self) -> common.HeatmapCalculationOptions:
-        return self.__internal    
+        return self._internal    
     
     def x_buckets(self, x_buckets: cogbuilder.Builder[common.HeatmapCalculationBucketConfig]) -> typing.Self:    
         """
         The number of buckets to use for the xAxis in the heatmap
         """
             
         x_buckets_resource = x_buckets.build()
-        self.__internal.x_buckets = x_buckets_resource
+        self._internal.x_buckets = x_buckets_resource
     
         return self
     
     def y_buckets(self, y_buckets: cogbuilder.Builder[common.HeatmapCalculationBucketConfig]) -> typing.Self:    
         """
         The number of buckets to use for the yAxis in the heatmap
         """
             
         y_buckets_resource = y_buckets.build()
-        self.__internal.y_buckets = y_buckets_resource
+        self._internal.y_buckets = y_buckets_resource
     
         return self
     
 
 class TableFieldOptions(cogbuilder.Builder[common.TableFieldOptions]):    
     """
     Field options for each field within a table (e.g 10, "The String", 64.20, etc.)
     Generally defines alignment, filtering capabilties, display options, etc.
     """
     
-    __internal: common.TableFieldOptions
+    _internal: common.TableFieldOptions
 
     def __init__(self):
-        self.__internal = common.TableFieldOptions()
+        self._internal = common.TableFieldOptions()
 
     def build(self) -> common.TableFieldOptions:
-        return self.__internal    
+        return self._internal    
     
     def width(self, width: float) -> typing.Self:        
-        self.__internal.width = width
+        self._internal.width = width
     
         return self
     
     def min_width(self, min_width: float) -> typing.Self:        
-        self.__internal.min_width = min_width
+        self._internal.min_width = min_width
     
         return self
     
     def align(self, align: common.FieldTextAlignment) -> typing.Self:        
-        self.__internal.align = align
+        self._internal.align = align
     
         return self
     
     def display_mode(self, display_mode: common.TableCellDisplayMode) -> typing.Self:    
         """
         This field is deprecated in favor of using cellOptions
         """
             
-        self.__internal.display_mode = display_mode
+        self._internal.display_mode = display_mode
     
         return self
     
     def cell_options(self, cell_options: common.TableCellOptions) -> typing.Self:        
-        self.__internal.cell_options = cell_options
+        self._internal.cell_options = cell_options
     
         return self
     
     def hidden(self, hidden: bool) -> typing.Self:    
         """
         ?? default is missing or false ??
         """
             
-        self.__internal.hidden = hidden
+        self._internal.hidden = hidden
     
         return self
     
     def inspect(self, inspect: bool) -> typing.Self:        
-        self.__internal.inspect = inspect
+        self._internal.inspect = inspect
     
         return self
     
     def filterable(self, filterable: bool) -> typing.Self:        
-        self.__internal.filterable = filterable
+        self._internal.filterable = filterable
     
         return self
     
     def hide_header(self, hide_header: bool) -> typing.Self:    
         """
-        Hides any header for a column, useful for columns that show some static content or buttons.
+        Hides any header for a column, usefull for columns that show some static content or buttons.
         """
             
-        self.__internal.hide_header = hide_header
+        self._internal.hide_header = hide_header
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/dashboard.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/dashboard.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,248 +3,258 @@
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
 from ..cog import variants as cogvariants
 
 
 class Dashboard(cogbuilder.Builder[dashboard.Dashboard]):    
-    __internal: dashboard.Dashboard
+    _internal: dashboard.Dashboard
     __current_y: int = 0
     __current_x: int = 0
     __last_panel_height: int = 0
 
     def __init__(self, title: typing.Optional[str]):
-        self.__internal = dashboard.Dashboard()        
-        self.__internal.title = title
+        self._internal = dashboard.Dashboard()        
+        self._internal.title = title
 
     def build(self) -> dashboard.Dashboard:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique numeric identifier for the dashboard.
         `id` is internal to a specific Grafana instance. `uid` should be used to identify a dashboard across Grafana instances.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def uid(self, uid: str) -> typing.Self:    
         """
         Unique dashboard identifier that can be generated by anyone. string (8-40)
         """
             
-        self.__internal.uid = uid
+        self._internal.uid = uid
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Title of dashboard.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of dashboard.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def revision(self, revision: int) -> typing.Self:    
         """
         This property should only be used in dashboards defined by plugins.  It is a quick check
         to see if the version has changed since the last time.
         """
             
-        self.__internal.revision = revision
+        self._internal.revision = revision
     
         return self
     
     def gnet_id(self, gnet_id: str) -> typing.Self:    
         """
         ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal
         """
             
-        self.__internal.gnet_id = gnet_id
+        self._internal.gnet_id = gnet_id
     
         return self
     
     def tags(self, tags: list[str]) -> typing.Self:    
         """
         Tags associated with dashboard.
         """
             
-        self.__internal.tags = tags
+        self._internal.tags = tags
+    
+        return self
+    
+    def style(self, style: typing.Literal["light", "dark"]) -> typing.Self:    
+        """
+        Theme of dashboard.
+        Default value: dark.
+        """
+            
+        self._internal.style = style
     
         return self
     
     def timezone(self, timezone: str) -> typing.Self:    
         """
         Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc".
         """
             
-        self.__internal.timezone = timezone
+        self._internal.timezone = timezone
     
         return self
     
     def editable(self) -> typing.Self:    
         """
         Whether a dashboard is editable or not.
         """
             
-        self.__internal.editable = True
+        self._internal.editable = True
     
         return self
     
     def readonly(self) -> typing.Self:    
         """
         Whether a dashboard is editable or not.
         """
             
-        self.__internal.editable = False
+        self._internal.editable = False
     
         return self
     
     def tooltip(self, graph_tooltip: dashboard.DashboardCursorSync) -> typing.Self:    
         """
         Configuration of dashboard cursor sync behavior.
         Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip).
         """
             
-        self.__internal.graph_tooltip = graph_tooltip
+        self._internal.graph_tooltip = graph_tooltip
     
         return self
     
     def time(self, from_val: str, to: str) -> typing.Self:    
         """
         Time range for dashboard.
         Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.
         """
             
-        if self.__internal.time is None:
-            self.__internal.time = dashboard.DashboardDashboardTime()
+        if self._internal.time is None:
+            self._internal.time = dashboard.DashboardDashboardTime()
         
-        assert isinstance(self.__internal.time, dashboard.DashboardDashboardTime)
+        assert isinstance(self._internal.time, dashboard.DashboardDashboardTime)
         
-        self.__internal.time.from_val = from_val    
-        if self.__internal.time is None:
-            self.__internal.time = dashboard.DashboardDashboardTime()
+        self._internal.time.from_val = from_val    
+        if self._internal.time is None:
+            self._internal.time = dashboard.DashboardDashboardTime()
         
-        assert isinstance(self.__internal.time, dashboard.DashboardDashboardTime)
+        assert isinstance(self._internal.time, dashboard.DashboardDashboardTime)
         
-        self.__internal.time.to = to
+        self._internal.time.to = to
     
         return self
     
-    def timepicker(self, timepicker: cogbuilder.Builder[dashboard.TimePickerConfig]) -> typing.Self:    
+    def timepicker(self, timepicker: cogbuilder.Builder[dashboard.TimePicker]) -> typing.Self:    
         """
         Configuration of the time picker shown at the top of a dashboard.
         """
             
         timepicker_resource = timepicker.build()
-        self.__internal.timepicker = timepicker_resource
+        self._internal.timepicker = timepicker_resource
     
         return self
     
     def fiscal_year_start_month(self, fiscal_year_start_month: int) -> typing.Self:    
         """
         The month that the fiscal year starts on.  0 = January, 11 = December
         """
             
         if not fiscal_year_start_month < 12:
             raise ValueError("fiscal_year_start_month must be < 12")
-        self.__internal.fiscal_year_start_month = fiscal_year_start_month
+        self._internal.fiscal_year_start_month = fiscal_year_start_month
     
         return self
     
     def live_now(self, live_now: bool) -> typing.Self:    
         """
         When set to true, the dashboard will redraw panels at an interval matching the pixel width.
         This will keep data "moving left" regardless of the query refresh rate. This setting helps
         avoid dashboards presenting stale live data
         """
             
-        self.__internal.live_now = live_now
+        self._internal.live_now = live_now
     
         return self
     
     def week_start(self, week_start: str) -> typing.Self:    
         """
         Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".
         """
             
-        self.__internal.week_start = week_start
+        self._internal.week_start = week_start
     
         return self
     
-    def refresh(self, refresh: str) -> typing.Self:    
+    def refresh(self, refresh: typing.Union[str, typing.Literal[False]]) -> typing.Self:    
         """
         Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".
         """
             
-        self.__internal.refresh = refresh
+        self._internal.refresh = refresh
     
         return self
     
     def version(self, version: int) -> typing.Self:    
         """
         Version of the dashboard, incremented each time the dashboard is updated.
         """
             
-        self.__internal.version = version
+        self._internal.version = version
     
         return self
     
     def with_panel(self, panel: cogbuilder.Builder[dashboard.Panel]) -> typing.Self:        
-        if self.__internal.panels is None:
-            self.__internal.panels = []
+        if self._internal.panels is None:
+            self._internal.panels = []
         
         panel_resource = panel.build()
         
         # Position the panel on the grid
         if panel_resource.grid_pos is None:
             panel_resource.grid_pos = dashboard.GridPos()
         
         panel_resource.grid_pos.x = self.__current_x
         panel_resource.grid_pos.y = self.__current_y
-        self.__internal.panels.append(panel_resource)
+        self._internal.panels.append(panel_resource)
         
         # Prepare the coordinates for the next panel
         self.__current_x += panel_resource.grid_pos.w
         self.__last_panel_height = max(self.__last_panel_height, panel_resource.grid_pos.h)
         
         # Check for grid width overflow?
         if self.__current_x >= 24:
             self.__current_x = 0
             self.__current_y += self.__last_panel_height
             self.__last_panel_height = 0
     
         return self
     
     def with_row(self, row_panel: cogbuilder.Builder[dashboard.RowPanel]) -> typing.Self:        
-        if self.__internal.panels is None:
-            self.__internal.panels = []
+        if self._internal.panels is None:
+            self._internal.panels = []
         
         row_panel_resource = row_panel.build()
         
         # Position the row on the grid
         row_panel_resource.grid_pos = dashboard.GridPos(
             x=0,
             y=self.__current_y + self.__last_panel_height,
             h=1,
             w=24,
         )
-        self.__internal.panels.append(row_panel_resource)
+        self._internal.panels.append(row_panel_resource)
         
         # Reset the state for the next row
         self.__current_x = 0
         self.__current_y = row_panel_resource.grid_pos.y + 1
         self.__last_panel_height = 0
         
         # Position the row's panels on the grid
@@ -269,896 +279,817 @@
         return self
     
     def with_variable(self, list_val: cogbuilder.Builder[dashboard.VariableModel]) -> typing.Self:    
         """
         Configured template variables
         """
             
-        if self.__internal.templating is None:
-            self.__internal.templating = dashboard.DashboardDashboardTemplating()
+        if self._internal.templating is None:
+            self._internal.templating = dashboard.DashboardDashboardTemplating()
         
-        assert isinstance(self.__internal.templating, dashboard.DashboardDashboardTemplating)
+        assert isinstance(self._internal.templating, dashboard.DashboardDashboardTemplating)
         
-        if self.__internal.templating.list_val is None:
-            self.__internal.templating.list_val = []
+        if self._internal.templating.list_val is None:
+            self._internal.templating.list_val = []
         
         list_val_resource = list_val.build()
-        self.__internal.templating.list_val.append(list_val_resource)
+        self._internal.templating.list_val.append(list_val_resource)
     
         return self
     
     def annotation(self, list_val: cogbuilder.Builder[dashboard.AnnotationQuery]) -> typing.Self:    
         """
         Contains the list of annotations that are associated with the dashboard.
         Annotations are used to overlay event markers and overlay event tags on graphs.
         Grafana comes with a native annotation store and the ability to add annotation events directly from the graph panel or via the HTTP API.
         See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
         """
             
-        if self.__internal.annotations is None:
-            self.__internal.annotations = dashboard.AnnotationContainer()
+        if self._internal.annotations is None:
+            self._internal.annotations = dashboard.AnnotationContainer()
         
-        assert isinstance(self.__internal.annotations, dashboard.AnnotationContainer)
+        assert isinstance(self._internal.annotations, dashboard.AnnotationContainer)
         
-        if self.__internal.annotations.list_val is None:
-            self.__internal.annotations.list_val = []
+        if self._internal.annotations.list_val is None:
+            self._internal.annotations.list_val = []
         
         list_val_resource = list_val.build()
-        self.__internal.annotations.list_val.append(list_val_resource)
+        self._internal.annotations.list_val.append(list_val_resource)
     
         return self
     
     def link(self, links: cogbuilder.Builder[dashboard.DashboardLink]) -> typing.Self:    
         """
         Links with references to other dashboards or external websites.
         """
             
-        if self.__internal.links is None:
-            self.__internal.links = []
+        if self._internal.links is None:
+            self._internal.links = []
         
         links_resource = links.build()
-        self.__internal.links.append(links_resource)
+        self._internal.links.append(links_resource)
     
         return self
     
     def snapshot(self, snapshot: cogbuilder.Builder[dashboard.Snapshot]) -> typing.Self:    
         """
         Snapshot options. They are present only if the dashboard is a snapshot.
         """
             
         snapshot_resource = snapshot.build()
-        self.__internal.snapshot = snapshot_resource
+        self._internal.snapshot = snapshot_resource
     
         return self
     
 
 class AnnotationTarget(cogbuilder.Builder[dashboard.AnnotationTarget]):    
     """
     TODO: this should be a regular DataQuery that depends on the selected dashboard
     these match the properties of the "grafana" datasouce that is default in most dashboards
     """
     
-    __internal: dashboard.AnnotationTarget
+    _internal: dashboard.AnnotationTarget
 
     def __init__(self):
-        self.__internal = dashboard.AnnotationTarget()
+        self._internal = dashboard.AnnotationTarget()
 
     def build(self) -> dashboard.AnnotationTarget:
-        return self.__internal    
+        return self._internal    
     
     def limit(self, limit: int) -> typing.Self:    
         """
         Only required/valid for the grafana datasource...
         but code+tests is already depending on it so hard to change
         """
             
-        self.__internal.limit = limit
+        self._internal.limit = limit
     
         return self
     
     def match_any(self, match_any: bool) -> typing.Self:    
         """
         Only required/valid for the grafana datasource...
         but code+tests is already depending on it so hard to change
         """
             
-        self.__internal.match_any = match_any
+        self._internal.match_any = match_any
     
         return self
     
     def tags(self, tags: list[str]) -> typing.Self:    
         """
         Only required/valid for the grafana datasource...
         but code+tests is already depending on it so hard to change
         """
             
-        self.__internal.tags = tags
+        self._internal.tags = tags
     
         return self
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         Only required/valid for the grafana datasource...
         but code+tests is already depending on it so hard to change
         """
             
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
 
 class AnnotationPanelFilter(cogbuilder.Builder[dashboard.AnnotationPanelFilter]):    
-    __internal: dashboard.AnnotationPanelFilter
+    _internal: dashboard.AnnotationPanelFilter
 
     def __init__(self):
-        self.__internal = dashboard.AnnotationPanelFilter()
+        self._internal = dashboard.AnnotationPanelFilter()
 
     def build(self) -> dashboard.AnnotationPanelFilter:
-        return self.__internal    
+        return self._internal    
     
     def exclude(self, exclude: bool) -> typing.Self:    
         """
         Should the specified panels be included or excluded
         """
             
-        self.__internal.exclude = exclude
+        self._internal.exclude = exclude
     
         return self
     
     def ids(self, ids: list[int]) -> typing.Self:    
         """
         Panel IDs that should be included or excluded
         """
             
-        self.__internal.ids = ids
+        self._internal.ids = ids
     
         return self
     
 
 class AnnotationQuery(cogbuilder.Builder[dashboard.AnnotationQuery]):    
     """
     TODO docs
     FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
     """
     
-    __internal: dashboard.AnnotationQuery
+    _internal: dashboard.AnnotationQuery
 
     def __init__(self):
-        self.__internal = dashboard.AnnotationQuery()
+        self._internal = dashboard.AnnotationQuery()
 
     def build(self) -> dashboard.AnnotationQuery:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of annotation.
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         Datasource where the annotations data is
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def enable(self, enable: bool) -> typing.Self:    
         """
         When enabled the annotation query is issued with every dashboard refresh
         """
             
-        self.__internal.enable = enable
+        self._internal.enable = enable
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         Annotation queries can be toggled on or off at the top of the dashboard.
         When hide is true, the toggle is not shown in the dashboard.
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def icon_color(self, icon_color: str) -> typing.Self:    
         """
         Color to use for the annotation event markers
         """
             
-        self.__internal.icon_color = icon_color
+        self._internal.icon_color = icon_color
     
         return self
     
     def filter_val(self, filter_val: cogbuilder.Builder[dashboard.AnnotationPanelFilter]) -> typing.Self:    
         """
         Filters to apply when fetching annotations
         """
             
         filter_val_resource = filter_val.build()
-        self.__internal.filter_val = filter_val_resource
+        self._internal.filter_val = filter_val_resource
     
         return self
     
     def target(self, target: cogbuilder.Builder[dashboard.AnnotationTarget]) -> typing.Self:    
         """
         TODO.. this should just be a normal query target
         """
             
         target_resource = target.build()
-        self.__internal.target = target_resource
+        self._internal.target = target_resource
     
         return self
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         TODO -- this should not exist here, it is based on the --grafana-- datasource
         """
             
-        self.__internal.type_val = type_val
-    
-        return self
-    
-    def built_in(self, built_in: float) -> typing.Self:    
-        """
-        Set to 1 for the standard annotation query all dashboards have by default.
-        """
-            
-        self.__internal.built_in = built_in
+        self._internal.type_val = type_val
     
         return self
     
 
 class DashboardLink(cogbuilder.Builder[dashboard.DashboardLink]):    
     """
     Links with references to other dashboards or external resources
     """
     
-    __internal: dashboard.DashboardLink
+    _internal: dashboard.DashboardLink
 
     def __init__(self, title: str):
-        self.__internal = dashboard.DashboardLink()        
-        self.__internal.title = title
+        self._internal = dashboard.DashboardLink()        
+        self._internal.title = title
 
     def build(self) -> dashboard.DashboardLink:
-        return self.__internal    
+        return self._internal    
     
     def title(self, title: str) -> typing.Self:    
         """
         Title to display with the link
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def type_val(self, type_val: dashboard.DashboardLinkType) -> typing.Self:    
         """
         Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)
         """
             
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def icon(self, icon: str) -> typing.Self:    
         """
         Icon name to be displayed with the link
         """
             
-        self.__internal.icon = icon
+        self._internal.icon = icon
     
         return self
     
     def tooltip(self, tooltip: str) -> typing.Self:    
         """
         Tooltip to display when the user hovers their mouse over it
         """
             
-        self.__internal.tooltip = tooltip
+        self._internal.tooltip = tooltip
     
         return self
     
     def url(self, url: str) -> typing.Self:    
         """
         Link URL. Only required/valid if the type is link
         """
             
-        self.__internal.url = url
+        self._internal.url = url
     
         return self
     
     def tags(self, tags: list[str]) -> typing.Self:    
         """
         List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards
         """
             
-        self.__internal.tags = tags
+        self._internal.tags = tags
     
         return self
     
     def as_dropdown(self, as_dropdown: bool) -> typing.Self:    
         """
         If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards
         """
             
-        self.__internal.as_dropdown = as_dropdown
+        self._internal.as_dropdown = as_dropdown
     
         return self
     
     def target_blank(self, target_blank: bool) -> typing.Self:    
         """
         If true, the link will be opened in a new tab
         """
             
-        self.__internal.target_blank = target_blank
+        self._internal.target_blank = target_blank
     
         return self
     
     def include_vars(self, include_vars: bool) -> typing.Self:    
         """
         If true, includes current template variables values in the link as query params
         """
             
-        self.__internal.include_vars = include_vars
+        self._internal.include_vars = include_vars
     
         return self
     
     def keep_time(self, keep_time: bool) -> typing.Self:    
         """
         If true, includes current time range in the link as query params
         """
             
-        self.__internal.keep_time = keep_time
+        self._internal.keep_time = keep_time
     
         return self
     
 
 class FieldColor(cogbuilder.Builder[dashboard.FieldColor]):    
     """
     Map a field to a color.
     """
     
-    __internal: dashboard.FieldColor
+    _internal: dashboard.FieldColor
 
     def __init__(self):
-        self.__internal = dashboard.FieldColor()
+        self._internal = dashboard.FieldColor()
 
     def build(self) -> dashboard.FieldColor:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: dashboard.FieldColorModeId) -> typing.Self:    
         """
         The main color scheme mode.
         """
             
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def fixed_color(self, fixed_color: str) -> typing.Self:    
         """
         The fixed color value for fixed or shades color modes.
         """
             
-        self.__internal.fixed_color = fixed_color
+        self._internal.fixed_color = fixed_color
     
         return self
     
     def series_by(self, series_by: dashboard.FieldColorSeriesByMode) -> typing.Self:    
         """
         Some visualizations need to know how to assign a series color from by value color schemes.
         """
             
-        self.__internal.series_by = series_by
+        self._internal.series_by = series_by
     
         return self
     
 
 class ThresholdsConfig(cogbuilder.Builder[dashboard.ThresholdsConfig]):    
     """
     Thresholds configuration for the panel
     """
     
-    __internal: dashboard.ThresholdsConfig
+    _internal: dashboard.ThresholdsConfig
 
     def __init__(self):
-        self.__internal = dashboard.ThresholdsConfig()
+        self._internal = dashboard.ThresholdsConfig()
 
     def build(self) -> dashboard.ThresholdsConfig:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: dashboard.ThresholdsMode) -> typing.Self:    
         """
         Thresholds mode.
         """
             
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def steps(self, steps: list[dashboard.Threshold]) -> typing.Self:    
         """
         Must be sorted by 'value', first value is always -Infinity
         """
             
-        self.__internal.steps = steps
+        self._internal.steps = steps
     
         return self
     
 
 class ValueMap(cogbuilder.Builder[dashboard.ValueMap]):    
     """
     Maps text values to a color or different display text and color.
     For example, you can configure a value mapping so that all instances of the value 10 appear as Perfection! rather than the number.
     """
     
-    __internal: dashboard.ValueMap
+    _internal: dashboard.ValueMap
 
     def __init__(self):
-        self.__internal = dashboard.ValueMap()        
-        self.__internal.type_val = "value"
+        self._internal = dashboard.ValueMap()        
+        self._internal.type_val = "value"
 
     def build(self) -> dashboard.ValueMap:
-        return self.__internal    
+        return self._internal    
     
     def options(self, options: dict[str, dashboard.ValueMappingResult]) -> typing.Self:    
         """
         Map with <value_to_match>: ValueMappingResult. For example: { "10": { text: "Perfection!", color: "green" } }
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
 
 class RangeMap(cogbuilder.Builder[dashboard.RangeMap]):    
     """
     Maps numerical ranges to a display text and color.
     For example, if a value is within a certain range, you can configure a range value mapping to display Low or High rather than the number.
     """
     
-    __internal: dashboard.RangeMap
+    _internal: dashboard.RangeMap
 
     def __init__(self):
-        self.__internal = dashboard.RangeMap()        
-        self.__internal.type_val = "range"
+        self._internal = dashboard.RangeMap()        
+        self._internal.type_val = "range"
 
     def build(self) -> dashboard.RangeMap:
-        return self.__internal    
+        return self._internal    
     
     def options(self, options: cogbuilder.Builder[dashboard.DashboardRangeMapOptions]) -> typing.Self:    
         """
         Range to match against and the result to apply when the value is within the range
         """
             
         options_resource = options.build()
-        self.__internal.options = options_resource
+        self._internal.options = options_resource
     
         return self
     
 
 class RegexMap(cogbuilder.Builder[dashboard.RegexMap]):    
     """
     Maps regular expressions to replacement text and a color.
     For example, if a value is www.example.com, you can configure a regex value mapping so that Grafana displays www and truncates the domain.
     """
     
-    __internal: dashboard.RegexMap
+    _internal: dashboard.RegexMap
 
     def __init__(self):
-        self.__internal = dashboard.RegexMap()        
-        self.__internal.type_val = "regex"
+        self._internal = dashboard.RegexMap()        
+        self._internal.type_val = "regex"
 
     def build(self) -> dashboard.RegexMap:
-        return self.__internal    
+        return self._internal    
     
     def options(self, options: cogbuilder.Builder[dashboard.DashboardRegexMapOptions]) -> typing.Self:    
         """
         Regular expression to match against and the result to apply when the value matches the regex
         """
             
         options_resource = options.build()
-        self.__internal.options = options_resource
+        self._internal.options = options_resource
     
         return self
     
 
 class SpecialValueMap(cogbuilder.Builder[dashboard.SpecialValueMap]):    
     """
     Maps special values like Null, NaN (not a number), and boolean values like true and false to a display text and color.
     See SpecialValueMatch to see the list of special values.
     For example, you can configure a special value mapping so that null values appear as N/A.
     """
     
-    __internal: dashboard.SpecialValueMap
+    _internal: dashboard.SpecialValueMap
 
     def __init__(self):
-        self.__internal = dashboard.SpecialValueMap()        
-        self.__internal.type_val = "special"
+        self._internal = dashboard.SpecialValueMap()        
+        self._internal.type_val = "special"
 
     def build(self) -> dashboard.SpecialValueMap:
-        return self.__internal    
+        return self._internal    
     
     def options(self, options: cogbuilder.Builder[dashboard.DashboardSpecialValueMapOptions]) -> typing.Self:        
         options_resource = options.build()
-        self.__internal.options = options_resource
-    
-        return self
-    
-
-class TimePicker(cogbuilder.Builder[dashboard.TimePickerConfig]):    
-    """
-    Time picker configuration
-    It defines the default config for the time picker and the refresh picker for the specific dashboard.
-    """
-    
-    __internal: dashboard.TimePickerConfig
-
-    def __init__(self):
-        self.__internal = dashboard.TimePickerConfig()
-
-    def build(self) -> dashboard.TimePickerConfig:
-        return self.__internal    
-    
-    def hidden(self, hidden: bool) -> typing.Self:    
-        """
-        Whether timepicker is visible or not.
-        """
-            
-        self.__internal.hidden = hidden
-    
-        return self
-    
-    def refresh_intervals(self, refresh_intervals: list[str]) -> typing.Self:    
-        """
-        Interval options available in the refresh picker dropdown.
-        """
-            
-        self.__internal.refresh_intervals = refresh_intervals
-    
-        return self
-    
-    def time_options(self, time_options: list[str]) -> typing.Self:    
-        """
-        Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
-        """
-            
-        self.__internal.time_options = time_options
-    
-        return self
-    
-    def now_delay(self, now_delay: str) -> typing.Self:    
-        """
-        Override the now time by entering a time delay. Use this option to accommodate known delays in data aggregation to avoid null values.
-        """
-            
-        self.__internal.now_delay = now_delay
+        self._internal.options = options_resource
     
         return self
     
 
 class Snapshot(cogbuilder.Builder[dashboard.Snapshot]):    
     """
     A dashboard snapshot shares an interactive dashboard publicly.
     It is a read-only version of a dashboard, and is not editable.
     It is possible to create a snapshot of a snapshot.
     Grafana strips away all sensitive information from the dashboard.
     Sensitive information stripped: queries (metric, template,annotation) and panel links.
     """
     
-    __internal: dashboard.Snapshot
+    _internal: dashboard.Snapshot
 
     def __init__(self):
-        self.__internal = dashboard.Snapshot()
+        self._internal = dashboard.Snapshot()
 
     def build(self) -> dashboard.Snapshot:
-        return self.__internal    
+        return self._internal    
     
     def created(self, created: str) -> typing.Self:    
         """
         Time when the snapshot was created
         """
             
-        self.__internal.created = created
+        self._internal.created = created
     
         return self
     
     def expires(self, expires: str) -> typing.Self:    
         """
         Time when the snapshot expires, default is never to expire
         """
             
-        self.__internal.expires = expires
+        self._internal.expires = expires
     
         return self
     
     def external(self, external: bool) -> typing.Self:    
         """
         Is the snapshot saved in an external grafana instance
         """
             
-        self.__internal.external = external
+        self._internal.external = external
     
         return self
     
     def external_url(self, external_url: str) -> typing.Self:    
         """
         external url, if snapshot was shared in external grafana instance
         """
             
-        self.__internal.external_url = external_url
-    
-        return self
-    
-    def original_url(self, original_url: str) -> typing.Self:    
-        """
-        original url, url of the dashboard that was snapshotted
-        """
-            
-        self.__internal.original_url = original_url
+        self._internal.external_url = external_url
     
         return self
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the snapshot
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def key(self, key: str) -> typing.Self:    
         """
         Optional, defined the unique key of the snapshot, required if external is true
         """
             
-        self.__internal.key = key
+        self._internal.key = key
     
         return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Optional, name of the snapshot
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def org_id(self, org_id: int) -> typing.Self:    
         """
         org id of the snapshot
         """
             
-        self.__internal.org_id = org_id
+        self._internal.org_id = org_id
     
         return self
     
     def updated(self, updated: str) -> typing.Self:    
         """
         last time when the snapshot was updated
         """
             
-        self.__internal.updated = updated
+        self._internal.updated = updated
     
         return self
     
     def url(self, url: str) -> typing.Self:    
         """
         url of the snapshot, if snapshot was shared internally
         """
             
-        self.__internal.url = url
+        self._internal.url = url
     
         return self
     
     def user_id(self, user_id: int) -> typing.Self:    
         """
         user id of the snapshot creator
         """
             
-        self.__internal.user_id = user_id
+        self._internal.user_id = user_id
     
         return self
     
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()
+        self._internal = dashboard.Panel()
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         The panel plugin type id. This is used to find the plugin to display the panel.
         """
             
         if not len(type_val) >= 1:
             raise ValueError("len(type_val) must be >= 1")
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -1166,82 +1097,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -1251,990 +1155,1225 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
 
 class Row(cogbuilder.Builder[dashboard.RowPanel]):    
     """
     Row panel
     """
     
-    __internal: dashboard.RowPanel
+    _internal: dashboard.RowPanel
 
     def __init__(self, title: typing.Optional[str]):
-        self.__internal = dashboard.RowPanel()        
-        self.__internal.title = title        
-        self.__internal.type_val = "row"
+        self._internal = dashboard.RowPanel()        
+        self._internal.title = title        
+        self._internal.type_val = "row"
 
     def build(self) -> dashboard.RowPanel:
-        return self.__internal    
+        return self._internal    
     
     def collapsed(self, collapsed: bool) -> typing.Self:    
         """
         Whether this row should be collapsed or not.
         """
             
-        self.__internal.collapsed = collapsed
+        self._internal.collapsed = collapsed
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Row title
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         Name of default datasource for the row
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
-    def panels(self, panels: list[cogbuilder.Builder[dashboard.Panel]]) -> typing.Self:    
+    def with_panel(self, panels: cogbuilder.Builder[dashboard.Panel]) -> typing.Self:    
         """
         List of panels in the row
         """
             
-        panels_resources = [r1.build() for r1 in panels]
-        self.__internal.panels = panels_resources
+        if self._internal.panels is None:
+            self._internal.panels = []
+        
+        panels_resource = panels.build()
+        self._internal.panels.append(panels_resource)
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
+    
+        return self
+    
+
+class GraphPanel(cogbuilder.Builder[dashboard.GraphPanel]):    
+    """
+    Support for legacy graph panel.
+    @deprecated this a deprecated panel type
+    """
+    
+    _internal: dashboard.GraphPanel
+
+    def __init__(self):
+        self._internal = dashboard.GraphPanel()        
+        self._internal.type_val = "graph"
+
+    def build(self) -> dashboard.GraphPanel:
+        return self._internal    
+    
+    def legend(self, legend: cogbuilder.Builder[dashboard.DashboardGraphPanelLegend]) -> typing.Self:    
+        """
+        @deprecated this is part of deprecated graph panel
+        """
+            
+        legend_resource = legend.build()
+        self._internal.legend = legend_resource
+    
+        return self
+    
+
+class TimePicker(cogbuilder.Builder[dashboard.TimePicker]):    
+    _internal: dashboard.TimePicker
+
+    def __init__(self):
+        self._internal = dashboard.TimePicker()
+
+    def build(self) -> dashboard.TimePicker:
+        return self._internal    
+    
+    def hidden(self, hidden: bool) -> typing.Self:    
+        """
+        Whether timepicker is visible or not.
+        """
+            
+        self._internal.hidden = hidden
+    
+        return self
+    
+    def refresh_intervals(self, refresh_intervals: list[str]) -> typing.Self:    
+        """
+        Interval options available in the refresh picker dropdown.
+        """
+            
+        self._internal.refresh_intervals = refresh_intervals
+    
+        return self
+    
+    def collapse(self, collapse: bool) -> typing.Self:    
+        """
+        Whether timepicker is collapsed or not. Has no effect on provisioned dashboard.
+        """
+            
+        self._internal.collapse = collapse
+    
+        return self
+    
+    def enable(self, enable: bool) -> typing.Self:    
+        """
+        Whether timepicker is enabled or not. Has no effect on provisioned dashboard.
+        """
+            
+        self._internal.enable = enable
+    
+        return self
+    
+    def time_options(self, time_options: list[str]) -> typing.Self:    
+        """
+        Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
+        """
+            
+        self._internal.time_options = time_options
     
         return self
     
 
 class DashboardDashboardTemplating(cogbuilder.Builder[dashboard.DashboardDashboardTemplating]):    
-    __internal: dashboard.DashboardDashboardTemplating
+    _internal: dashboard.DashboardDashboardTemplating
 
     def __init__(self):
-        self.__internal = dashboard.DashboardDashboardTemplating()
+        self._internal = dashboard.DashboardDashboardTemplating()
 
     def build(self) -> dashboard.DashboardDashboardTemplating:
-        return self.__internal    
+        return self._internal    
     
     def list_val(self, list_val: list[cogbuilder.Builder[dashboard.VariableModel]]) -> typing.Self:    
         """
         List of configured template variables with their saved values along with some other metadata
         """
             
         list_val_resources = [r1.build() for r1 in list_val]
-        self.__internal.list_val = list_val_resources
+        self._internal.list_val = list_val_resources
     
         return self
     
 
 class DashboardRangeMapOptions(cogbuilder.Builder[dashboard.DashboardRangeMapOptions]):    
-    __internal: dashboard.DashboardRangeMapOptions
+    _internal: dashboard.DashboardRangeMapOptions
 
     def __init__(self):
-        self.__internal = dashboard.DashboardRangeMapOptions()
+        self._internal = dashboard.DashboardRangeMapOptions()
 
     def build(self) -> dashboard.DashboardRangeMapOptions:
-        return self.__internal    
+        return self._internal    
     
     def from_val(self, from_val: float) -> typing.Self:    
         """
         Min value of the range. It can be null which means -Infinity
         """
             
-        self.__internal.from_val = from_val
+        self._internal.from_val = from_val
     
         return self
     
     def to(self, to: float) -> typing.Self:    
         """
         Max value of the range. It can be null which means +Infinity
         """
             
-        self.__internal.to = to
+        self._internal.to = to
     
         return self
     
     def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
         """
         Config to apply when the value is within the range
         """
             
-        self.__internal.result = result
+        self._internal.result = result
     
         return self
     
 
 class DashboardRegexMapOptions(cogbuilder.Builder[dashboard.DashboardRegexMapOptions]):    
-    __internal: dashboard.DashboardRegexMapOptions
+    _internal: dashboard.DashboardRegexMapOptions
 
     def __init__(self):
-        self.__internal = dashboard.DashboardRegexMapOptions()
+        self._internal = dashboard.DashboardRegexMapOptions()
 
     def build(self) -> dashboard.DashboardRegexMapOptions:
-        return self.__internal    
+        return self._internal    
     
     def pattern(self, pattern: str) -> typing.Self:    
         """
         Regular expression to match against
         """
             
-        self.__internal.pattern = pattern
+        self._internal.pattern = pattern
     
         return self
     
     def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
         """
         Config to apply when the value matches the regex
         """
             
-        self.__internal.result = result
+        self._internal.result = result
     
         return self
     
 
 class DashboardSpecialValueMapOptions(cogbuilder.Builder[dashboard.DashboardSpecialValueMapOptions]):    
-    __internal: dashboard.DashboardSpecialValueMapOptions
+    _internal: dashboard.DashboardSpecialValueMapOptions
 
     def __init__(self):
-        self.__internal = dashboard.DashboardSpecialValueMapOptions()
+        self._internal = dashboard.DashboardSpecialValueMapOptions()
 
     def build(self) -> dashboard.DashboardSpecialValueMapOptions:
-        return self.__internal    
+        return self._internal    
     
     def match(self, match: dashboard.SpecialValueMatch) -> typing.Self:    
         """
         Special value to match against
         """
             
-        self.__internal.match = match
+        self._internal.match = match
     
         return self
     
     def result(self, result: dashboard.ValueMappingResult) -> typing.Self:    
         """
         Config to apply when the value matches the special value
         """
             
-        self.__internal.result = result
+        self._internal.result = result
     
         return self
     
 
 class DashboardFieldConfigSourceOverrides(cogbuilder.Builder[dashboard.DashboardFieldConfigSourceOverrides]):    
-    __internal: dashboard.DashboardFieldConfigSourceOverrides
+    _internal: dashboard.DashboardFieldConfigSourceOverrides
 
     def __init__(self):
-        self.__internal = dashboard.DashboardFieldConfigSourceOverrides()
+        self._internal = dashboard.DashboardFieldConfigSourceOverrides()
 
     def build(self) -> dashboard.DashboardFieldConfigSourceOverrides:
-        return self.__internal    
+        return self._internal    
     
     def matcher(self, matcher: dashboard.MatcherConfig) -> typing.Self:        
-        self.__internal.matcher = matcher
+        self._internal.matcher = matcher
     
         return self
     
     def properties(self, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:        
-        self.__internal.properties = properties
+        self._internal.properties = properties
+    
+        return self
+    
+
+class DashboardGraphPanelLegend(cogbuilder.Builder[dashboard.DashboardGraphPanelLegend]):    
+    _internal: dashboard.DashboardGraphPanelLegend
+
+    def __init__(self):
+        self._internal = dashboard.DashboardGraphPanelLegend()
+
+    def build(self) -> dashboard.DashboardGraphPanelLegend:
+        return self._internal    
+    
+    def show(self, show: bool) -> typing.Self:        
+        self._internal.show = show
+    
+        return self
+    
+    def sort(self, sort: str) -> typing.Self:        
+        self._internal.sort = sort
+    
+        return self
+    
+    def sort_desc(self, sort_desc: bool) -> typing.Self:        
+        self._internal.sort_desc = sort_desc
     
         return self
     
 
 class QueryVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.QUERY
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.QUERY
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def query(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         Data source used to fetch values for a variable. It can be defined but `null`.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
     def current(self, current: dashboard.VariableOption) -> typing.Self:    
         """
         Shows current selected variable text/value on the dashboard
         """
             
-        self.__internal.current = current
+        self._internal.current = current
     
         return self
     
     def multi(self, multi: bool) -> typing.Self:    
         """
         Whether multiple values can be selected or not from variable value list
         """
             
-        self.__internal.multi = multi
+        self._internal.multi = multi
     
         return self
     
     def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
         """
         Options that can be selected for a variable.
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
     def refresh(self, refresh: dashboard.VariableRefresh) -> typing.Self:    
         """
         Options to config when to refresh a variable
         """
             
-        self.__internal.refresh = refresh
+        self._internal.refresh = refresh
     
         return self
     
     def sort(self, sort: dashboard.VariableSort) -> typing.Self:    
         """
         Options sort order
         """
             
-        self.__internal.sort = sort
+        self._internal.sort = sort
     
         return self
     
     def include_all(self, include_all: bool) -> typing.Self:    
         """
         Whether all value option is available or not
         """
             
-        self.__internal.include_all = include_all
+        self._internal.include_all = include_all
     
         return self
     
     def all_value(self, all_value: str) -> typing.Self:    
         """
         Custom all value
         """
             
-        self.__internal.all_value = all_value
+        self._internal.all_value = all_value
     
         return self
     
     def regex(self, regex: str) -> typing.Self:    
         """
         Optional field, if you want to extract part of a series name or metric node segment.
         Named capture groups can be used to separate the display text and value.
         """
             
-        self.__internal.regex = regex
+        self._internal.regex = regex
     
         return self
     
 
 class AdHocVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.ADHOC
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.ADHOC
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         Data source used to fetch values for a variable. It can be defined but `null`.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
 
 class ConstantVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.CONSTANT
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.CONSTANT
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def value(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
 
 class DatasourceVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.DATASOURCE
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.DATASOURCE
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def type_val(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
     def current(self, current: dashboard.VariableOption) -> typing.Self:    
         """
         Shows current selected variable text/value on the dashboard
         """
             
-        self.__internal.current = current
+        self._internal.current = current
     
         return self
     
     def multi(self, multi: bool) -> typing.Self:    
         """
         Whether multiple values can be selected or not from variable value list
         """
             
-        self.__internal.multi = multi
+        self._internal.multi = multi
     
         return self
     
     def include_all(self, include_all: bool) -> typing.Self:    
         """
         Whether all value option is available or not
         """
             
-        self.__internal.include_all = include_all
+        self._internal.include_all = include_all
     
         return self
     
     def all_value(self, all_value: str) -> typing.Self:    
         """
         Custom all value
         """
             
-        self.__internal.all_value = all_value
+        self._internal.all_value = all_value
     
         return self
     
     def regex(self, regex: str) -> typing.Self:    
         """
         Optional field, if you want to extract part of a series name or metric node segment.
         Named capture groups can be used to separate the display text and value.
         """
             
-        self.__internal.regex = regex
+        self._internal.regex = regex
     
         return self
     
 
 class IntervalVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.INTERVAL
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.INTERVAL
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def values(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
     def current(self, current: dashboard.VariableOption) -> typing.Self:    
         """
         Shows current selected variable text/value on the dashboard
         """
             
-        self.__internal.current = current
+        self._internal.current = current
     
         return self
     
     def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
         """
         Options that can be selected for a variable.
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
 
 class TextBoxVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.TEXTBOX
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.TEXTBOX
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def default_value(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
     def current(self, current: dashboard.VariableOption) -> typing.Self:    
         """
         Shows current selected variable text/value on the dashboard
         """
             
-        self.__internal.current = current
+        self._internal.current = current
     
         return self
     
     def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
         """
         Options that can be selected for a variable.
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
 
 class CustomVariable(cogbuilder.Builder[dashboard.VariableModel]):    
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
     
-    __internal: dashboard.VariableModel
+    _internal: dashboard.VariableModel
 
     def __init__(self, name: str):
-        self.__internal = dashboard.VariableModel()        
-        self.__internal.name = name        
-        self.__internal.type_val = dashboard.VariableType.CUSTOM
+        self._internal = dashboard.VariableModel()        
+        self._internal.name = name        
+        self._internal.type_val = dashboard.VariableType.CUSTOM
 
     def build(self) -> dashboard.VariableModel:
-        return self.__internal    
+        return self._internal    
+    
+    def id_val(self, id_val: str) -> typing.Self:    
+        """
+        Unique numeric identifier for the variable.
+        """
+            
+        self._internal.id_val = id_val
+    
+        return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of variable
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def label(self, label: str) -> typing.Self:    
         """
         Optional display name
         """
             
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def hide(self, hide: dashboard.VariableHide) -> typing.Self:    
         """
         Visibility configuration for the variable
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Description of variable. It can be defined but `null`.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def values(self, query: typing.Union[str, object]) -> typing.Self:    
         """
         Query used to fetch values for a variable
         """
             
-        self.__internal.query = query
+        self._internal.query = query
+    
+        return self
+    
+    def all_format(self, all_format: str) -> typing.Self:    
+        """
+        Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+        """
+            
+        self._internal.all_format = all_format
     
         return self
     
     def current(self, current: dashboard.VariableOption) -> typing.Self:    
         """
         Shows current selected variable text/value on the dashboard
         """
             
-        self.__internal.current = current
+        self._internal.current = current
     
         return self
     
     def multi(self, multi: bool) -> typing.Self:    
         """
         Whether multiple values can be selected or not from variable value list
         """
             
-        self.__internal.multi = multi
+        self._internal.multi = multi
     
         return self
     
     def options(self, options: list[dashboard.VariableOption]) -> typing.Self:    
         """
         Options that can be selected for a variable.
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
     def include_all(self, include_all: bool) -> typing.Self:    
         """
         Whether all value option is available or not
         """
             
-        self.__internal.include_all = include_all
+        self._internal.include_all = include_all
     
         return self
     
     def all_value(self, all_value: str) -> typing.Self:    
         """
         Custom all value
         """
             
-        self.__internal.all_value = all_value
+        self._internal.all_value = all_value
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/dashboardlist.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/piechart.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,193 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import dashboardlist
+from ..models import piechart
 from ..cog import variants as cogvariants
+from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "dashlist"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "piechart"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,263 +244,253 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def keep_time(self, keep_time: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def pie_type(self, pie_type: piechart.PieChartType) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.keep_time = keep_time
+        self._internal.options.pie_type = pie_type
     
         return self
     
-    def include_vars(self, include_vars: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def display_labels(self, display_labels: list[piechart.PieChartLabels]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.include_vars = include_vars
+        self._internal.options.display_labels = display_labels
     
         return self
     
-    def show_starred(self, show_starred: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.show_starred = show_starred
+        tooltip_resource = tooltip.build()
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
-    def show_recently_viewed(self, show_recently_viewed: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.show_recently_viewed = show_recently_viewed
+        reduce_options_resource = reduce_options.build()
+        self._internal.options.reduce_options = reduce_options_resource
     
         return self
     
-    def show_search(self, show_search: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.show_search = show_search
+        text_resource = text.build()
+        self._internal.options.text = text_resource
     
         return self
     
-    def show_headings(self, show_headings: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def legend(self, legend: piechart.PieChartLegendOptions) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.show_headings = show_headings
+        self._internal.options.legend = legend
     
         return self
     
-    def max_items(self, max_items: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = piechart.Options()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.options, piechart.Options)
         
-        self.__internal.options.max_items = max_items
+        self._internal.options.orientation = orientation
     
         return self
     
-    def query(self, query: str) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+    def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        self.__internal.options.query = query
-    
-        return self
-    
-    def folder_id(self, folder_id: int) -> typing.Self:    
-        """
-        folderId is deprecated, and migrated to folderUid on panel init
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.options.folder_id = folder_id
-    
-        return self
-    
-    def folder_uid(self, folder_uid: str) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = dashboardlist.Options()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = piechart.FieldConfig()
         
-        assert isinstance(self.__internal.options, dashboardlist.Options)
+        assert isinstance(self._internal.field_config.defaults.custom, piechart.FieldConfig)
         
-        self.__internal.options.folder_uid = folder_uid
+        hide_from_resource = hide_from.build()
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/datagrid.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/datagrid.py`

 * *Files 14% similar despite different names*

```diff
@@ -8,186 +8,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "datagrid"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "datagrid"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,171 +243,171 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def selected_series(self, selected_series: int) -> typing.Self:        
         if not selected_series >= 0:
             raise ValueError("selected_series must be >= 0")
-        if self.__internal.options is None:
-            self.__internal.options = datagrid.Options()
+        if self._internal.options is None:
+            self._internal.options = datagrid.Options()
         
-        assert isinstance(self.__internal.options, datagrid.Options)
+        assert isinstance(self._internal.options, datagrid.Options)
         
-        self.__internal.options.selected_series = selected_series
+        self._internal.options.selected_series = selected_series
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/debug.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/gauge.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,193 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import debug
+from ..models import gauge
 from ..cog import variants as cogvariants
+from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "debug"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "gauge"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,179 +244,211 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def mode(self, mode: debug.DebugMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = debug.Options()
+    def show_threshold_labels(self, show_threshold_labels: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = gauge.Options()
+        
+        assert isinstance(self._internal.options, gauge.Options)
+        
+        self._internal.options.show_threshold_labels = show_threshold_labels
+    
+        return self
+    
+    def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = gauge.Options()
+        
+        assert isinstance(self._internal.options, gauge.Options)
+        
+        reduce_options_resource = reduce_options.build()
+        self._internal.options.reduce_options = reduce_options_resource
+    
+        return self
+    
+    def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = gauge.Options()
+        
+        assert isinstance(self._internal.options, gauge.Options)
+        
+        text_resource = text.build()
+        self._internal.options.text = text_resource
+    
+        return self
+    
+    def show_threshold_markers(self, show_threshold_markers: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = gauge.Options()
         
-        assert isinstance(self.__internal.options, debug.Options)
+        assert isinstance(self._internal.options, gauge.Options)
         
-        self.__internal.options.mode = mode
+        self._internal.options.show_threshold_markers = show_threshold_markers
     
         return self
     
-    def counters(self, counters: debug.UpdateConfig) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = debug.Options()
+    def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = gauge.Options()
         
-        assert isinstance(self.__internal.options, debug.Options)
+        assert isinstance(self._internal.options, gauge.Options)
         
-        self.__internal.options.counters = counters
+        self._internal.options.orientation = orientation
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/elasticsearch.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/elasticsearch.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,1990 +2,1990 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import elasticsearch
 
 
 class BaseBucketAggregation(cogbuilder.Builder[elasticsearch.BaseBucketAggregation]):    
-    __internal: elasticsearch.BaseBucketAggregation
+    _internal: elasticsearch.BaseBucketAggregation
 
     def __init__(self):
-        self.__internal = elasticsearch.BaseBucketAggregation()
+        self._internal = elasticsearch.BaseBucketAggregation()
 
     def build(self) -> elasticsearch.BaseBucketAggregation:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def type_val(self, type_val: elasticsearch.BucketAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def settings(self, settings: object) -> typing.Self:        
-        self.__internal.settings = settings
+        self._internal.settings = settings
     
         return self
     
 
 class BucketAggregationWithField(cogbuilder.Builder[elasticsearch.BucketAggregationWithField]):    
-    __internal: elasticsearch.BucketAggregationWithField
+    _internal: elasticsearch.BucketAggregationWithField
 
     def __init__(self):
-        self.__internal = elasticsearch.BucketAggregationWithField()
+        self._internal = elasticsearch.BucketAggregationWithField()
 
     def build(self) -> elasticsearch.BucketAggregationWithField:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def type_val(self, type_val: elasticsearch.BucketAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def settings(self, settings: object) -> typing.Self:        
-        self.__internal.settings = settings
+        self._internal.settings = settings
     
         return self
     
 
 class DateHistogram(cogbuilder.Builder[elasticsearch.DateHistogram]):    
-    __internal: elasticsearch.DateHistogram
+    _internal: elasticsearch.DateHistogram
 
     def __init__(self):
-        self.__internal = elasticsearch.DateHistogram()        
-        self.__internal.type_val = "date_histogram"
+        self._internal = elasticsearch.DateHistogram()        
+        self._internal.type_val = "date_histogram"
 
     def build(self) -> elasticsearch.DateHistogram:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchDateHistogramSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
 
 class DateHistogramSettings(cogbuilder.Builder[elasticsearch.DateHistogramSettings]):    
-    __internal: elasticsearch.DateHistogramSettings
+    _internal: elasticsearch.DateHistogramSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.DateHistogramSettings()
+        self._internal = elasticsearch.DateHistogramSettings()
 
     def build(self) -> elasticsearch.DateHistogramSettings:
-        return self.__internal    
+        return self._internal    
     
     def interval(self, interval: str) -> typing.Self:        
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
     def trim_edges(self, trim_edges: str) -> typing.Self:        
-        self.__internal.trim_edges = trim_edges
+        self._internal.trim_edges = trim_edges
     
         return self
     
     def offset(self, offset: str) -> typing.Self:        
-        self.__internal.offset = offset
+        self._internal.offset = offset
     
         return self
     
     def time_zone(self, time_zone: str) -> typing.Self:        
-        self.__internal.time_zone = time_zone
+        self._internal.time_zone = time_zone
     
         return self
     
 
 class Histogram(cogbuilder.Builder[elasticsearch.Histogram]):    
-    __internal: elasticsearch.Histogram
+    _internal: elasticsearch.Histogram
 
     def __init__(self):
-        self.__internal = elasticsearch.Histogram()        
-        self.__internal.type_val = "histogram"
+        self._internal = elasticsearch.Histogram()        
+        self._internal.type_val = "histogram"
 
     def build(self) -> elasticsearch.Histogram:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchHistogramSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
 
 class HistogramSettings(cogbuilder.Builder[elasticsearch.HistogramSettings]):    
-    __internal: elasticsearch.HistogramSettings
+    _internal: elasticsearch.HistogramSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.HistogramSettings()
+        self._internal = elasticsearch.HistogramSettings()
 
     def build(self) -> elasticsearch.HistogramSettings:
-        return self.__internal    
+        return self._internal    
     
     def interval(self, interval: str) -> typing.Self:        
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
 
 class Nested(cogbuilder.Builder[elasticsearch.Nested]):    
-    __internal: elasticsearch.Nested
+    _internal: elasticsearch.Nested
 
     def __init__(self):
-        self.__internal = elasticsearch.Nested()        
-        self.__internal.type_val = "nested"
+        self._internal = elasticsearch.Nested()        
+        self._internal.type_val = "nested"
 
     def build(self) -> elasticsearch.Nested:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: object) -> typing.Self:        
-        self.__internal.settings = settings
+        self._internal.settings = settings
     
         return self
     
 
 class Terms(cogbuilder.Builder[elasticsearch.Terms]):    
-    __internal: elasticsearch.Terms
+    _internal: elasticsearch.Terms
 
     def __init__(self):
-        self.__internal = elasticsearch.Terms()        
-        self.__internal.type_val = "terms"
+        self._internal = elasticsearch.Terms()        
+        self._internal.type_val = "terms"
 
     def build(self) -> elasticsearch.Terms:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchTermsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
 
 class TermsSettings(cogbuilder.Builder[elasticsearch.TermsSettings]):    
-    __internal: elasticsearch.TermsSettings
+    _internal: elasticsearch.TermsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.TermsSettings()
+        self._internal = elasticsearch.TermsSettings()
 
     def build(self) -> elasticsearch.TermsSettings:
-        return self.__internal    
+        return self._internal    
     
     def order(self, order: elasticsearch.TermsOrder) -> typing.Self:        
-        self.__internal.order = order
+        self._internal.order = order
     
         return self
     
     def size(self, size: str) -> typing.Self:        
-        self.__internal.size = size
+        self._internal.size = size
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
     def order_by(self, order_by: str) -> typing.Self:        
-        self.__internal.order_by = order_by
+        self._internal.order_by = order_by
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class Filters(cogbuilder.Builder[elasticsearch.Filters]):    
-    __internal: elasticsearch.Filters
+    _internal: elasticsearch.Filters
 
     def __init__(self):
-        self.__internal = elasticsearch.Filters()        
-        self.__internal.type_val = "filters"
+        self._internal = elasticsearch.Filters()        
+        self._internal.type_val = "filters"
 
     def build(self) -> elasticsearch.Filters:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchFiltersSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
 
 class Filter(cogbuilder.Builder[elasticsearch.Filter]):    
-    __internal: elasticsearch.Filter
+    _internal: elasticsearch.Filter
 
     def __init__(self):
-        self.__internal = elasticsearch.Filter()
+        self._internal = elasticsearch.Filter()
 
     def build(self) -> elasticsearch.Filter:
-        return self.__internal    
+        return self._internal    
     
     def query(self, query: str) -> typing.Self:        
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def label(self, label: str) -> typing.Self:        
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
 
 class FiltersSettings(cogbuilder.Builder[elasticsearch.FiltersSettings]):    
-    __internal: elasticsearch.FiltersSettings
+    _internal: elasticsearch.FiltersSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.FiltersSettings()
+        self._internal = elasticsearch.FiltersSettings()
 
     def build(self) -> elasticsearch.FiltersSettings:
-        return self.__internal    
+        return self._internal    
     
     def filters(self, filters: list[cogbuilder.Builder[elasticsearch.Filter]]) -> typing.Self:        
         filters_resources = [r1.build() for r1 in filters]
-        self.__internal.filters = filters_resources
+        self._internal.filters = filters_resources
     
         return self
     
 
 class GeoHashGrid(cogbuilder.Builder[elasticsearch.GeoHashGrid]):    
-    __internal: elasticsearch.GeoHashGrid
+    _internal: elasticsearch.GeoHashGrid
 
     def __init__(self):
-        self.__internal = elasticsearch.GeoHashGrid()        
-        self.__internal.type_val = "geohash_grid"
+        self._internal = elasticsearch.GeoHashGrid()        
+        self._internal.type_val = "geohash_grid"
 
     def build(self) -> elasticsearch.GeoHashGrid:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchGeoHashGridSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
 
 class GeoHashGridSettings(cogbuilder.Builder[elasticsearch.GeoHashGridSettings]):    
-    __internal: elasticsearch.GeoHashGridSettings
+    _internal: elasticsearch.GeoHashGridSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.GeoHashGridSettings()
+        self._internal = elasticsearch.GeoHashGridSettings()
 
     def build(self) -> elasticsearch.GeoHashGridSettings:
-        return self.__internal    
+        return self._internal    
     
     def precision(self, precision: str) -> typing.Self:        
-        self.__internal.precision = precision
+        self._internal.precision = precision
     
         return self
     
 
 class BaseMetricAggregation(cogbuilder.Builder[elasticsearch.BaseMetricAggregation]):    
-    __internal: elasticsearch.BaseMetricAggregation
+    _internal: elasticsearch.BaseMetricAggregation
 
     def __init__(self):
-        self.__internal = elasticsearch.BaseMetricAggregation()
+        self._internal = elasticsearch.BaseMetricAggregation()
 
     def build(self) -> elasticsearch.BaseMetricAggregation:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: elasticsearch.MetricAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class PipelineVariable(cogbuilder.Builder[elasticsearch.PipelineVariable]):    
-    __internal: elasticsearch.PipelineVariable
+    _internal: elasticsearch.PipelineVariable
 
     def __init__(self):
-        self.__internal = elasticsearch.PipelineVariable()
+        self._internal = elasticsearch.PipelineVariable()
 
     def build(self) -> elasticsearch.PipelineVariable:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
 
 class MetricAggregationWithField(cogbuilder.Builder[elasticsearch.MetricAggregationWithField]):    
-    __internal: elasticsearch.MetricAggregationWithField
+    _internal: elasticsearch.MetricAggregationWithField
 
     def __init__(self):
-        self.__internal = elasticsearch.MetricAggregationWithField()
+        self._internal = elasticsearch.MetricAggregationWithField()
 
     def build(self) -> elasticsearch.MetricAggregationWithField:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def type_val(self, type_val: elasticsearch.MetricAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class MetricAggregationWithMissingSupport(cogbuilder.Builder[elasticsearch.MetricAggregationWithMissingSupport]):    
-    __internal: elasticsearch.MetricAggregationWithMissingSupport
+    _internal: elasticsearch.MetricAggregationWithMissingSupport
 
     def __init__(self):
-        self.__internal = elasticsearch.MetricAggregationWithMissingSupport()
+        self._internal = elasticsearch.MetricAggregationWithMissingSupport()
 
     def build(self) -> elasticsearch.MetricAggregationWithMissingSupport:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def type_val(self, type_val: elasticsearch.MetricAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class MetricAggregationWithInlineScript(cogbuilder.Builder[elasticsearch.MetricAggregationWithInlineScript]):    
-    __internal: elasticsearch.MetricAggregationWithInlineScript
+    _internal: elasticsearch.MetricAggregationWithInlineScript
 
     def __init__(self):
-        self.__internal = elasticsearch.MetricAggregationWithInlineScript()
+        self._internal = elasticsearch.MetricAggregationWithInlineScript()
 
     def build(self) -> elasticsearch.MetricAggregationWithInlineScript:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def type_val(self, type_val: elasticsearch.MetricAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Count(cogbuilder.Builder[elasticsearch.Count]):    
-    __internal: elasticsearch.Count
+    _internal: elasticsearch.Count
 
     def __init__(self):
-        self.__internal = elasticsearch.Count()        
-        self.__internal.type_val = "count"
+        self._internal = elasticsearch.Count()        
+        self._internal.type_val = "count"
 
     def build(self) -> elasticsearch.Count:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Average(cogbuilder.Builder[elasticsearch.Average]):    
-    __internal: elasticsearch.Average
+    _internal: elasticsearch.Average
 
     def __init__(self):
-        self.__internal = elasticsearch.Average()        
-        self.__internal.type_val = "avg"
+        self._internal = elasticsearch.Average()        
+        self._internal.type_val = "avg"
 
     def build(self) -> elasticsearch.Average:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchAverageSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Sum(cogbuilder.Builder[elasticsearch.Sum]):    
-    __internal: elasticsearch.Sum
+    _internal: elasticsearch.Sum
 
     def __init__(self):
-        self.__internal = elasticsearch.Sum()        
-        self.__internal.type_val = "sum"
+        self._internal = elasticsearch.Sum()        
+        self._internal.type_val = "sum"
 
     def build(self) -> elasticsearch.Sum:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchSumSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Max(cogbuilder.Builder[elasticsearch.Max]):    
-    __internal: elasticsearch.Max
+    _internal: elasticsearch.Max
 
     def __init__(self):
-        self.__internal = elasticsearch.Max()        
-        self.__internal.type_val = "max"
+        self._internal = elasticsearch.Max()        
+        self._internal.type_val = "max"
 
     def build(self) -> elasticsearch.Max:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMaxSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Min(cogbuilder.Builder[elasticsearch.Min]):    
-    __internal: elasticsearch.Min
+    _internal: elasticsearch.Min
 
     def __init__(self):
-        self.__internal = elasticsearch.Min()        
-        self.__internal.type_val = "min"
+        self._internal = elasticsearch.Min()        
+        self._internal.type_val = "min"
 
     def build(self) -> elasticsearch.Min:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMinSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class ExtendedStat(cogbuilder.Builder[elasticsearch.ExtendedStat]):    
-    __internal: elasticsearch.ExtendedStat
+    _internal: elasticsearch.ExtendedStat
 
     def __init__(self):
-        self.__internal = elasticsearch.ExtendedStat()
+        self._internal = elasticsearch.ExtendedStat()
 
     def build(self) -> elasticsearch.ExtendedStat:
-        return self.__internal    
+        return self._internal    
     
     def label(self, label: str) -> typing.Self:        
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def value(self, value: elasticsearch.ExtendedStatMetaType) -> typing.Self:        
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
 
 class ExtendedStats(cogbuilder.Builder[elasticsearch.ExtendedStats]):    
-    __internal: elasticsearch.ExtendedStats
+    _internal: elasticsearch.ExtendedStats
 
     def __init__(self):
-        self.__internal = elasticsearch.ExtendedStats()        
-        self.__internal.type_val = "extended_stats"
+        self._internal = elasticsearch.ExtendedStats()        
+        self._internal.type_val = "extended_stats"
 
     def build(self) -> elasticsearch.ExtendedStats:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchExtendedStatsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def meta(self, meta: object) -> typing.Self:        
-        self.__internal.meta = meta
+        self._internal.meta = meta
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Percentiles(cogbuilder.Builder[elasticsearch.Percentiles]):    
-    __internal: elasticsearch.Percentiles
+    _internal: elasticsearch.Percentiles
 
     def __init__(self):
-        self.__internal = elasticsearch.Percentiles()        
-        self.__internal.type_val = "percentiles"
+        self._internal = elasticsearch.Percentiles()        
+        self._internal.type_val = "percentiles"
 
     def build(self) -> elasticsearch.Percentiles:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchPercentilesSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class UniqueCount(cogbuilder.Builder[elasticsearch.UniqueCount]):    
-    __internal: elasticsearch.UniqueCount
+    _internal: elasticsearch.UniqueCount
 
     def __init__(self):
-        self.__internal = elasticsearch.UniqueCount()        
-        self.__internal.type_val = "cardinality"
+        self._internal = elasticsearch.UniqueCount()        
+        self._internal.type_val = "cardinality"
 
     def build(self) -> elasticsearch.UniqueCount:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchUniqueCountSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class RawDocument(cogbuilder.Builder[elasticsearch.RawDocument]):    
-    __internal: elasticsearch.RawDocument
+    _internal: elasticsearch.RawDocument
 
     def __init__(self):
-        self.__internal = elasticsearch.RawDocument()        
-        self.__internal.type_val = "raw_document"
+        self._internal = elasticsearch.RawDocument()        
+        self._internal.type_val = "raw_document"
 
     def build(self) -> elasticsearch.RawDocument:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchRawDocumentSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class RawData(cogbuilder.Builder[elasticsearch.RawData]):    
-    __internal: elasticsearch.RawData
+    _internal: elasticsearch.RawData
 
     def __init__(self):
-        self.__internal = elasticsearch.RawData()        
-        self.__internal.type_val = "raw_data"
+        self._internal = elasticsearch.RawData()        
+        self._internal.type_val = "raw_data"
 
     def build(self) -> elasticsearch.RawData:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchRawDataSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Logs(cogbuilder.Builder[elasticsearch.Logs]):    
-    __internal: elasticsearch.Logs
+    _internal: elasticsearch.Logs
 
     def __init__(self):
-        self.__internal = elasticsearch.Logs()        
-        self.__internal.type_val = "logs"
+        self._internal = elasticsearch.Logs()        
+        self._internal.type_val = "logs"
 
     def build(self) -> elasticsearch.Logs:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchLogsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Rate(cogbuilder.Builder[elasticsearch.Rate]):    
-    __internal: elasticsearch.Rate
+    _internal: elasticsearch.Rate
 
     def __init__(self):
-        self.__internal = elasticsearch.Rate()        
-        self.__internal.type_val = "rate"
+        self._internal = elasticsearch.Rate()        
+        self._internal.type_val = "rate"
 
     def build(self) -> elasticsearch.Rate:
-        return self.__internal    
+        return self._internal    
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchRateSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class BasePipelineMetricAggregation(cogbuilder.Builder[elasticsearch.BasePipelineMetricAggregation]):    
-    __internal: elasticsearch.BasePipelineMetricAggregation
+    _internal: elasticsearch.BasePipelineMetricAggregation
 
     def __init__(self):
-        self.__internal = elasticsearch.BasePipelineMetricAggregation()
+        self._internal = elasticsearch.BasePipelineMetricAggregation()
 
     def build(self) -> elasticsearch.BasePipelineMetricAggregation:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def type_val(self, type_val: str) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class PipelineMetricAggregationWithMultipleBucketPaths(cogbuilder.Builder[elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths]):    
-    __internal: elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths
+    _internal: elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths
 
     def __init__(self):
-        self.__internal = elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths()
+        self._internal = elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths()
 
     def build(self) -> elasticsearch.PipelineMetricAggregationWithMultipleBucketPaths:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_variables(self, pipeline_variables: list[cogbuilder.Builder[elasticsearch.PipelineVariable]]) -> typing.Self:        
         pipeline_variables_resources = [r1.build() for r1 in pipeline_variables]
-        self.__internal.pipeline_variables = pipeline_variables_resources
+        self._internal.pipeline_variables = pipeline_variables_resources
     
         return self
     
     def type_val(self, type_val: elasticsearch.MetricAggregationType) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class MovingAverageModelOption(cogbuilder.Builder[elasticsearch.MovingAverageModelOption]):    
-    __internal: elasticsearch.MovingAverageModelOption
+    _internal: elasticsearch.MovingAverageModelOption
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageModelOption()
+        self._internal = elasticsearch.MovingAverageModelOption()
 
     def build(self) -> elasticsearch.MovingAverageModelOption:
-        return self.__internal    
+        return self._internal    
     
     def label(self, label: str) -> typing.Self:        
-        self.__internal.label = label
+        self._internal.label = label
     
         return self
     
     def value(self, value: elasticsearch.MovingAverageModel) -> typing.Self:        
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
 
 class BaseMovingAverageModelSettings(cogbuilder.Builder[elasticsearch.BaseMovingAverageModelSettings]):    
-    __internal: elasticsearch.BaseMovingAverageModelSettings
+    _internal: elasticsearch.BaseMovingAverageModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.BaseMovingAverageModelSettings()
+        self._internal = elasticsearch.BaseMovingAverageModelSettings()
 
     def build(self) -> elasticsearch.BaseMovingAverageModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def model(self, model: elasticsearch.MovingAverageModel) -> typing.Self:        
-        self.__internal.model = model
+        self._internal.model = model
     
         return self
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverageSimpleModelSettings(cogbuilder.Builder[elasticsearch.MovingAverageSimpleModelSettings]):    
-    __internal: elasticsearch.MovingAverageSimpleModelSettings
+    _internal: elasticsearch.MovingAverageSimpleModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageSimpleModelSettings()        
-        self.__internal.model = "simple"
+        self._internal = elasticsearch.MovingAverageSimpleModelSettings()        
+        self._internal.model = "simple"
 
     def build(self) -> elasticsearch.MovingAverageSimpleModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverageLinearModelSettings(cogbuilder.Builder[elasticsearch.MovingAverageLinearModelSettings]):    
-    __internal: elasticsearch.MovingAverageLinearModelSettings
+    _internal: elasticsearch.MovingAverageLinearModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageLinearModelSettings()        
-        self.__internal.model = "linear"
+        self._internal = elasticsearch.MovingAverageLinearModelSettings()        
+        self._internal.model = "linear"
 
     def build(self) -> elasticsearch.MovingAverageLinearModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverageEWMAModelSettings(cogbuilder.Builder[elasticsearch.MovingAverageEWMAModelSettings]):    
-    __internal: elasticsearch.MovingAverageEWMAModelSettings
+    _internal: elasticsearch.MovingAverageEWMAModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageEWMAModelSettings()        
-        self.__internal.model = "ewma"
+        self._internal = elasticsearch.MovingAverageEWMAModelSettings()        
+        self._internal.model = "ewma"
 
     def build(self) -> elasticsearch.MovingAverageEWMAModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def minimize(self, minimize: bool) -> typing.Self:        
-        self.__internal.minimize = minimize
+        self._internal.minimize = minimize
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverageHoltModelSettings(cogbuilder.Builder[elasticsearch.MovingAverageHoltModelSettings]):    
-    __internal: elasticsearch.MovingAverageHoltModelSettings
+    _internal: elasticsearch.MovingAverageHoltModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageHoltModelSettings()        
-        self.__internal.model = "holt"
+        self._internal = elasticsearch.MovingAverageHoltModelSettings()        
+        self._internal.model = "holt"
 
     def build(self) -> elasticsearch.MovingAverageHoltModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def minimize(self, minimize: bool) -> typing.Self:        
-        self.__internal.minimize = minimize
+        self._internal.minimize = minimize
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverageHoltWintersModelSettings(cogbuilder.Builder[elasticsearch.MovingAverageHoltWintersModelSettings]):    
-    __internal: elasticsearch.MovingAverageHoltWintersModelSettings
+    _internal: elasticsearch.MovingAverageHoltWintersModelSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverageHoltWintersModelSettings()        
-        self.__internal.model = "holt_winters"
+        self._internal = elasticsearch.MovingAverageHoltWintersModelSettings()        
+        self._internal.model = "holt_winters"
 
     def build(self) -> elasticsearch.MovingAverageHoltWintersModelSettings:
-        return self.__internal    
+        return self._internal    
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def minimize(self, minimize: bool) -> typing.Self:        
-        self.__internal.minimize = minimize
+        self._internal.minimize = minimize
     
         return self
     
     def predict(self, predict: str) -> typing.Self:        
-        self.__internal.predict = predict
+        self._internal.predict = predict
     
         return self
     
 
 class MovingAverage(cogbuilder.Builder[elasticsearch.MovingAverage]):    
     """
     #MovingAverage's settings are overridden in types.ts
     """
     
-    __internal: elasticsearch.MovingAverage
+    _internal: elasticsearch.MovingAverage
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingAverage()        
-        self.__internal.type_val = "moving_avg"
+        self._internal = elasticsearch.MovingAverage()        
+        self._internal.type_val = "moving_avg"
 
     def build(self) -> elasticsearch.MovingAverage:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: object) -> typing.Self:        
-        self.__internal.settings = settings
+        self._internal.settings = settings
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class MovingFunction(cogbuilder.Builder[elasticsearch.MovingFunction]):    
-    __internal: elasticsearch.MovingFunction
+    _internal: elasticsearch.MovingFunction
 
     def __init__(self):
-        self.__internal = elasticsearch.MovingFunction()        
-        self.__internal.type_val = "moving_fn"
+        self._internal = elasticsearch.MovingFunction()        
+        self._internal.type_val = "moving_fn"
 
     def build(self) -> elasticsearch.MovingFunction:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchMovingFunctionSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Derivative(cogbuilder.Builder[elasticsearch.Derivative]):    
-    __internal: elasticsearch.Derivative
+    _internal: elasticsearch.Derivative
 
     def __init__(self):
-        self.__internal = elasticsearch.Derivative()        
-        self.__internal.type_val = "derivative"
+        self._internal = elasticsearch.Derivative()        
+        self._internal.type_val = "derivative"
 
     def build(self) -> elasticsearch.Derivative:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchDerivativeSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class SerialDiff(cogbuilder.Builder[elasticsearch.SerialDiff]):    
-    __internal: elasticsearch.SerialDiff
+    _internal: elasticsearch.SerialDiff
 
     def __init__(self):
-        self.__internal = elasticsearch.SerialDiff()        
-        self.__internal.type_val = "serial_diff"
+        self._internal = elasticsearch.SerialDiff()        
+        self._internal.type_val = "serial_diff"
 
     def build(self) -> elasticsearch.SerialDiff:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchSerialDiffSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class CumulativeSum(cogbuilder.Builder[elasticsearch.CumulativeSum]):    
-    __internal: elasticsearch.CumulativeSum
+    _internal: elasticsearch.CumulativeSum
 
     def __init__(self):
-        self.__internal = elasticsearch.CumulativeSum()        
-        self.__internal.type_val = "cumulative_sum"
+        self._internal = elasticsearch.CumulativeSum()        
+        self._internal.type_val = "cumulative_sum"
 
     def build(self) -> elasticsearch.CumulativeSum:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_agg(self, pipeline_agg: str) -> typing.Self:        
-        self.__internal.pipeline_agg = pipeline_agg
+        self._internal.pipeline_agg = pipeline_agg
     
         return self
     
     def field(self, field: str) -> typing.Self:        
-        self.__internal.field = field
+        self._internal.field = field
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchCumulativeSumSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class BucketScript(cogbuilder.Builder[elasticsearch.BucketScript]):    
-    __internal: elasticsearch.BucketScript
+    _internal: elasticsearch.BucketScript
 
     def __init__(self):
-        self.__internal = elasticsearch.BucketScript()        
-        self.__internal.type_val = "bucket_script"
+        self._internal = elasticsearch.BucketScript()        
+        self._internal.type_val = "bucket_script"
 
     def build(self) -> elasticsearch.BucketScript:
-        return self.__internal    
+        return self._internal    
     
     def pipeline_variables(self, pipeline_variables: list[cogbuilder.Builder[elasticsearch.PipelineVariable]]) -> typing.Self:        
         pipeline_variables_resources = [r1.build() for r1 in pipeline_variables]
-        self.__internal.pipeline_variables = pipeline_variables_resources
+        self._internal.pipeline_variables = pipeline_variables_resources
     
         return self
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchBucketScriptSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class TopMetrics(cogbuilder.Builder[elasticsearch.TopMetrics]):    
-    __internal: elasticsearch.TopMetrics
+    _internal: elasticsearch.TopMetrics
 
     def __init__(self):
-        self.__internal = elasticsearch.TopMetrics()        
-        self.__internal.type_val = "top_metrics"
+        self._internal = elasticsearch.TopMetrics()        
+        self._internal.type_val = "top_metrics"
 
     def build(self) -> elasticsearch.TopMetrics:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def settings(self, settings: cogbuilder.Builder[elasticsearch.ElasticsearchTopMetricsSettings]) -> typing.Self:        
         settings_resource = settings.build()
-        self.__internal.settings = settings_resource
+        self._internal.settings = settings_resource
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
 
 class Dataquery(cogbuilder.Builder[elasticsearch.Dataquery]):    
-    __internal: elasticsearch.Dataquery
+    _internal: elasticsearch.Dataquery
 
     def __init__(self):
-        self.__internal = elasticsearch.Dataquery()
+        self._internal = elasticsearch.Dataquery()
 
     def build(self) -> elasticsearch.Dataquery:
-        return self.__internal    
+        return self._internal    
     
     def alias(self, alias: str) -> typing.Self:        
-        self.__internal.alias = alias
+        self._internal.alias = alias
     
         return self
     
     def query(self, query: str) -> typing.Self:        
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def time_field(self, time_field: str) -> typing.Self:        
-        self.__internal.time_field = time_field
+        self._internal.time_field = time_field
     
         return self
     
     def bucket_aggs(self, bucket_aggs: list[elasticsearch.BucketAggregation]) -> typing.Self:        
-        self.__internal.bucket_aggs = bucket_aggs
+        self._internal.bucket_aggs = bucket_aggs
     
         return self
     
     def metrics(self, metrics: list[elasticsearch.MetricAggregation]) -> typing.Self:        
-        self.__internal.metrics = metrics
+        self._internal.metrics = metrics
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:        
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:        
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:        
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
 
 class ElasticsearchDateHistogramSettings(cogbuilder.Builder[elasticsearch.ElasticsearchDateHistogramSettings]):    
-    __internal: elasticsearch.ElasticsearchDateHistogramSettings
+    _internal: elasticsearch.ElasticsearchDateHistogramSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchDateHistogramSettings()
+        self._internal = elasticsearch.ElasticsearchDateHistogramSettings()
 
     def build(self) -> elasticsearch.ElasticsearchDateHistogramSettings:
-        return self.__internal    
+        return self._internal    
     
     def interval(self, interval: str) -> typing.Self:        
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
     def trim_edges(self, trim_edges: str) -> typing.Self:        
-        self.__internal.trim_edges = trim_edges
+        self._internal.trim_edges = trim_edges
     
         return self
     
     def offset(self, offset: str) -> typing.Self:        
-        self.__internal.offset = offset
+        self._internal.offset = offset
     
         return self
     
     def time_zone(self, time_zone: str) -> typing.Self:        
-        self.__internal.time_zone = time_zone
+        self._internal.time_zone = time_zone
     
         return self
     
 
 class ElasticsearchHistogramSettings(cogbuilder.Builder[elasticsearch.ElasticsearchHistogramSettings]):    
-    __internal: elasticsearch.ElasticsearchHistogramSettings
+    _internal: elasticsearch.ElasticsearchHistogramSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchHistogramSettings()
+        self._internal = elasticsearch.ElasticsearchHistogramSettings()
 
     def build(self) -> elasticsearch.ElasticsearchHistogramSettings:
-        return self.__internal    
+        return self._internal    
     
     def interval(self, interval: str) -> typing.Self:        
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
 
 class ElasticsearchTermsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchTermsSettings]):    
-    __internal: elasticsearch.ElasticsearchTermsSettings
+    _internal: elasticsearch.ElasticsearchTermsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchTermsSettings()
+        self._internal = elasticsearch.ElasticsearchTermsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchTermsSettings:
-        return self.__internal    
+        return self._internal    
     
     def order(self, order: elasticsearch.TermsOrder) -> typing.Self:        
-        self.__internal.order = order
+        self._internal.order = order
     
         return self
     
     def size(self, size: str) -> typing.Self:        
-        self.__internal.size = size
+        self._internal.size = size
     
         return self
     
     def min_doc_count(self, min_doc_count: str) -> typing.Self:        
-        self.__internal.min_doc_count = min_doc_count
+        self._internal.min_doc_count = min_doc_count
     
         return self
     
     def order_by(self, order_by: str) -> typing.Self:        
-        self.__internal.order_by = order_by
+        self._internal.order_by = order_by
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchFiltersSettings(cogbuilder.Builder[elasticsearch.ElasticsearchFiltersSettings]):    
-    __internal: elasticsearch.ElasticsearchFiltersSettings
+    _internal: elasticsearch.ElasticsearchFiltersSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchFiltersSettings()
+        self._internal = elasticsearch.ElasticsearchFiltersSettings()
 
     def build(self) -> elasticsearch.ElasticsearchFiltersSettings:
-        return self.__internal    
+        return self._internal    
     
     def filters(self, filters: list[cogbuilder.Builder[elasticsearch.Filter]]) -> typing.Self:        
         filters_resources = [r1.build() for r1 in filters]
-        self.__internal.filters = filters_resources
+        self._internal.filters = filters_resources
     
         return self
     
 
 class ElasticsearchGeoHashGridSettings(cogbuilder.Builder[elasticsearch.ElasticsearchGeoHashGridSettings]):    
-    __internal: elasticsearch.ElasticsearchGeoHashGridSettings
+    _internal: elasticsearch.ElasticsearchGeoHashGridSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchGeoHashGridSettings()
+        self._internal = elasticsearch.ElasticsearchGeoHashGridSettings()
 
     def build(self) -> elasticsearch.ElasticsearchGeoHashGridSettings:
-        return self.__internal    
+        return self._internal    
     
     def precision(self, precision: str) -> typing.Self:        
-        self.__internal.precision = precision
+        self._internal.precision = precision
     
         return self
     
 
 class ElasticsearchMetricAggregationWithMissingSupportSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings]):    
-    __internal: elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings
+    _internal: elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings()
+        self._internal = elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMetricAggregationWithMissingSupportSettings:
-        return self.__internal    
+        return self._internal    
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchInlineScript(cogbuilder.Builder[elasticsearch.ElasticsearchInlineScript]):    
-    __internal: elasticsearch.ElasticsearchInlineScript
+    _internal: elasticsearch.ElasticsearchInlineScript
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchInlineScript()
+        self._internal = elasticsearch.ElasticsearchInlineScript()
 
     def build(self) -> elasticsearch.ElasticsearchInlineScript:
-        return self.__internal    
+        return self._internal    
     
     def inline(self, inline: str) -> typing.Self:        
-        self.__internal.inline = inline
+        self._internal.inline = inline
     
         return self
     
 
 class ElasticsearchMetricAggregationWithInlineScriptSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings]):    
-    __internal: elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings
+    _internal: elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings()
+        self._internal = elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMetricAggregationWithInlineScriptSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
 
 class ElasticsearchAverageSettings(cogbuilder.Builder[elasticsearch.ElasticsearchAverageSettings]):    
-    __internal: elasticsearch.ElasticsearchAverageSettings
+    _internal: elasticsearch.ElasticsearchAverageSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchAverageSettings()
+        self._internal = elasticsearch.ElasticsearchAverageSettings()
 
     def build(self) -> elasticsearch.ElasticsearchAverageSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchSumSettings(cogbuilder.Builder[elasticsearch.ElasticsearchSumSettings]):    
-    __internal: elasticsearch.ElasticsearchSumSettings
+    _internal: elasticsearch.ElasticsearchSumSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchSumSettings()
+        self._internal = elasticsearch.ElasticsearchSumSettings()
 
     def build(self) -> elasticsearch.ElasticsearchSumSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchMaxSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMaxSettings]):    
-    __internal: elasticsearch.ElasticsearchMaxSettings
+    _internal: elasticsearch.ElasticsearchMaxSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMaxSettings()
+        self._internal = elasticsearch.ElasticsearchMaxSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMaxSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchMinSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMinSettings]):    
-    __internal: elasticsearch.ElasticsearchMinSettings
+    _internal: elasticsearch.ElasticsearchMinSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMinSettings()
+        self._internal = elasticsearch.ElasticsearchMinSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMinSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchExtendedStatsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchExtendedStatsSettings]):    
-    __internal: elasticsearch.ElasticsearchExtendedStatsSettings
+    _internal: elasticsearch.ElasticsearchExtendedStatsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchExtendedStatsSettings()
+        self._internal = elasticsearch.ElasticsearchExtendedStatsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchExtendedStatsSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
     def sigma(self, sigma: str) -> typing.Self:        
-        self.__internal.sigma = sigma
+        self._internal.sigma = sigma
     
         return self
     
 
 class ElasticsearchPercentilesSettings(cogbuilder.Builder[elasticsearch.ElasticsearchPercentilesSettings]):    
-    __internal: elasticsearch.ElasticsearchPercentilesSettings
+    _internal: elasticsearch.ElasticsearchPercentilesSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchPercentilesSettings()
+        self._internal = elasticsearch.ElasticsearchPercentilesSettings()
 
     def build(self) -> elasticsearch.ElasticsearchPercentilesSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
     def percents(self, percents: list[str]) -> typing.Self:        
-        self.__internal.percents = percents
+        self._internal.percents = percents
     
         return self
     
 
 class ElasticsearchUniqueCountSettings(cogbuilder.Builder[elasticsearch.ElasticsearchUniqueCountSettings]):    
-    __internal: elasticsearch.ElasticsearchUniqueCountSettings
+    _internal: elasticsearch.ElasticsearchUniqueCountSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchUniqueCountSettings()
+        self._internal = elasticsearch.ElasticsearchUniqueCountSettings()
 
     def build(self) -> elasticsearch.ElasticsearchUniqueCountSettings:
-        return self.__internal    
+        return self._internal    
     
     def precision_threshold(self, precision_threshold: str) -> typing.Self:        
-        self.__internal.precision_threshold = precision_threshold
+        self._internal.precision_threshold = precision_threshold
     
         return self
     
     def missing(self, missing: str) -> typing.Self:        
-        self.__internal.missing = missing
+        self._internal.missing = missing
     
         return self
     
 
 class ElasticsearchRawDocumentSettings(cogbuilder.Builder[elasticsearch.ElasticsearchRawDocumentSettings]):    
-    __internal: elasticsearch.ElasticsearchRawDocumentSettings
+    _internal: elasticsearch.ElasticsearchRawDocumentSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchRawDocumentSettings()
+        self._internal = elasticsearch.ElasticsearchRawDocumentSettings()
 
     def build(self) -> elasticsearch.ElasticsearchRawDocumentSettings:
-        return self.__internal    
+        return self._internal    
     
     def size(self, size: str) -> typing.Self:        
-        self.__internal.size = size
+        self._internal.size = size
     
         return self
     
 
 class ElasticsearchRawDataSettings(cogbuilder.Builder[elasticsearch.ElasticsearchRawDataSettings]):    
-    __internal: elasticsearch.ElasticsearchRawDataSettings
+    _internal: elasticsearch.ElasticsearchRawDataSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchRawDataSettings()
+        self._internal = elasticsearch.ElasticsearchRawDataSettings()
 
     def build(self) -> elasticsearch.ElasticsearchRawDataSettings:
-        return self.__internal    
+        return self._internal    
     
     def size(self, size: str) -> typing.Self:        
-        self.__internal.size = size
+        self._internal.size = size
     
         return self
     
 
 class ElasticsearchLogsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchLogsSettings]):    
-    __internal: elasticsearch.ElasticsearchLogsSettings
+    _internal: elasticsearch.ElasticsearchLogsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchLogsSettings()
+        self._internal = elasticsearch.ElasticsearchLogsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchLogsSettings:
-        return self.__internal    
+        return self._internal    
     
     def limit(self, limit: str) -> typing.Self:        
-        self.__internal.limit = limit
+        self._internal.limit = limit
     
         return self
     
 
 class ElasticsearchRateSettings(cogbuilder.Builder[elasticsearch.ElasticsearchRateSettings]):    
-    __internal: elasticsearch.ElasticsearchRateSettings
+    _internal: elasticsearch.ElasticsearchRateSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchRateSettings()
+        self._internal = elasticsearch.ElasticsearchRateSettings()
 
     def build(self) -> elasticsearch.ElasticsearchRateSettings:
-        return self.__internal    
+        return self._internal    
     
     def unit(self, unit: str) -> typing.Self:        
-        self.__internal.unit = unit
+        self._internal.unit = unit
     
         return self
     
     def mode(self, mode: str) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
 
 class ElasticsearchMovingAverageEWMAModelSettingsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings]):    
-    __internal: elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings
+    _internal: elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings()
+        self._internal = elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMovingAverageEWMAModelSettingsSettings:
-        return self.__internal    
+        return self._internal    
     
     def alpha(self, alpha: str) -> typing.Self:        
-        self.__internal.alpha = alpha
+        self._internal.alpha = alpha
     
         return self
     
 
 class ElasticsearchMovingAverageHoltModelSettingsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings]):    
-    __internal: elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings
+    _internal: elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings()
+        self._internal = elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMovingAverageHoltModelSettingsSettings:
-        return self.__internal    
+        return self._internal    
     
     def alpha(self, alpha: str) -> typing.Self:        
-        self.__internal.alpha = alpha
+        self._internal.alpha = alpha
     
         return self
     
     def beta(self, beta: str) -> typing.Self:        
-        self.__internal.beta = beta
+        self._internal.beta = beta
     
         return self
     
 
 class ElasticsearchMovingAverageHoltWintersModelSettingsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings]):    
-    __internal: elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings
+    _internal: elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings()
+        self._internal = elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMovingAverageHoltWintersModelSettingsSettings:
-        return self.__internal    
+        return self._internal    
     
     def alpha(self, alpha: str) -> typing.Self:        
-        self.__internal.alpha = alpha
+        self._internal.alpha = alpha
     
         return self
     
     def beta(self, beta: str) -> typing.Self:        
-        self.__internal.beta = beta
+        self._internal.beta = beta
     
         return self
     
     def gamma(self, gamma: str) -> typing.Self:        
-        self.__internal.gamma = gamma
+        self._internal.gamma = gamma
     
         return self
     
     def period(self, period: str) -> typing.Self:        
-        self.__internal.period = period
+        self._internal.period = period
     
         return self
     
     def pad(self, pad: bool) -> typing.Self:        
-        self.__internal.pad = pad
+        self._internal.pad = pad
     
         return self
     
 
 class ElasticsearchMovingFunctionSettings(cogbuilder.Builder[elasticsearch.ElasticsearchMovingFunctionSettings]):    
-    __internal: elasticsearch.ElasticsearchMovingFunctionSettings
+    _internal: elasticsearch.ElasticsearchMovingFunctionSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchMovingFunctionSettings()
+        self._internal = elasticsearch.ElasticsearchMovingFunctionSettings()
 
     def build(self) -> elasticsearch.ElasticsearchMovingFunctionSettings:
-        return self.__internal    
+        return self._internal    
     
     def window(self, window: str) -> typing.Self:        
-        self.__internal.window = window
+        self._internal.window = window
     
         return self
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
     def shift(self, shift: str) -> typing.Self:        
-        self.__internal.shift = shift
+        self._internal.shift = shift
     
         return self
     
 
 class ElasticsearchDerivativeSettings(cogbuilder.Builder[elasticsearch.ElasticsearchDerivativeSettings]):    
-    __internal: elasticsearch.ElasticsearchDerivativeSettings
+    _internal: elasticsearch.ElasticsearchDerivativeSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchDerivativeSettings()
+        self._internal = elasticsearch.ElasticsearchDerivativeSettings()
 
     def build(self) -> elasticsearch.ElasticsearchDerivativeSettings:
-        return self.__internal    
+        return self._internal    
     
     def unit(self, unit: str) -> typing.Self:        
-        self.__internal.unit = unit
+        self._internal.unit = unit
     
         return self
     
 
 class ElasticsearchSerialDiffSettings(cogbuilder.Builder[elasticsearch.ElasticsearchSerialDiffSettings]):    
-    __internal: elasticsearch.ElasticsearchSerialDiffSettings
+    _internal: elasticsearch.ElasticsearchSerialDiffSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchSerialDiffSettings()
+        self._internal = elasticsearch.ElasticsearchSerialDiffSettings()
 
     def build(self) -> elasticsearch.ElasticsearchSerialDiffSettings:
-        return self.__internal    
+        return self._internal    
     
     def lag(self, lag: str) -> typing.Self:        
-        self.__internal.lag = lag
+        self._internal.lag = lag
     
         return self
     
 
 class ElasticsearchCumulativeSumSettings(cogbuilder.Builder[elasticsearch.ElasticsearchCumulativeSumSettings]):    
-    __internal: elasticsearch.ElasticsearchCumulativeSumSettings
+    _internal: elasticsearch.ElasticsearchCumulativeSumSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchCumulativeSumSettings()
+        self._internal = elasticsearch.ElasticsearchCumulativeSumSettings()
 
     def build(self) -> elasticsearch.ElasticsearchCumulativeSumSettings:
-        return self.__internal    
+        return self._internal    
     
     def format_val(self, format_val: str) -> typing.Self:        
-        self.__internal.format_val = format_val
+        self._internal.format_val = format_val
     
         return self
     
 
 class ElasticsearchBucketScriptSettings(cogbuilder.Builder[elasticsearch.ElasticsearchBucketScriptSettings]):    
-    __internal: elasticsearch.ElasticsearchBucketScriptSettings
+    _internal: elasticsearch.ElasticsearchBucketScriptSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchBucketScriptSettings()
+        self._internal = elasticsearch.ElasticsearchBucketScriptSettings()
 
     def build(self) -> elasticsearch.ElasticsearchBucketScriptSettings:
-        return self.__internal    
+        return self._internal    
     
     def script(self, script: elasticsearch.InlineScript) -> typing.Self:        
-        self.__internal.script = script
+        self._internal.script = script
     
         return self
     
 
 class ElasticsearchTopMetricsSettings(cogbuilder.Builder[elasticsearch.ElasticsearchTopMetricsSettings]):    
-    __internal: elasticsearch.ElasticsearchTopMetricsSettings
+    _internal: elasticsearch.ElasticsearchTopMetricsSettings
 
     def __init__(self):
-        self.__internal = elasticsearch.ElasticsearchTopMetricsSettings()
+        self._internal = elasticsearch.ElasticsearchTopMetricsSettings()
 
     def build(self) -> elasticsearch.ElasticsearchTopMetricsSettings:
-        return self.__internal    
+        return self._internal    
     
     def order(self, order: str) -> typing.Self:        
-        self.__internal.order = order
+        self._internal.order = order
     
         return self
     
     def order_by(self, order_by: str) -> typing.Self:        
-        self.__internal.order_by = order_by
+        self._internal.order_by = order_by
     
         return self
     
     def metrics(self, metrics: list[str]) -> typing.Self:        
-        self.__internal.metrics = metrics
+        self._internal.metrics = metrics
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/gauge.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/logs.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import gauge
+from ..models import logs
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "gauge"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "logs"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,241 +244,239 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def show_threshold_labels(self, show_threshold_labels: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def show_labels(self, show_labels: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.show_threshold_labels = show_threshold_labels
+        self._internal.options.show_labels = show_labels
     
         return self
     
-    def show_threshold_markers(self, show_threshold_markers: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def show_common_labels(self, show_common_labels: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.show_threshold_markers = show_threshold_markers
+        self._internal.options.show_common_labels = show_common_labels
     
         return self
     
-    def sizing(self, sizing: common.BarGaugeSizing) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def show_time(self, show_time: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.sizing = sizing
+        self._internal.options.show_time = show_time
     
         return self
     
-    def min_viz_width(self, min_viz_width: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def wrap_log_message(self, wrap_log_message: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.min_viz_width = min_viz_width
+        self._internal.options.wrap_log_message = wrap_log_message
     
         return self
     
-    def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def prettify_log_message(self, prettify_log_message: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        reduce_options_resource = reduce_options.build()
-        self.__internal.options.reduce_options = reduce_options_resource
+        self._internal.options.prettify_log_message = prettify_log_message
     
         return self
     
-    def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def enable_log_details(self, enable_log_details: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        text_resource = text.build()
-        self.__internal.options.text = text_resource
+        self._internal.options.enable_log_details = enable_log_details
     
         return self
     
-    def min_viz_height(self, min_viz_height: int) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def sort_order(self, sort_order: common.LogsSortOrder) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.min_viz_height = min_viz_height
+        self._internal.options.sort_order = sort_order
     
         return self
     
-    def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = gauge.Options()
+    def dedup_strategy(self, dedup_strategy: common.LogsDedupStrategy) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = logs.Options()
         
-        assert isinstance(self.__internal.options, gauge.Options)
+        assert isinstance(self._internal.options, logs.Options)
         
-        self.__internal.options.orientation = orientation
+        self._internal.options.dedup_strategy = dedup_strategy
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/geomap.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/statushistory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import geomap
+from ..models import statushistory
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "geomap"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "status-history"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,211 +244,304 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def view(self, view: geomap.MapViewConfig) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = geomap.Options()
+    def row_height(self, row_height: float) -> typing.Self:    
+        """
+        Set the height of the rows
+        """
+            
+        if not row_height >= 0:
+            raise ValueError("row_height must be >= 0")
+        if not row_height <= 1:
+            raise ValueError("row_height must be <= 1")
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
         
-        assert isinstance(self.__internal.options, geomap.Options)
+        assert isinstance(self._internal.options, statushistory.Options)
         
-        self.__internal.options.view = view
+        self._internal.options.row_height = row_height
     
         return self
     
-    def controls(self, controls: geomap.ControlsOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = geomap.Options()
+    def show_value(self, show_value: common.VisibilityMode) -> typing.Self:    
+        """
+        Show values on the columns
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
         
-        assert isinstance(self.__internal.options, geomap.Options)
+        assert isinstance(self._internal.options, statushistory.Options)
         
-        self.__internal.options.controls = controls
+        self._internal.options.show_value = show_value
     
         return self
     
-    def basemap(self, basemap: cogbuilder.Builder[common.MapLayerOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = geomap.Options()
+    def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
         
-        assert isinstance(self.__internal.options, geomap.Options)
+        assert isinstance(self._internal.options, statushistory.Options)
         
-        basemap_resource = basemap.build()
-        self.__internal.options.basemap = basemap_resource
+        legend_resource = legend.build()
+        self._internal.options.legend = legend_resource
     
         return self
     
-    def layers(self, layers: list[cogbuilder.Builder[common.MapLayerOptions]]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = geomap.Options()
+    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
         
-        assert isinstance(self.__internal.options, geomap.Options)
+        assert isinstance(self._internal.options, statushistory.Options)
         
-        layers_resources = [r1.build() for r1 in layers]
-        self.__internal.options.layers = layers_resources
+        tooltip_resource = tooltip.build()
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
-    def tooltip(self, tooltip: geomap.TooltipOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = geomap.Options()
+    def timezone(self, timezone: list[common.TimeZone]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
+        
+        assert isinstance(self._internal.options, statushistory.Options)
+        
+        self._internal.options.timezone = timezone
+    
+        return self
+    
+    def col_width(self, col_width: float) -> typing.Self:    
+        """
+        Controls the column width
+        """
+            
+        if not col_width <= 1:
+            raise ValueError("col_width must be <= 1")
+        if self._internal.options is None:
+            self._internal.options = statushistory.Options()
+        
+        assert isinstance(self._internal.options, statushistory.Options)
+        
+        self._internal.options.col_width = col_width
+    
+        return self
+    
+    def line_width(self, line_width: int) -> typing.Self:        
+        if not line_width <= 10:
+            raise ValueError("line_width must be <= 10")
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statushistory.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults.custom, statushistory.FieldConfig)
+        
+        self._internal.field_config.defaults.custom.line_width = line_width
+    
+        return self
+    
+    def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statushistory.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults.custom, statushistory.FieldConfig)
+        
+        hide_from_resource = hide_from.build()
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
+    
+        return self
+    
+    def fill_opacity(self, fill_opacity: int) -> typing.Self:        
+        if not fill_opacity <= 100:
+            raise ValueError("fill_opacity must be <= 100")
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
+        
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
+        
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
+        
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
+        
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = statushistory.FieldConfig()
         
-        assert isinstance(self.__internal.options, geomap.Options)
+        assert isinstance(self._internal.field_config.defaults.custom, statushistory.FieldConfig)
         
-        self.__internal.options.tooltip = tooltip
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/googlecloudmonitoring.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/googlecloudmonitoring.py`

 * *Files 17% similar despite different names*

```diff
@@ -2,698 +2,787 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import googlecloudmonitoring
 
 
 class CloudMonitoringQuery(cogbuilder.Builder[googlecloudmonitoring.CloudMonitoringQuery]):    
-    __internal: googlecloudmonitoring.CloudMonitoringQuery
+    _internal: googlecloudmonitoring.CloudMonitoringQuery
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.CloudMonitoringQuery()
+        self._internal = googlecloudmonitoring.CloudMonitoringQuery()
 
     def build(self) -> googlecloudmonitoring.CloudMonitoringQuery:
-        return self.__internal    
+        return self._internal    
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def alias_by(self, alias_by: str) -> typing.Self:    
         """
         Aliases can be set to modify the legend labels. e.g. {{metric.label.xxx}}. See docs for more detail.
         """
             
-        self.__internal.alias_by = alias_by
+        self._internal.alias_by = alias_by
     
         return self
     
     def time_series_list(self, time_series_list: cogbuilder.Builder[googlecloudmonitoring.TimeSeriesList]) -> typing.Self:    
         """
         GCM query type.
         queryType: #QueryType
         Time Series List sub-query properties.
         """
             
         time_series_list_resource = time_series_list.build()
-        self.__internal.time_series_list = time_series_list_resource
+        self._internal.time_series_list = time_series_list_resource
     
         return self
     
     def time_series_query(self, time_series_query: cogbuilder.Builder[googlecloudmonitoring.TimeSeriesQuery]) -> typing.Self:    
         """
         Time Series sub-query properties.
         """
             
         time_series_query_resource = time_series_query.build()
-        self.__internal.time_series_query = time_series_query_resource
+        self._internal.time_series_query = time_series_query_resource
     
         return self
     
     def slo_query(self, slo_query: cogbuilder.Builder[googlecloudmonitoring.SLOQuery]) -> typing.Self:    
         """
         SLO sub-query properties.
         """
             
         slo_query_resource = slo_query.build()
-        self.__internal.slo_query = slo_query_resource
-    
-        return self
-    
-    def prom_ql_query(self, prom_ql_query: cogbuilder.Builder[googlecloudmonitoring.PromQLQuery]) -> typing.Self:    
-        """
-        PromQL sub-query properties.
-        """
-            
-        prom_ql_query_resource = prom_ql_query.build()
-        self.__internal.prom_ql_query = prom_ql_query_resource
+        self._internal.slo_query = slo_query_resource
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def interval_ms(self, interval_ms: float) -> typing.Self:    
         """
         Time interval in milliseconds.
         """
             
-        self.__internal.interval_ms = interval_ms
+        self._internal.interval_ms = interval_ms
     
         return self
     
 
 class TimeSeriesList(cogbuilder.Builder[googlecloudmonitoring.TimeSeriesList]):    
     """
     Time Series List sub-query properties.
     """
     
-    __internal: googlecloudmonitoring.TimeSeriesList
+    _internal: googlecloudmonitoring.TimeSeriesList
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.TimeSeriesList()
+        self._internal = googlecloudmonitoring.TimeSeriesList()
 
     def build(self) -> googlecloudmonitoring.TimeSeriesList:
-        return self.__internal    
+        return self._internal    
     
     def project_name(self, project_name: str) -> typing.Self:    
         """
         GCP project to execute the query against.
         """
             
-        self.__internal.project_name = project_name
+        self._internal.project_name = project_name
     
         return self
     
     def cross_series_reducer(self, cross_series_reducer: str) -> typing.Self:    
         """
         Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
         """
             
-        self.__internal.cross_series_reducer = cross_series_reducer
+        self._internal.cross_series_reducer = cross_series_reducer
     
         return self
     
     def alignment_period(self, alignment_period: str) -> typing.Self:    
         """
         Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
         """
             
-        self.__internal.alignment_period = alignment_period
+        self._internal.alignment_period = alignment_period
     
         return self
     
     def per_series_aligner(self, per_series_aligner: str) -> typing.Self:    
         """
         Alignment function to be used. Defaults to ALIGN_MEAN.
         """
             
-        self.__internal.per_series_aligner = per_series_aligner
+        self._internal.per_series_aligner = per_series_aligner
     
         return self
     
     def group_bys(self, group_bys: list[str]) -> typing.Self:    
         """
         Array of labels to group data by.
         """
             
-        self.__internal.group_bys = group_bys
+        self._internal.group_bys = group_bys
     
         return self
     
     def filters(self, filters: list[str]) -> typing.Self:    
         """
         Array of filters to query data by. Labels that can be filtered on are defined by the metric.
         """
             
-        self.__internal.filters = filters
+        self._internal.filters = filters
     
         return self
     
     def view(self, view: str) -> typing.Self:    
         """
         Data view, defaults to FULL.
         """
             
-        self.__internal.view = view
+        self._internal.view = view
+    
+        return self
+    
+    def secondary_cross_series_reducer(self, secondary_cross_series_reducer: str) -> typing.Self:    
+        """
+        Only present if a preprocessor is selected. Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
+        """
+            
+        self._internal.secondary_cross_series_reducer = secondary_cross_series_reducer
+    
+        return self
+    
+    def secondary_alignment_period(self, secondary_alignment_period: str) -> typing.Self:    
+        """
+        Only present if a preprocessor is selected. Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
+        """
+            
+        self._internal.secondary_alignment_period = secondary_alignment_period
+    
+        return self
+    
+    def secondary_per_series_aligner(self, secondary_per_series_aligner: str) -> typing.Self:    
+        """
+        Only present if a preprocessor is selected. Alignment function to be used. Defaults to ALIGN_MEAN.
+        """
+            
+        self._internal.secondary_per_series_aligner = secondary_per_series_aligner
+    
+        return self
+    
+    def secondary_group_bys(self, secondary_group_bys: list[str]) -> typing.Self:    
+        """
+        Only present if a preprocessor is selected. Array of labels to group data by.
+        """
+            
+        self._internal.secondary_group_bys = secondary_group_bys
+    
+        return self
+    
+    def preprocessor(self, preprocessor: googlecloudmonitoring.PreprocessorType) -> typing.Self:    
+        """
+        Preprocessor is not part of the API, but is used to store the preprocessor and not affect the UI for the rest of parameters
+        """
+            
+        self._internal.preprocessor = preprocessor
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Annotation title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def text(self, text: str) -> typing.Self:    
         """
         Annotation text.
         """
             
-        self.__internal.text = text
+        self._internal.text = text
+    
+        return self
+    
+
+class AnnotationQuery(cogbuilder.Builder[googlecloudmonitoring.AnnotationQuery]):    
+    """
+    Annotation sub-query properties.
+    """
+    
+    _internal: googlecloudmonitoring.AnnotationQuery
+
+    def __init__(self):
+        self._internal = googlecloudmonitoring.AnnotationQuery()
+
+    def build(self) -> googlecloudmonitoring.AnnotationQuery:
+        return self._internal    
+    
+    def project_name(self, project_name: str) -> typing.Self:    
+        """
+        GCP project to execute the query against.
+        """
+            
+        self._internal.project_name = project_name
+    
+        return self
+    
+    def cross_series_reducer(self, cross_series_reducer: str) -> typing.Self:    
+        """
+        Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
+        """
+            
+        self._internal.cross_series_reducer = cross_series_reducer
+    
+        return self
+    
+    def alignment_period(self, alignment_period: str) -> typing.Self:    
+        """
+        Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
+        """
+            
+        self._internal.alignment_period = alignment_period
+    
+        return self
+    
+    def per_series_aligner(self, per_series_aligner: str) -> typing.Self:    
+        """
+        Alignment function to be used. Defaults to ALIGN_MEAN.
+        """
+            
+        self._internal.per_series_aligner = per_series_aligner
+    
+        return self
+    
+    def group_bys(self, group_bys: list[str]) -> typing.Self:    
+        """
+        Array of labels to group data by.
+        """
+            
+        self._internal.group_bys = group_bys
+    
+        return self
+    
+    def filters(self, filters: list[str]) -> typing.Self:    
+        """
+        Array of filters to query data by. Labels that can be filtered on are defined by the metric.
+        """
+            
+        self._internal.filters = filters
+    
+        return self
+    
+    def view(self, view: str) -> typing.Self:    
+        """
+        Data view, defaults to FULL.
+        """
+            
+        self._internal.view = view
     
         return self
     
     def secondary_cross_series_reducer(self, secondary_cross_series_reducer: str) -> typing.Self:    
         """
         Only present if a preprocessor is selected. Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
         """
             
-        self.__internal.secondary_cross_series_reducer = secondary_cross_series_reducer
+        self._internal.secondary_cross_series_reducer = secondary_cross_series_reducer
     
         return self
     
     def secondary_alignment_period(self, secondary_alignment_period: str) -> typing.Self:    
         """
         Only present if a preprocessor is selected. Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
         """
             
-        self.__internal.secondary_alignment_period = secondary_alignment_period
+        self._internal.secondary_alignment_period = secondary_alignment_period
     
         return self
     
     def secondary_per_series_aligner(self, secondary_per_series_aligner: str) -> typing.Self:    
         """
         Only present if a preprocessor is selected. Alignment function to be used. Defaults to ALIGN_MEAN.
         """
             
-        self.__internal.secondary_per_series_aligner = secondary_per_series_aligner
+        self._internal.secondary_per_series_aligner = secondary_per_series_aligner
     
         return self
     
     def secondary_group_bys(self, secondary_group_bys: list[str]) -> typing.Self:    
         """
         Only present if a preprocessor is selected. Array of labels to group data by.
         """
             
-        self.__internal.secondary_group_bys = secondary_group_bys
+        self._internal.secondary_group_bys = secondary_group_bys
+    
+        return self
+    
+    def title(self, title: str) -> typing.Self:    
+        """
+        Annotation title.
+        """
+            
+        self._internal.title = title
     
         return self
     
     def preprocessor(self, preprocessor: googlecloudmonitoring.PreprocessorType) -> typing.Self:    
         """
         Preprocessor is not part of the API, but is used to store the preprocessor and not affect the UI for the rest of parameters
         """
             
-        self.__internal.preprocessor = preprocessor
+        self._internal.preprocessor = preprocessor
+    
+        return self
+    
+    def text(self, text: str) -> typing.Self:    
+        """
+        Annotation text.
+        """
+            
+        self._internal.text = text
     
         return self
     
 
 class TimeSeriesQuery(cogbuilder.Builder[googlecloudmonitoring.TimeSeriesQuery]):    
     """
     Time Series sub-query properties.
     """
     
-    __internal: googlecloudmonitoring.TimeSeriesQuery
+    _internal: googlecloudmonitoring.TimeSeriesQuery
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.TimeSeriesQuery()
+        self._internal = googlecloudmonitoring.TimeSeriesQuery()
 
     def build(self) -> googlecloudmonitoring.TimeSeriesQuery:
-        return self.__internal    
+        return self._internal    
     
     def project_name(self, project_name: str) -> typing.Self:    
         """
         GCP project to execute the query against.
         """
             
-        self.__internal.project_name = project_name
+        self._internal.project_name = project_name
     
         return self
     
     def query(self, query: str) -> typing.Self:    
         """
         MQL query to be executed.
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def graph_period(self, graph_period: typing.Union[typing.Literal["disabled"]]) -> typing.Self:    
         """
         To disable the graphPeriod, it should explictly be set to 'disabled'.
         """
             
-        self.__internal.graph_period = graph_period
+        self._internal.graph_period = graph_period
     
         return self
     
 
 class SLOQuery(cogbuilder.Builder[googlecloudmonitoring.SLOQuery]):    
     """
     SLO sub-query properties.
     """
     
-    __internal: googlecloudmonitoring.SLOQuery
+    _internal: googlecloudmonitoring.SLOQuery
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.SLOQuery()
+        self._internal = googlecloudmonitoring.SLOQuery()
 
     def build(self) -> googlecloudmonitoring.SLOQuery:
-        return self.__internal    
+        return self._internal    
     
     def project_name(self, project_name: str) -> typing.Self:    
         """
         GCP project to execute the query against.
         """
             
-        self.__internal.project_name = project_name
+        self._internal.project_name = project_name
     
         return self
     
     def per_series_aligner(self, per_series_aligner: str) -> typing.Self:    
         """
         Alignment function to be used. Defaults to ALIGN_MEAN.
         """
             
-        self.__internal.per_series_aligner = per_series_aligner
+        self._internal.per_series_aligner = per_series_aligner
     
         return self
     
     def alignment_period(self, alignment_period: str) -> typing.Self:    
         """
         Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
         """
             
-        self.__internal.alignment_period = alignment_period
+        self._internal.alignment_period = alignment_period
     
         return self
     
     def selector_name(self, selector_name: str) -> typing.Self:    
         """
         SLO selector.
         """
             
-        self.__internal.selector_name = selector_name
+        self._internal.selector_name = selector_name
     
         return self
     
     def service_id(self, service_id: str) -> typing.Self:    
         """
         ID for the service the SLO is in.
         """
             
-        self.__internal.service_id = service_id
+        self._internal.service_id = service_id
     
         return self
     
     def service_name(self, service_name: str) -> typing.Self:    
         """
         Name for the service the SLO is in.
         """
             
-        self.__internal.service_name = service_name
+        self._internal.service_name = service_name
     
         return self
     
     def slo_id(self, slo_id: str) -> typing.Self:    
         """
         ID for the SLO.
         """
             
-        self.__internal.slo_id = slo_id
+        self._internal.slo_id = slo_id
     
         return self
     
     def slo_name(self, slo_name: str) -> typing.Self:    
         """
         Name of the SLO.
         """
             
-        self.__internal.slo_name = slo_name
+        self._internal.slo_name = slo_name
     
         return self
     
     def goal(self, goal: float) -> typing.Self:    
         """
         SLO goal value.
         """
             
-        self.__internal.goal = goal
+        self._internal.goal = goal
     
         return self
     
     def lookback_period(self, lookback_period: str) -> typing.Self:    
         """
         Specific lookback period for the SLO.
         """
             
-        self.__internal.lookback_period = lookback_period
-    
-        return self
-    
-
-class PromQLQuery(cogbuilder.Builder[googlecloudmonitoring.PromQLQuery]):    
-    """
-    PromQL sub-query properties.
-    """
-    
-    __internal: googlecloudmonitoring.PromQLQuery
-
-    def __init__(self):
-        self.__internal = googlecloudmonitoring.PromQLQuery()
-
-    def build(self) -> googlecloudmonitoring.PromQLQuery:
-        return self.__internal    
-    
-    def project_name(self, project_name: str) -> typing.Self:    
-        """
-        GCP project to execute the query against.
-        """
-            
-        self.__internal.project_name = project_name
-    
-        return self
-    
-    def expr(self, expr: str) -> typing.Self:    
-        """
-        PromQL expression/query to be executed.
-        """
-            
-        self.__internal.expr = expr
-    
-        return self
-    
-    def step(self, step: str) -> typing.Self:    
-        """
-        PromQL min step
-        """
-            
-        self.__internal.step = step
+        self._internal.lookback_period = lookback_period
     
         return self
     
 
 class MetricQuery(cogbuilder.Builder[googlecloudmonitoring.MetricQuery]):    
     """
     @deprecated This type is for migration purposes only. Replaced by TimeSeriesList Metric sub-query properties.
     """
     
-    __internal: googlecloudmonitoring.MetricQuery
+    _internal: googlecloudmonitoring.MetricQuery
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.MetricQuery()
+        self._internal = googlecloudmonitoring.MetricQuery()
 
     def build(self) -> googlecloudmonitoring.MetricQuery:
-        return self.__internal    
+        return self._internal    
     
     def project_name(self, project_name: str) -> typing.Self:    
         """
         GCP project to execute the query against.
         """
             
-        self.__internal.project_name = project_name
+        self._internal.project_name = project_name
     
         return self
     
     def per_series_aligner(self, per_series_aligner: str) -> typing.Self:    
         """
         Alignment function to be used. Defaults to ALIGN_MEAN.
         """
             
-        self.__internal.per_series_aligner = per_series_aligner
+        self._internal.per_series_aligner = per_series_aligner
     
         return self
     
     def alignment_period(self, alignment_period: str) -> typing.Self:    
         """
         Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
         """
             
-        self.__internal.alignment_period = alignment_period
+        self._internal.alignment_period = alignment_period
     
         return self
     
     def alias_by(self, alias_by: str) -> typing.Self:    
         """
         Aliases can be set to modify the legend labels. e.g. {{metric.label.xxx}}. See docs for more detail.
         """
             
-        self.__internal.alias_by = alias_by
+        self._internal.alias_by = alias_by
     
         return self
     
     def editor_mode(self, editor_mode: str) -> typing.Self:        
-        self.__internal.editor_mode = editor_mode
+        self._internal.editor_mode = editor_mode
     
         return self
     
     def metric_type(self, metric_type: str) -> typing.Self:        
-        self.__internal.metric_type = metric_type
+        self._internal.metric_type = metric_type
     
         return self
     
     def cross_series_reducer(self, cross_series_reducer: str) -> typing.Self:    
         """
         Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
         """
             
-        self.__internal.cross_series_reducer = cross_series_reducer
+        self._internal.cross_series_reducer = cross_series_reducer
     
         return self
     
     def group_bys(self, group_bys: list[str]) -> typing.Self:    
         """
         Array of labels to group data by.
         """
             
-        self.__internal.group_bys = group_bys
+        self._internal.group_bys = group_bys
     
         return self
     
     def filters(self, filters: list[str]) -> typing.Self:    
         """
         Array of filters to query data by. Labels that can be filtered on are defined by the metric.
         """
             
-        self.__internal.filters = filters
+        self._internal.filters = filters
     
         return self
     
     def metric_kind(self, metric_kind: googlecloudmonitoring.MetricKind) -> typing.Self:        
-        self.__internal.metric_kind = metric_kind
+        self._internal.metric_kind = metric_kind
     
         return self
     
     def value_type(self, value_type: str) -> typing.Self:        
-        self.__internal.value_type = value_type
+        self._internal.value_type = value_type
     
         return self
     
     def view(self, view: str) -> typing.Self:        
-        self.__internal.view = view
+        self._internal.view = view
     
         return self
     
     def query(self, query: str) -> typing.Self:    
         """
         MQL query to be executed.
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def preprocessor(self, preprocessor: googlecloudmonitoring.PreprocessorType) -> typing.Self:    
         """
         Preprocessor is not part of the API, but is used to store the preprocessor and not affect the UI for the rest of parameters
         """
             
-        self.__internal.preprocessor = preprocessor
+        self._internal.preprocessor = preprocessor
     
         return self
     
     def graph_period(self, graph_period: typing.Union[typing.Literal["disabled"]]) -> typing.Self:    
         """
         To disable the graphPeriod, it should explictly be set to 'disabled'.
         """
             
-        self.__internal.graph_period = graph_period
+        self._internal.graph_period = graph_period
     
         return self
     
 
 class LegacyCloudMonitoringAnnotationQuery(cogbuilder.Builder[googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery]):    
     """
-    @deprecated Use TimeSeriesList instead. Legacy annotation query properties for migration purposes.
+    @deprecated Use AnnotationQuery instead. Legacy annotation query properties for migration purposes.
     """
     
-    __internal: googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery
+    _internal: googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery()
+        self._internal = googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery()
 
     def build(self) -> googlecloudmonitoring.LegacyCloudMonitoringAnnotationQuery:
-        return self.__internal    
+        return self._internal    
     
     def project_name(self, project_name: str) -> typing.Self:    
         """
         GCP project to execute the query against.
         """
             
-        self.__internal.project_name = project_name
+        self._internal.project_name = project_name
     
         return self
     
     def metric_type(self, metric_type: str) -> typing.Self:        
-        self.__internal.metric_type = metric_type
+        self._internal.metric_type = metric_type
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         Query refId.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def filters(self, filters: list[str]) -> typing.Self:    
         """
         Array of filters to query data by. Labels that can be filtered on are defined by the metric.
         """
             
-        self.__internal.filters = filters
+        self._internal.filters = filters
     
         return self
     
     def metric_kind(self, metric_kind: googlecloudmonitoring.MetricKind) -> typing.Self:        
-        self.__internal.metric_kind = metric_kind
+        self._internal.metric_kind = metric_kind
     
         return self
     
     def value_type(self, value_type: str) -> typing.Self:        
-        self.__internal.value_type = value_type
+        self._internal.value_type = value_type
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Annotation title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def text(self, text: str) -> typing.Self:    
         """
         Annotation text.
         """
             
-        self.__internal.text = text
+        self._internal.text = text
     
         return self
     
 
 class Filter(cogbuilder.Builder[googlecloudmonitoring.Filter]):    
     """
     Query filter representation.
     """
     
-    __internal: googlecloudmonitoring.Filter
+    _internal: googlecloudmonitoring.Filter
 
     def __init__(self):
-        self.__internal = googlecloudmonitoring.Filter()
+        self._internal = googlecloudmonitoring.Filter()
 
     def build(self) -> googlecloudmonitoring.Filter:
-        return self.__internal    
+        return self._internal    
     
     def key(self, key: str) -> typing.Self:    
         """
         Filter key.
         """
             
-        self.__internal.key = key
+        self._internal.key = key
     
         return self
     
     def operator(self, operator: str) -> typing.Self:    
         """
         Filter operator.
         """
             
-        self.__internal.operator = operator
+        self._internal.operator = operator
     
         return self
     
     def value(self, value: str) -> typing.Self:    
         """
         Filter value.
         """
             
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
     def condition(self, condition: str) -> typing.Self:    
         """
         Filter condition.
         """
             
-        self.__internal.condition = condition
+        self._internal.condition = condition
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/grafanapyroscope.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/grafanapyroscope.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,60 +2,55 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import grafanapyroscope
 
 
 class Dataquery(cogbuilder.Builder[grafanapyroscope.Dataquery]):    
-    __internal: grafanapyroscope.Dataquery
+    _internal: grafanapyroscope.Dataquery
 
     def __init__(self):
-        self.__internal = grafanapyroscope.Dataquery()
+        self._internal = grafanapyroscope.Dataquery()
 
     def build(self) -> grafanapyroscope.Dataquery:
-        return self.__internal    
+        return self._internal    
     
     def label_selector(self, label_selector: str) -> typing.Self:        
-        self.__internal.label_selector = label_selector
-    
-        return self
-    
-    def span_selector(self, span_selector: list[str]) -> typing.Self:        
-        self.__internal.span_selector = span_selector
+        self._internal.label_selector = label_selector
     
         return self
     
     def profile_type_id(self, profile_type_id: str) -> typing.Self:        
-        self.__internal.profile_type_id = profile_type_id
+        self._internal.profile_type_id = profile_type_id
     
         return self
     
     def group_by(self, group_by: list[str]) -> typing.Self:        
-        self.__internal.group_by = group_by
+        self._internal.group_by = group_by
     
         return self
     
     def max_nodes(self, max_nodes: int) -> typing.Self:        
-        self.__internal.max_nodes = max_nodes
+        self._internal.max_nodes = max_nodes
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:        
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:        
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:        
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/heatmap.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/heatmap.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "heatmap"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "heatmap"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,392 +244,392 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def calculate(self, calculate: bool) -> typing.Self:    
         """
         Controls if the heatmap should be calculated from data
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.calculate = calculate
+        self._internal.options.calculate = calculate
     
         return self
     
     def calculation(self, calculation: cogbuilder.Builder[common.HeatmapCalculationOptions]) -> typing.Self:    
         """
         Calculation options for the heatmap
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
         calculation_resource = calculation.build()
-        self.__internal.options.calculation = calculation_resource
+        self._internal.options.calculation = calculation_resource
     
         return self
     
     def color(self, color: heatmap.HeatmapColorOptions) -> typing.Self:    
         """
         Controls the color options
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.color = color
+        self._internal.options.color = color
     
         return self
     
     def filter_values(self, filter_values: heatmap.FilterValueRange) -> typing.Self:    
         """
         Filters values between a given range
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.filter_values = filter_values
+        self._internal.options.filter_values = filter_values
     
         return self
     
     def rows_frame(self, rows_frame: heatmap.RowsHeatmapOptions) -> typing.Self:    
         """
         Controls tick alignment and value name when not calculating from data
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.rows_frame = rows_frame
+        self._internal.options.rows_frame = rows_frame
     
         return self
     
     def show_value(self, show_value: common.VisibilityMode) -> typing.Self:    
         """
         | *{
         	layout: ui.HeatmapCellLayout & "auto" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed
         }
         Controls the display of the value in the cell
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.show_value = show_value
+        self._internal.options.show_value = show_value
     
         return self
     
     def cell_gap(self, cell_gap: int) -> typing.Self:    
         """
         Controls gap between cells
         """
             
         if not cell_gap <= 25:
             raise ValueError("cell_gap must be <= 25")
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.cell_gap = cell_gap
+        self._internal.options.cell_gap = cell_gap
     
         return self
     
     def cell_radius(self, cell_radius: float) -> typing.Self:    
         """
         Controls cell radius
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.cell_radius = cell_radius
+        self._internal.options.cell_radius = cell_radius
     
         return self
     
     def cell_values(self, cell_values: heatmap.CellValues) -> typing.Self:    
         """
         Controls cell value unit
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.cell_values = cell_values
+        self._internal.options.cell_values = cell_values
     
         return self
     
     def y_axis(self, y_axis: heatmap.YAxisConfig) -> typing.Self:    
         """
         Controls yAxis placement
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.y_axis = y_axis
+        self._internal.options.y_axis = y_axis
     
         return self
     
     def legend(self, legend: heatmap.HeatmapLegend) -> typing.Self:    
         """
         | *{
         	axisPlacement: ui.AxisPlacement & "left" // TODO: fix after remove when https://github.com/grafana/cuetsy/issues/74 is fixed
         }
         Controls legend options
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.legend = legend
+        self._internal.options.legend = legend
     
         return self
     
     def tooltip(self, tooltip: heatmap.HeatmapTooltip) -> typing.Self:    
         """
         Controls tooltip options
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.tooltip = tooltip
+        self._internal.options.tooltip = tooltip
     
         return self
     
     def exemplars_color(self, exemplars: heatmap.ExemplarConfig) -> typing.Self:    
         """
         Controls exemplar options
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = heatmap.Options()
+        if self._internal.options is None:
+            self._internal.options = heatmap.Options()
         
-        assert isinstance(self.__internal.options, heatmap.Options)
+        assert isinstance(self._internal.options, heatmap.Options)
         
-        self.__internal.options.exemplars = exemplars
+        self._internal.options.exemplars = exemplars
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = heatmap.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = heatmap.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, heatmap.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, heatmap.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = heatmap.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = heatmap.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, heatmap.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, heatmap.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/histogram.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/histogram.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "histogram"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "histogram"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,538 +244,502 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def bucket_count(self, bucket_count: int) -> typing.Self:    
-        """
-        Bucket count (approx)
-        """
-            
-        if not bucket_count > 0:
-            raise ValueError("bucket_count must be > 0")
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
-        
-        assert isinstance(self.__internal.options, histogram.Options)
-        
-        self.__internal.options.bucket_count = bucket_count
-    
-        return self
-    
     def bucket_size(self, bucket_size: int) -> typing.Self:    
         """
         Size of each bucket
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
+        if self._internal.options is None:
+            self._internal.options = histogram.Options()
         
-        assert isinstance(self.__internal.options, histogram.Options)
+        assert isinstance(self._internal.options, histogram.Options)
         
-        self.__internal.options.bucket_size = bucket_size
+        self._internal.options.bucket_size = bucket_size
     
         return self
     
-    def bucket_offset(self, bucket_offset: float) -> typing.Self:    
+    def bucket_offset(self, bucket_offset: int) -> typing.Self:    
         """
         Offset buckets by this amount
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
+        if self._internal.options is None:
+            self._internal.options = histogram.Options()
         
-        assert isinstance(self.__internal.options, histogram.Options)
+        assert isinstance(self._internal.options, histogram.Options)
         
-        self.__internal.options.bucket_offset = bucket_offset
+        self._internal.options.bucket_offset = bucket_offset
     
         return self
     
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
+        if self._internal.options is None:
+            self._internal.options = histogram.Options()
         
-        assert isinstance(self.__internal.options, histogram.Options)
+        assert isinstance(self._internal.options, histogram.Options)
         
         legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.legend = legend_resource
     
         return self
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
+        if self._internal.options is None:
+            self._internal.options = histogram.Options()
         
-        assert isinstance(self.__internal.options, histogram.Options)
+        assert isinstance(self._internal.options, histogram.Options)
         
         tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
     def combine(self, combine: bool) -> typing.Self:    
         """
         Combines multiple series into a single histogram
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = histogram.Options()
+        if self._internal.options is None:
+            self._internal.options = histogram.Options()
         
-        assert isinstance(self.__internal.options, histogram.Options)
+        assert isinstance(self._internal.options, histogram.Options)
         
-        self.__internal.options.combine = combine
+        self._internal.options.combine = combine
     
         return self
     
     def line_width(self, line_width: int) -> typing.Self:    
         """
         Controls line width of the bars.
         """
             
         if not line_width <= 10:
             raise ValueError("line_width must be <= 10")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def fill_opacity(self, fill_opacity: int) -> typing.Self:    
         """
         Controls the fill opacity of the bars.
         """
             
         if not fill_opacity <= 100:
             raise ValueError("fill_opacity must be <= 100")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:    
         """
         Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.
         Gradient appearance is influenced by the Fill opacity setting.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.gradient_mode = gradient_mode
+        self._internal.field_config.defaults.custom.gradient_mode = gradient_mode
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = histogram.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = histogram.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, histogram.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, histogram.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/librarypanel.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/librarypanel.py`

 * *Files 10% similar despite different names*

```diff
@@ -4,326 +4,334 @@
 from ..cog import builder as cogbuilder
 from ..models import librarypanel
 from ..cog import variants as cogvariants
 from ..models import dashboard
 
 
 class LibraryPanel(cogbuilder.Builder[librarypanel.LibraryPanel]):    
-    __internal: librarypanel.LibraryPanel
+    _internal: librarypanel.LibraryPanel
 
     def __init__(self):
-        self.__internal = librarypanel.LibraryPanel()
+        self._internal = librarypanel.LibraryPanel()
 
     def build(self) -> librarypanel.LibraryPanel:
-        return self.__internal    
+        return self._internal    
     
     def folder_uid(self, folder_uid: str) -> typing.Self:    
         """
         Folder UID
         """
             
-        self.__internal.folder_uid = folder_uid
+        self._internal.folder_uid = folder_uid
     
         return self
     
     def uid(self, uid: str) -> typing.Self:    
         """
         Library element UID
         """
             
-        self.__internal.uid = uid
+        self._internal.uid = uid
     
         return self
     
     def name(self, name: str) -> typing.Self:    
         """
         Panel name (also saved in the model)
         """
             
         if not len(name) >= 1:
             raise ValueError("len(name) must be >= 1")
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         The panel type (from inside the model)
         """
             
         if not len(type_val) >= 1:
             raise ValueError("len(type_val) must be >= 1")
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def schema_version(self, schema_version: int) -> typing.Self:    
         """
         Dashboard version when this was saved (zero if unknown)
         """
             
-        self.__internal.schema_version = schema_version
+        self._internal.schema_version = schema_version
     
         return self
     
     def version(self, version: int) -> typing.Self:    
         """
         panel version, incremented each time the dashboard is updated.
         """
             
-        self.__internal.version = version
+        self._internal.version = version
     
         return self
     
     def model(self, model: cogbuilder.Builder[librarypanel.LibrarypanelLibraryPanelModel]) -> typing.Self:    
         """
         TODO: should be the same panel schema defined in dashboard
         Typescript: Omit<Panel, 'gridPos' | 'id' | 'libraryPanel'>;
         """
             
         model_resource = model.build()
-        self.__internal.model = model_resource
+        self._internal.model = model_resource
     
         return self
     
     def meta(self, meta: cogbuilder.Builder[librarypanel.LibraryElementDTOMeta]) -> typing.Self:    
         """
         Object storage metadata
         """
             
         meta_resource = meta.build()
-        self.__internal.meta = meta_resource
+        self._internal.meta = meta_resource
     
         return self
     
 
 class LibraryElementDTOMetaUser(cogbuilder.Builder[librarypanel.LibraryElementDTOMetaUser]):    
-    __internal: librarypanel.LibraryElementDTOMetaUser
+    _internal: librarypanel.LibraryElementDTOMetaUser
 
     def __init__(self):
-        self.__internal = librarypanel.LibraryElementDTOMetaUser()
+        self._internal = librarypanel.LibraryElementDTOMetaUser()
 
     def build(self) -> librarypanel.LibraryElementDTOMetaUser:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def avatar_url(self, avatar_url: str) -> typing.Self:        
-        self.__internal.avatar_url = avatar_url
+        self._internal.avatar_url = avatar_url
     
         return self
     
 
 class LibraryElementDTOMeta(cogbuilder.Builder[librarypanel.LibraryElementDTOMeta]):    
-    __internal: librarypanel.LibraryElementDTOMeta
+    _internal: librarypanel.LibraryElementDTOMeta
 
     def __init__(self):
-        self.__internal = librarypanel.LibraryElementDTOMeta()
+        self._internal = librarypanel.LibraryElementDTOMeta()
 
     def build(self) -> librarypanel.LibraryElementDTOMeta:
-        return self.__internal    
+        return self._internal    
     
     def folder_name(self, folder_name: str) -> typing.Self:        
-        self.__internal.folder_name = folder_name
+        self._internal.folder_name = folder_name
     
         return self
     
     def folder_uid(self, folder_uid: str) -> typing.Self:        
-        self.__internal.folder_uid = folder_uid
+        self._internal.folder_uid = folder_uid
     
         return self
     
     def connected_dashboards(self, connected_dashboards: int) -> typing.Self:        
-        self.__internal.connected_dashboards = connected_dashboards
+        self._internal.connected_dashboards = connected_dashboards
     
         return self
     
     def created(self, created: str) -> typing.Self:        
-        self.__internal.created = created
+        self._internal.created = created
     
         return self
     
     def updated(self, updated: str) -> typing.Self:        
-        self.__internal.updated = updated
+        self._internal.updated = updated
     
         return self
     
     def created_by(self, created_by: cogbuilder.Builder[librarypanel.LibraryElementDTOMetaUser]) -> typing.Self:        
         created_by_resource = created_by.build()
-        self.__internal.created_by = created_by_resource
+        self._internal.created_by = created_by_resource
     
         return self
     
     def updated_by(self, updated_by: cogbuilder.Builder[librarypanel.LibraryElementDTOMetaUser]) -> typing.Self:        
         updated_by_resource = updated_by.build()
-        self.__internal.updated_by = updated_by_resource
+        self._internal.updated_by = updated_by_resource
     
         return self
     
 
 class LibrarypanelLibraryPanelModel(cogbuilder.Builder[librarypanel.LibrarypanelLibraryPanelModel]):    
-    __internal: librarypanel.LibrarypanelLibraryPanelModel
+    _internal: librarypanel.LibrarypanelLibraryPanelModel
 
     def __init__(self):
-        self.__internal = librarypanel.LibrarypanelLibraryPanelModel()
+        self._internal = librarypanel.LibrarypanelLibraryPanelModel()
 
     def build(self) -> librarypanel.LibrarypanelLibraryPanelModel:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: str) -> typing.Self:    
         """
         The panel plugin type id. This is used to find the plugin to display the panel.
         """
             
         if not len(type_val) >= 1:
             raise ValueError("len(type_val) must be >= 1")
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def plugin_version(self, plugin_version: str) -> typing.Self:    
         """
         The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.
         """
             
-        self.__internal.plugin_version = plugin_version
+        self._internal.plugin_version = plugin_version
+    
+        return self
+    
+    def tags(self, tags: list[str]) -> typing.Self:    
+        """
+        Tags for the panel.
+        """
+            
+        self._internal.tags = tags
     
         return self
     
     def targets(self, targets: list[cogbuilder.Builder[cogvariants.Dataquery]]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
         targets_resources = [r1.build() for r1 in targets]
-        self.__internal.targets = targets_resources
+        self._internal.targets = targets_resources
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
+    def repeat_panel_id(self, repeat_panel_id: int) -> typing.Self:    
         """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
+        Id of the repeating panel.
         """
             
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_panel_id = repeat_panel_id
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def transformations(self, transformations: list[dashboard.DataTransformerConfig]) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        self.__internal.transformations = transformations
+        self._internal.transformations = transformations
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -331,68 +339,41 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.time_shift = time_shift
     
         return self
     
     def options(self, options: object) -> typing.Self:    
         """
         It depends on the panel plugin. They are specified by the Options field in panel plugin schemas.
         """
             
-        self.__internal.options = options
+        self._internal.options = options
     
         return self
     
     def field_config(self, field_config: dashboard.FieldConfigSource) -> typing.Self:    
         """
         Field options allow you to change how the data is displayed in your visualizations.
         """
             
-        self.__internal.field_config = field_config
+        self._internal.field_config = field_config
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/logs.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/table.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import logs
+from ..models import table
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "logs"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "table"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,249 +244,245 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def show_labels(self, show_labels: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
-        
-        assert isinstance(self.__internal.options, logs.Options)
-        
-        self.__internal.options.show_labels = show_labels
-    
-        return self
-    
-    def show_common_labels(self, show_common_labels: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
-        
-        assert isinstance(self.__internal.options, logs.Options)
-        
-        self.__internal.options.show_common_labels = show_common_labels
-    
-        return self
-    
-    def show_time(self, show_time: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
-        
-        assert isinstance(self.__internal.options, logs.Options)
-        
-        self.__internal.options.show_time = show_time
-    
-        return self
-    
-    def show_log_context_toggle(self, show_log_context_toggle: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def frame_index(self, frame_index: float) -> typing.Self:    
+        """
+        Represents the index of the selected frame
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.show_log_context_toggle = show_log_context_toggle
+        self._internal.options.frame_index = frame_index
     
         return self
     
-    def wrap_log_message(self, wrap_log_message: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def show_header(self, show_header: bool) -> typing.Self:    
+        """
+        Controls whether the panel should show the header
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.wrap_log_message = wrap_log_message
+        self._internal.options.show_header = show_header
     
         return self
     
-    def prettify_log_message(self, prettify_log_message: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def show_type_icons(self, show_type_icons: bool) -> typing.Self:    
+        """
+        Controls whether the header should show icons for the column types
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.prettify_log_message = prettify_log_message
+        self._internal.options.show_type_icons = show_type_icons
     
         return self
     
-    def enable_log_details(self, enable_log_details: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def sort_by(self, sort_by: list[cogbuilder.Builder[common.TableSortByFieldState]]) -> typing.Self:    
+        """
+        Used to control row sorting
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.enable_log_details = enable_log_details
+        sort_by_resources = [r1.build() for r1 in sort_by]
+        self._internal.options.sort_by = sort_by_resources
     
         return self
     
-    def sort_order(self, sort_order: common.LogsSortOrder) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def footer(self, footer: cogbuilder.Builder[common.TableFooterOptions]) -> typing.Self:    
+        """
+        Controls footer options
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.sort_order = sort_order
+        footer_resource = footer.build()
+        self._internal.options.footer = footer_resource
     
         return self
     
-    def dedup_strategy(self, dedup_strategy: common.LogsDedupStrategy) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = logs.Options()
+    def cell_height(self, cell_height: common.TableCellHeight) -> typing.Self:    
+        """
+        Controls the height of the rows
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = table.Options()
         
-        assert isinstance(self.__internal.options, logs.Options)
+        assert isinstance(self._internal.options, table.Options)
         
-        self.__internal.options.dedup_strategy = dedup_strategy
+        self._internal.options.cell_height = cell_height
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/loki.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/loki.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,75 +2,75 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import loki
 
 
 class Dataquery(cogbuilder.Builder[loki.Dataquery]):    
-    __internal: loki.Dataquery
+    _internal: loki.Dataquery
 
     def __init__(self):
-        self.__internal = loki.Dataquery()
+        self._internal = loki.Dataquery()
 
     def build(self) -> loki.Dataquery:
-        return self.__internal    
+        return self._internal    
     
     def expr(self, expr: str) -> typing.Self:        
-        self.__internal.expr = expr
+        self._internal.expr = expr
     
         return self
     
     def legend_format(self, legend_format: str) -> typing.Self:        
-        self.__internal.legend_format = legend_format
+        self._internal.legend_format = legend_format
     
         return self
     
     def max_lines(self, max_lines: int) -> typing.Self:        
-        self.__internal.max_lines = max_lines
+        self._internal.max_lines = max_lines
     
         return self
     
     def resolution(self, resolution: int) -> typing.Self:        
-        self.__internal.resolution = resolution
+        self._internal.resolution = resolution
     
         return self
     
     def editor_mode(self, editor_mode: loki.QueryEditorMode) -> typing.Self:        
-        self.__internal.editor_mode = editor_mode
+        self._internal.editor_mode = editor_mode
     
         return self
     
     def range_val(self, range_val: bool) -> typing.Self:        
-        self.__internal.range_val = range_val
+        self._internal.range_val = range_val
     
         return self
     
     def instant(self, instant: bool) -> typing.Self:        
-        self.__internal.instant = instant
+        self._internal.instant = instant
     
         return self
     
     def step(self, step: str) -> typing.Self:        
-        self.__internal.step = step
+        self._internal.step = step
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:        
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:        
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:        
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/news.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/debug.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,193 +1,183 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import news
+from ..models import debug
 from ..cog import variants as cogvariants
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "news"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "debug"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,183 +243,179 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def feed_url(self, feed_url: str) -> typing.Self:    
-        """
-        empty/missing will default to grafana blog
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = news.Options()
+    def mode(self, mode: debug.DebugMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = debug.Options()
         
-        assert isinstance(self.__internal.options, news.Options)
+        assert isinstance(self._internal.options, debug.Options)
         
-        self.__internal.options.feed_url = feed_url
+        self._internal.options.mode = mode
     
         return self
     
-    def show_image(self, show_image: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = news.Options()
+    def counters(self, counters: debug.UpdateConfig) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = debug.Options()
         
-        assert isinstance(self.__internal.options, news.Options)
+        assert isinstance(self._internal.options, debug.Options)
         
-        self.__internal.options.show_image = show_image
+        self._internal.options.counters = counters
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/nodegraph.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/nodegraph.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,186 +8,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "nodeGraph"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "nodeGraph"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,179 +243,179 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def nodes(self, nodes: nodegraph.NodeOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = nodegraph.Options()
+        if self._internal.options is None:
+            self._internal.options = nodegraph.Options()
         
-        assert isinstance(self.__internal.options, nodegraph.Options)
+        assert isinstance(self._internal.options, nodegraph.Options)
         
-        self.__internal.options.nodes = nodes
+        self._internal.options.nodes = nodes
     
         return self
     
     def edges(self, edges: nodegraph.EdgeOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = nodegraph.Options()
+        if self._internal.options is None:
+            self._internal.options = nodegraph.Options()
         
-        assert isinstance(self.__internal.options, nodegraph.Options)
+        assert isinstance(self._internal.options, nodegraph.Options)
         
-        self.__internal.options.edges = edges
+        self._internal.options.edges = edges
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/parca.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/parca.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,45 +2,45 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import parca
 
 
 class Dataquery(cogbuilder.Builder[parca.Dataquery]):    
-    __internal: parca.Dataquery
+    _internal: parca.Dataquery
 
     def __init__(self):
-        self.__internal = parca.Dataquery()
+        self._internal = parca.Dataquery()
 
     def build(self) -> parca.Dataquery:
-        return self.__internal    
+        return self._internal    
     
     def label_selector(self, label_selector: str) -> typing.Self:        
-        self.__internal.label_selector = label_selector
+        self._internal.label_selector = label_selector
     
         return self
     
     def profile_type_id(self, profile_type_id: str) -> typing.Self:        
-        self.__internal.profile_type_id = profile_type_id
+        self._internal.profile_type_id = profile_type_id
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:        
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:        
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:        
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/piechart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/stat.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import piechart
+from ..models import stat
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "piechart"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "stat"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,253 +244,231 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def pie_type(self, pie_type: piechart.PieChartType) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+    def graph_mode(self, graph_mode: common.BigValueGraphMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
-        self.__internal.options.pie_type = pie_type
+        self._internal.options.graph_mode = graph_mode
     
         return self
     
-    def display_labels(self, display_labels: list[piechart.PieChartLabels]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+    def color_mode(self, color_mode: common.BigValueColorMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
-        self.__internal.options.display_labels = display_labels
+        self._internal.options.color_mode = color_mode
     
         return self
     
-    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+    def justify_mode(self, justify_mode: common.BigValueJustifyMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
-        tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.justify_mode = justify_mode
     
         return self
     
     def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
         reduce_options_resource = reduce_options.build()
-        self.__internal.options.reduce_options = reduce_options_resource
+        self._internal.options.reduce_options = reduce_options_resource
     
         return self
     
     def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
         text_resource = text.build()
-        self.__internal.options.text = text_resource
+        self._internal.options.text = text_resource
     
         return self
     
-    def legend(self, legend: piechart.PieChartLegendOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
+    def text_mode(self, text_mode: common.BigValueTextMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.options, piechart.Options)
+        assert isinstance(self._internal.options, stat.Options)
         
-        self.__internal.options.legend = legend
+        self._internal.options.text_mode = text_mode
     
         return self
     
     def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = piechart.Options()
-        
-        assert isinstance(self.__internal.options, piechart.Options)
-        
-        self.__internal.options.orientation = orientation
-    
-        return self
-    
-    def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = piechart.FieldConfig()
+        if self._internal.options is None:
+            self._internal.options = stat.Options()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, piechart.FieldConfig)
+        assert isinstance(self._internal.options, stat.Options)
         
-        hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.options.orientation = orientation
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/preferences.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/preferences.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,130 +2,125 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import preferences
 
 
 class Preferences(cogbuilder.Builder[preferences.Preferences]):    
-    """
-    Spec defines user, team or org Grafana preferences
-    swagger:model Preferences
-    """
-    
-    __internal: preferences.Preferences
+    _internal: preferences.Preferences
 
     def __init__(self):
-        self.__internal = preferences.Preferences()
+        self._internal = preferences.Preferences()
 
     def build(self) -> preferences.Preferences:
-        return self.__internal    
+        return self._internal    
     
     def home_dashboard_uid(self, home_dashboard_uid: str) -> typing.Self:    
         """
         UID for the home dashboard
         """
             
-        self.__internal.home_dashboard_uid = home_dashboard_uid
+        self._internal.home_dashboard_uid = home_dashboard_uid
     
         return self
     
     def timezone(self, timezone: str) -> typing.Self:    
         """
         The timezone selection
         TODO: this should use the timezone defined in common
         """
             
-        self.__internal.timezone = timezone
+        self._internal.timezone = timezone
     
         return self
     
     def week_start(self, week_start: str) -> typing.Self:    
         """
         day of the week (sunday, monday, etc)
         """
             
-        self.__internal.week_start = week_start
+        self._internal.week_start = week_start
     
         return self
     
     def theme(self, theme: str) -> typing.Self:    
         """
         light, dark, empty is default
         """
             
-        self.__internal.theme = theme
+        self._internal.theme = theme
     
         return self
     
     def language(self, language: str) -> typing.Self:    
         """
         Selected language (beta)
         """
             
-        self.__internal.language = language
+        self._internal.language = language
     
         return self
     
     def query_history(self, query_history: cogbuilder.Builder[preferences.QueryHistoryPreference]) -> typing.Self:    
         """
         Explore query history preferences
         """
             
         query_history_resource = query_history.build()
-        self.__internal.query_history = query_history_resource
+        self._internal.query_history = query_history_resource
     
         return self
     
     def cookie_preferences(self, cookie_preferences: cogbuilder.Builder[preferences.CookiePreferences]) -> typing.Self:    
         """
         Cookie preferences
         """
             
         cookie_preferences_resource = cookie_preferences.build()
-        self.__internal.cookie_preferences = cookie_preferences_resource
+        self._internal.cookie_preferences = cookie_preferences_resource
     
         return self
     
 
 class QueryHistoryPreference(cogbuilder.Builder[preferences.QueryHistoryPreference]):    
-    __internal: preferences.QueryHistoryPreference
+    _internal: preferences.QueryHistoryPreference
 
     def __init__(self):
-        self.__internal = preferences.QueryHistoryPreference()
+        self._internal = preferences.QueryHistoryPreference()
 
     def build(self) -> preferences.QueryHistoryPreference:
-        return self.__internal    
+        return self._internal    
     
     def home_tab(self, home_tab: str) -> typing.Self:    
         """
         one of: '' | 'query' | 'starred';
         """
             
-        self.__internal.home_tab = home_tab
+        self._internal.home_tab = home_tab
     
         return self
     
 
 class CookiePreferences(cogbuilder.Builder[preferences.CookiePreferences]):    
-    __internal: preferences.CookiePreferences
+    _internal: preferences.CookiePreferences
 
     def __init__(self):
-        self.__internal = preferences.CookiePreferences()
+        self._internal = preferences.CookiePreferences()
 
     def build(self) -> preferences.CookiePreferences:
-        return self.__internal    
+        return self._internal    
     
     def analytics(self, analytics: object) -> typing.Self:        
-        self.__internal.analytics = analytics
+        self._internal.analytics = analytics
     
         return self
     
     def performance(self, performance: object) -> typing.Self:        
-        self.__internal.performance = performance
+        self._internal.performance = performance
     
         return self
     
     def functional(self, functional: object) -> typing.Self:        
-        self.__internal.functional = functional
+        self._internal.functional = functional
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/publicdashboard.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/publicdashboard.py`

 * *Files 23% similar despite different names*

```diff
@@ -2,69 +2,69 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import publicdashboard
 
 
 class PublicDashboard(cogbuilder.Builder[publicdashboard.PublicDashboard]):    
-    __internal: publicdashboard.PublicDashboard
+    _internal: publicdashboard.PublicDashboard
 
     def __init__(self):
-        self.__internal = publicdashboard.PublicDashboard()
+        self._internal = publicdashboard.PublicDashboard()
 
     def build(self) -> publicdashboard.PublicDashboard:
-        return self.__internal    
+        return self._internal    
     
     def uid(self, uid: str) -> typing.Self:    
         """
         Unique public dashboard identifier
         """
             
-        self.__internal.uid = uid
+        self._internal.uid = uid
     
         return self
     
     def dashboard_uid(self, dashboard_uid: str) -> typing.Self:    
         """
         Dashboard unique identifier referenced by this public dashboard
         """
             
-        self.__internal.dashboard_uid = dashboard_uid
+        self._internal.dashboard_uid = dashboard_uid
     
         return self
     
     def access_token(self, access_token: str) -> typing.Self:    
         """
         Unique public access token
         """
             
-        self.__internal.access_token = access_token
+        self._internal.access_token = access_token
     
         return self
     
     def is_enabled(self, is_enabled: bool) -> typing.Self:    
         """
         Flag that indicates if the public dashboard is enabled
         """
             
-        self.__internal.is_enabled = is_enabled
+        self._internal.is_enabled = is_enabled
     
         return self
     
     def annotations_enabled(self, annotations_enabled: bool) -> typing.Self:    
         """
         Flag that indicates if annotations are enabled
         """
             
-        self.__internal.annotations_enabled = annotations_enabled
+        self._internal.annotations_enabled = annotations_enabled
     
         return self
     
     def time_selection_enabled(self, time_selection_enabled: bool) -> typing.Self:    
         """
         Flag that indicates if the time range picker is enabled
         """
             
-        self.__internal.time_selection_enabled = time_selection_enabled
+        self._internal.time_selection_enabled = time_selection_enabled
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/role.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/role.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,60 +2,60 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import role
 
 
 class Role(cogbuilder.Builder[role.Role]):    
-    __internal: role.Role
+    _internal: role.Role
 
     def __init__(self):
-        self.__internal = role.Role()
+        self._internal = role.Role()
 
     def build(self) -> role.Role:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:    
         """
         The role identifier `managed:builtins:editor:permissions`
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         Optional display
         """
             
-        self.__internal.display_name = display_name
+        self._internal.display_name = display_name
     
         return self
     
     def group_name(self, group_name: str) -> typing.Self:    
         """
         Name of the team.
         """
             
-        self.__internal.group_name = group_name
+        self._internal.group_name = group_name
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Role description
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def hidden(self, hidden: typing.Union[bool]) -> typing.Self:    
         """
         Do not show this role
         """
             
-        self.__internal.hidden = hidden
+        self._internal.hidden = hidden
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/rolebinding.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/rolebinding.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,91 +2,91 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import rolebinding
 
 
 class RoleBinding(cogbuilder.Builder[rolebinding.RoleBinding]):    
-    __internal: rolebinding.RoleBinding
+    _internal: rolebinding.RoleBinding
 
     def __init__(self):
-        self.__internal = rolebinding.RoleBinding()
+        self._internal = rolebinding.RoleBinding()
 
     def build(self) -> rolebinding.RoleBinding:
-        return self.__internal    
+        return self._internal    
     
     def role(self, role: typing.Union[cogbuilder.Builder[rolebinding.BuiltinRoleRef], cogbuilder.Builder[rolebinding.CustomRoleRef]]) -> typing.Self:    
         """
         The role we are discussing
         """
             
         role_resource = role.build()
-        self.__internal.role = role_resource
+        self._internal.role = role_resource
     
         return self
     
     def subject(self, subject: cogbuilder.Builder[rolebinding.RoleBindingSubject]) -> typing.Self:    
         """
         The team or user that has the specified role
         """
             
         subject_resource = subject.build()
-        self.__internal.subject = subject_resource
+        self._internal.subject = subject_resource
     
         return self
     
 
 class CustomRoleRef(cogbuilder.Builder[rolebinding.CustomRoleRef]):    
-    __internal: rolebinding.CustomRoleRef
+    _internal: rolebinding.CustomRoleRef
 
     def __init__(self):
-        self.__internal = rolebinding.CustomRoleRef()        
-        self.__internal.kind = "Role"
+        self._internal = rolebinding.CustomRoleRef()        
+        self._internal.kind = "Role"
 
     def build(self) -> rolebinding.CustomRoleRef:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
 
 class BuiltinRoleRef(cogbuilder.Builder[rolebinding.BuiltinRoleRef]):    
-    __internal: rolebinding.BuiltinRoleRef
+    _internal: rolebinding.BuiltinRoleRef
 
     def __init__(self):
-        self.__internal = rolebinding.BuiltinRoleRef()        
-        self.__internal.kind = "BuiltinRole"
+        self._internal = rolebinding.BuiltinRoleRef()        
+        self._internal.kind = "BuiltinRole"
 
     def build(self) -> rolebinding.BuiltinRoleRef:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: typing.Literal["viewer", "editor", "admin"]) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
 
 class RoleBindingSubject(cogbuilder.Builder[rolebinding.RoleBindingSubject]):    
-    __internal: rolebinding.RoleBindingSubject
+    _internal: rolebinding.RoleBindingSubject
 
     def __init__(self):
-        self.__internal = rolebinding.RoleBindingSubject()
+        self._internal = rolebinding.RoleBindingSubject()
 
     def build(self) -> rolebinding.RoleBindingSubject:
-        return self.__internal    
+        return self._internal    
     
     def kind(self, kind: typing.Literal["Team", "User"]) -> typing.Self:        
-        self.__internal.kind = kind
+        self._internal.kind = kind
     
         return self
     
     def name(self, name: str) -> typing.Self:    
         """
         The team/user identifier name
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/stat.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/dashboardlist.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,194 +1,183 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import stat
+from ..models import dashboardlist
 from ..cog import variants as cogvariants
-from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "stat"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "dashlist"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,251 +243,249 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def graph_mode(self, graph_mode: common.BigValueGraphMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def keep_time(self, keep_time: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.graph_mode = graph_mode
+        self._internal.options.keep_time = keep_time
     
         return self
     
-    def color_mode(self, color_mode: common.BigValueColorMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def include_vars(self, include_vars: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.color_mode = color_mode
+        self._internal.options.include_vars = include_vars
     
         return self
     
-    def justify_mode(self, justify_mode: common.BigValueJustifyMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def show_starred(self, show_starred: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.justify_mode = justify_mode
+        self._internal.options.show_starred = show_starred
     
         return self
     
-    def text_mode(self, text_mode: common.BigValueTextMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def show_recently_viewed(self, show_recently_viewed: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.text_mode = text_mode
+        self._internal.options.show_recently_viewed = show_recently_viewed
     
         return self
     
-    def wide_layout(self, wide_layout: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def show_search(self, show_search: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.wide_layout = wide_layout
+        self._internal.options.show_search = show_search
     
         return self
     
-    def reduce_options(self, reduce_options: cogbuilder.Builder[common.ReduceDataOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def show_headings(self, show_headings: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        reduce_options_resource = reduce_options.build()
-        self.__internal.options.reduce_options = reduce_options_resource
+        self._internal.options.show_headings = show_headings
     
         return self
     
-    def text(self, text: cogbuilder.Builder[common.VizTextDisplayOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def max_items(self, max_items: int) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        text_resource = text.build()
-        self.__internal.options.text = text_resource
+        self._internal.options.max_items = max_items
     
         return self
     
-    def show_percent_change(self, show_percent_change: bool) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def query(self, query: str) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.show_percent_change = show_percent_change
+        self._internal.options.query = query
     
         return self
     
-    def orientation(self, orientation: common.VizOrientation) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = stat.Options()
+    def folder_id(self, folder_id: int) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = dashboardlist.Options()
         
-        assert isinstance(self.__internal.options, stat.Options)
+        assert isinstance(self._internal.options, dashboardlist.Options)
         
-        self.__internal.options.orientation = orientation
+        self._internal.options.folder_id = folder_id
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/statetimeline.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/text.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,194 +1,183 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import statetimeline
+from ..models import text
 from ..cog import variants as cogvariants
-from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "state-timeline"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "text"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,314 +243,189 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def show_value(self, show_value: common.VisibilityMode) -> typing.Self:    
-        """
-        Show timeline values on chart
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
+    def mode(self, mode: text.TextMode) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = text.Options()
         
-        assert isinstance(self.__internal.options, statetimeline.Options)
+        assert isinstance(self._internal.options, text.Options)
         
-        self.__internal.options.show_value = show_value
+        self._internal.options.mode = mode
     
         return self
     
-    def row_height(self, row_height: float) -> typing.Self:    
-        """
-        Controls the row height
-        """
-            
-        if not row_height <= 1:
-            raise ValueError("row_height must be <= 1")
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
+    def code(self, code: text.CodeOptions) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = text.Options()
         
-        assert isinstance(self.__internal.options, statetimeline.Options)
+        assert isinstance(self._internal.options, text.Options)
         
-        self.__internal.options.row_height = row_height
+        self._internal.options.code = code
     
         return self
     
-    def merge_values(self, merge_values: bool) -> typing.Self:    
-        """
-        Merge equal consecutive values
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
-        
-        assert isinstance(self.__internal.options, statetimeline.Options)
-        
-        self.__internal.options.merge_values = merge_values
-    
-        return self
-    
-    def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
-        
-        assert isinstance(self.__internal.options, statetimeline.Options)
-        
-        legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
-    
-        return self
-    
-    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
-        
-        assert isinstance(self.__internal.options, statetimeline.Options)
-        
-        tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
-    
-        return self
-    
-    def timezone(self, timezone: list[common.TimeZone]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
-        
-        assert isinstance(self.__internal.options, statetimeline.Options)
-        
-        self.__internal.options.timezone = timezone
-    
-        return self
-    
-    def align_value(self, align_value: common.TimelineValueAlignment) -> typing.Self:    
-        """
-        Controls value alignment on the timelines
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = statetimeline.Options()
-        
-        assert isinstance(self.__internal.options, statetimeline.Options)
-        
-        self.__internal.options.align_value = align_value
-    
-        return self
-    
-    def line_width(self, line_width: int) -> typing.Self:        
-        if not line_width <= 10:
-            raise ValueError("line_width must be <= 10")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = statetimeline.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, statetimeline.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.line_width = line_width
-    
-        return self
-    
-    def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = statetimeline.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, statetimeline.FieldConfig)
-        
-        hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
-    
-        return self
-    
-    def fill_opacity(self, fill_opacity: int) -> typing.Self:        
-        if not fill_opacity <= 100:
-            raise ValueError("fill_opacity must be <= 100")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = statetimeline.FieldConfig()
+    def content(self, content: str) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = text.Options()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, statetimeline.FieldConfig)
+        assert isinstance(self._internal.options, text.Options)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.options.content = content
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/table.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/geomap.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import table
+from ..models import geomap
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "table"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "geomap"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,437 +244,211 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def frame_index(self, frame_index: float) -> typing.Self:    
-        """
-        Represents the index of the selected frame
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
+    def view(self, view: geomap.MapViewConfig) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = geomap.Options()
         
-        assert isinstance(self.__internal.options, table.Options)
+        assert isinstance(self._internal.options, geomap.Options)
         
-        self.__internal.options.frame_index = frame_index
+        self._internal.options.view = view
     
         return self
     
-    def show_header(self, show_header: bool) -> typing.Self:    
-        """
-        Controls whether the panel should show the header
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
+    def controls(self, controls: geomap.ControlsOptions) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = geomap.Options()
         
-        assert isinstance(self.__internal.options, table.Options)
+        assert isinstance(self._internal.options, geomap.Options)
         
-        self.__internal.options.show_header = show_header
+        self._internal.options.controls = controls
     
         return self
     
-    def show_type_icons(self, show_type_icons: bool) -> typing.Self:    
-        """
-        Controls whether the header should show icons for the column types
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
+    def basemap(self, basemap: cogbuilder.Builder[common.MapLayerOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = geomap.Options()
         
-        assert isinstance(self.__internal.options, table.Options)
+        assert isinstance(self._internal.options, geomap.Options)
         
-        self.__internal.options.show_type_icons = show_type_icons
+        basemap_resource = basemap.build()
+        self._internal.options.basemap = basemap_resource
     
         return self
     
-    def sort_by(self, sort_by: list[cogbuilder.Builder[common.TableSortByFieldState]]) -> typing.Self:    
-        """
-        Used to control row sorting
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
-        
-        assert isinstance(self.__internal.options, table.Options)
-        
-        sort_by_resources = [r1.build() for r1 in sort_by]
-        self.__internal.options.sort_by = sort_by_resources
-    
-        return self
-    
-    def footer(self, footer: cogbuilder.Builder[common.TableFooterOptions]) -> typing.Self:    
-        """
-        Controls footer options
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
-        
-        assert isinstance(self.__internal.options, table.Options)
-        
-        footer_resource = footer.build()
-        self.__internal.options.footer = footer_resource
-    
-        return self
-    
-    def cell_height(self, cell_height: common.TableCellHeight) -> typing.Self:    
-        """
-        Controls the height of the rows
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = table.Options()
+    def layers(self, layers: list[cogbuilder.Builder[common.MapLayerOptions]]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = geomap.Options()
         
-        assert isinstance(self.__internal.options, table.Options)
+        assert isinstance(self._internal.options, geomap.Options)
         
-        self.__internal.options.cell_height = cell_height
+        layers_resources = [r1.build() for r1 in layers]
+        self._internal.options.layers = layers_resources
     
         return self
     
-    def width(self, width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.width = width
-    
-        return self
-    
-    def min_width(self, min_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.min_width = min_width
-    
-        return self
-    
-    def align(self, align: common.FieldTextAlignment) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.align = align
-    
-        return self
-    
-    def display_mode(self, display_mode: common.TableCellDisplayMode) -> typing.Self:    
-        """
-        This field is deprecated in favor of using cellOptions
-        """
-            
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.display_mode = display_mode
-    
-        return self
-    
-    def cell_options(self, cell_options: common.TableCellOptions) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.cell_options = cell_options
-    
-        return self
-    
-    def hidden(self, hidden: bool) -> typing.Self:    
-        """
-        ?? default is missing or false ??
-        """
-            
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.hidden = hidden
-    
-        return self
-    
-    def inspect(self, inspect: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.inspect = inspect
-    
-        return self
-    
-    def filterable(self, filterable: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.filterable = filterable
-    
-        return self
-    
-    def hide_header(self, hide_header: bool) -> typing.Self:    
-        """
-        Hides any header for a column, useful for columns that show some static content or buttons.
-        """
-            
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = table.FieldConfig()
+    def tooltip(self, tooltip: geomap.TooltipOptions) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = geomap.Options()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, table.FieldConfig)
+        assert isinstance(self._internal.options, geomap.Options)
         
-        self.__internal.field_config.defaults.custom.hide_header = hide_header
+        self._internal.options.tooltip = tooltip
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/team.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/team.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,34 +2,34 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import team
 
 
 class Team(cogbuilder.Builder[team.Team]):    
-    __internal: team.Team
+    _internal: team.Team
 
     def __init__(self, name: str):
-        self.__internal = team.Team()        
-        self.__internal.name = name
+        self._internal = team.Team()        
+        self._internal.name = name
 
     def build(self) -> team.Team:
-        return self.__internal    
+        return self._internal    
     
     def name(self, name: str) -> typing.Self:    
         """
         Name of the team.
         """
             
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def email(self, email: str) -> typing.Self:    
         """
         Email of the team.
         """
             
-        self.__internal.email = email
+        self._internal.email = email
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/tempo.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/tempo.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,238 +2,210 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import tempo
 
 
 class TempoQuery(cogbuilder.Builder[tempo.TempoQuery]):    
-    __internal: tempo.TempoQuery
+    _internal: tempo.TempoQuery
 
     def __init__(self):
-        self.__internal = tempo.TempoQuery()
+        self._internal = tempo.TempoQuery()
 
     def build(self) -> tempo.TempoQuery:
-        return self.__internal    
+        return self._internal    
     
     def ref_id(self, ref_id: str) -> typing.Self:    
         """
         A unique identifier for the query within the list of targets.
         In server side expressions, the refId is used as a variable name to identify results.
         By default, the UI will assign A->Z; however setting meaningful names may be useful.
         """
             
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:    
         """
         true if query is disabled (ie should not be returned to the dashboard)
         Note this does not always imply that the query should not be executed since
         the results from a hidden query may be used as the input to other queries (SSE etc)
         """
             
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:    
         """
         Specify the query flavor
         TODO make this required and give it a default
         """
             
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def query(self, query: str) -> typing.Self:    
         """
         TraceQL query or trace ID
         """
             
-        self.__internal.query = query
+        self._internal.query = query
     
         return self
     
     def search(self, search: str) -> typing.Self:    
         """
         @deprecated Logfmt query to filter traces by their tags. Example: http.status_code=200 error=true
         """
             
-        self.__internal.search = search
+        self._internal.search = search
     
         return self
     
     def service_name(self, service_name: str) -> typing.Self:    
         """
         @deprecated Query traces by service name
         """
             
-        self.__internal.service_name = service_name
+        self._internal.service_name = service_name
     
         return self
     
     def span_name(self, span_name: str) -> typing.Self:    
         """
         @deprecated Query traces by span name
         """
             
-        self.__internal.span_name = span_name
+        self._internal.span_name = span_name
     
         return self
     
     def min_duration(self, min_duration: str) -> typing.Self:    
         """
         @deprecated Define the minimum duration to select traces. Use duration format, for example: 1.2s, 100ms
         """
             
-        self.__internal.min_duration = min_duration
+        self._internal.min_duration = min_duration
     
         return self
     
     def max_duration(self, max_duration: str) -> typing.Self:    
         """
         @deprecated Define the maximum duration to select traces. Use duration format, for example: 1.2s, 100ms
         """
             
-        self.__internal.max_duration = max_duration
+        self._internal.max_duration = max_duration
     
         return self
     
-    def service_map_query(self, service_map_query: typing.Union[str, list[str]]) -> typing.Self:    
+    def service_map_query(self, service_map_query: str) -> typing.Self:    
         """
-        Filters to be included in a PromQL query to select data for the service graph. Example: {client="app",service="app"}. Providing multiple values will produce union of results for each filter, using PromQL OR operator internally.
+        Filters to be included in a PromQL query to select data for the service graph. Example: {client="app",service="app"}
         """
             
-        self.__internal.service_map_query = service_map_query
+        self._internal.service_map_query = service_map_query
     
         return self
     
     def service_map_include_namespace(self, service_map_include_namespace: bool) -> typing.Self:    
         """
         Use service.namespace in addition to service.name to uniquely identify a service.
         """
             
-        self.__internal.service_map_include_namespace = service_map_include_namespace
+        self._internal.service_map_include_namespace = service_map_include_namespace
     
         return self
     
     def limit(self, limit: int) -> typing.Self:    
         """
         Defines the maximum number of traces that are returned from Tempo
         """
             
-        self.__internal.limit = limit
-    
-        return self
-    
-    def spss(self, spss: int) -> typing.Self:    
-        """
-        Defines the maximum number of spans per spanset that are returned from Tempo
-        """
-            
-        self.__internal.spss = spss
-    
-        return self
-    
-    def filters(self, filters: list[cogbuilder.Builder[tempo.TraceqlFilter]]) -> typing.Self:        
-        filters_resources = [r1.build() for r1 in filters]
-        self.__internal.filters = filters_resources
-    
-        return self
-    
-    def group_by(self, group_by: list[cogbuilder.Builder[tempo.TraceqlFilter]]) -> typing.Self:    
-        """
-        Filters that are used to query the metrics summary
-        """
-            
-        group_by_resources = [r1.build() for r1 in group_by]
-        self.__internal.group_by = group_by_resources
+        self._internal.limit = limit
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:    
         """
         For mixed data sources the selected datasource is on the query level.
         For non mixed scenarios this is undefined.
         TODO find a better way to do this ^ that's friendly to schema
         TODO this shouldn't be unknown but DataSourceRef | null
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
-    def table_type(self, table_type: tempo.SearchTableType) -> typing.Self:    
-        """
-        The type of the table that is used to display the search results
-        """
-            
-        self.__internal.table_type = table_type
+    def filters(self, filters: list[cogbuilder.Builder[tempo.TraceqlFilter]]) -> typing.Self:        
+        filters_resources = [r1.build() for r1 in filters]
+        self._internal.filters = filters_resources
     
         return self
     
 
 class TraceqlFilter(cogbuilder.Builder[tempo.TraceqlFilter]):    
-    __internal: tempo.TraceqlFilter
+    _internal: tempo.TraceqlFilter
 
     def __init__(self):
-        self.__internal = tempo.TraceqlFilter()
+        self._internal = tempo.TraceqlFilter()
 
     def build(self) -> tempo.TraceqlFilter:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:    
         """
         Uniquely identify the filter, will not be used in the query generation
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def tag(self, tag: str) -> typing.Self:    
         """
         The tag for the search filter, for example: .http.status_code, .service.name, status
         """
             
-        self.__internal.tag = tag
+        self._internal.tag = tag
     
         return self
     
     def operator(self, operator: str) -> typing.Self:    
         """
         The operator that connects the tag to the value, for example: =, >, !=, =~
         """
             
-        self.__internal.operator = operator
+        self._internal.operator = operator
     
         return self
     
     def value(self, value: typing.Union[str, list[str]]) -> typing.Self:    
         """
         The value for the search filter
         """
             
-        self.__internal.value = value
+        self._internal.value = value
     
         return self
     
     def value_type(self, value_type: str) -> typing.Self:    
         """
         The type of the value, used for example to check whether we need to wrap the value in quotes when generating the query
         """
             
-        self.__internal.value_type = value_type
+        self._internal.value_type = value_type
     
         return self
     
     def scope(self, scope: tempo.TraceqlSearchScope) -> typing.Self:    
         """
         The scope of the filter, can either be unscoped/all scopes, resource or span
         """
             
-        self.__internal.scope = scope
+        self._internal.scope = scope
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/testdata.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/testdata.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,406 +2,396 @@
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import testdata
 
 
 class StreamingQuery(cogbuilder.Builder[testdata.StreamingQuery]):    
-    __internal: testdata.StreamingQuery
+    _internal: testdata.StreamingQuery
 
     def __init__(self):
-        self.__internal = testdata.StreamingQuery()
+        self._internal = testdata.StreamingQuery()
 
     def build(self) -> testdata.StreamingQuery:
-        return self.__internal    
+        return self._internal    
     
-    def type_val(self, type_val: typing.Literal["signal", "logs", "fetch", "traces"]) -> typing.Self:        
-        self.__internal.type_val = type_val
+    def type_val(self, type_val: typing.Literal["signal", "logs", "fetch"]) -> typing.Self:        
+        self._internal.type_val = type_val
     
         return self
     
     def speed(self, speed: int) -> typing.Self:        
-        self.__internal.speed = speed
+        self._internal.speed = speed
     
         return self
     
     def spread(self, spread: int) -> typing.Self:        
-        self.__internal.spread = spread
+        self._internal.spread = spread
     
         return self
     
     def noise(self, noise: int) -> typing.Self:        
-        self.__internal.noise = noise
+        self._internal.noise = noise
     
         return self
     
     def bands(self, bands: int) -> typing.Self:        
-        self.__internal.bands = bands
+        self._internal.bands = bands
     
         return self
     
     def url(self, url: str) -> typing.Self:        
-        self.__internal.url = url
+        self._internal.url = url
     
         return self
     
 
 class PulseWaveQuery(cogbuilder.Builder[testdata.PulseWaveQuery]):    
-    __internal: testdata.PulseWaveQuery
+    _internal: testdata.PulseWaveQuery
 
     def __init__(self):
-        self.__internal = testdata.PulseWaveQuery()
+        self._internal = testdata.PulseWaveQuery()
 
     def build(self) -> testdata.PulseWaveQuery:
-        return self.__internal    
+        return self._internal    
     
     def time_step(self, time_step: int) -> typing.Self:        
-        self.__internal.time_step = time_step
+        self._internal.time_step = time_step
     
         return self
     
     def on_count(self, on_count: int) -> typing.Self:        
-        self.__internal.on_count = on_count
+        self._internal.on_count = on_count
     
         return self
     
     def off_count(self, off_count: int) -> typing.Self:        
-        self.__internal.off_count = off_count
+        self._internal.off_count = off_count
     
         return self
     
     def on_value(self, on_value: float) -> typing.Self:        
-        self.__internal.on_value = on_value
+        self._internal.on_value = on_value
     
         return self
     
     def off_value(self, off_value: float) -> typing.Self:        
-        self.__internal.off_value = off_value
+        self._internal.off_value = off_value
     
         return self
     
 
 class SimulationQuery(cogbuilder.Builder[testdata.SimulationQuery]):    
-    __internal: testdata.SimulationQuery
+    _internal: testdata.SimulationQuery
 
     def __init__(self):
-        self.__internal = testdata.SimulationQuery()
+        self._internal = testdata.SimulationQuery()
 
     def build(self) -> testdata.SimulationQuery:
-        return self.__internal    
+        return self._internal    
     
     def key(self, key: cogbuilder.Builder[testdata.Key]) -> typing.Self:        
         key_resource = key.build()
-        self.__internal.key = key_resource
+        self._internal.key = key_resource
     
         return self
     
     def config(self, config: object) -> typing.Self:        
-        self.__internal.config = config
+        self._internal.config = config
     
         return self
     
     def stream(self, stream: bool) -> typing.Self:        
-        self.__internal.stream = stream
+        self._internal.stream = stream
     
         return self
     
     def last(self, last: bool) -> typing.Self:        
-        self.__internal.last = last
+        self._internal.last = last
     
         return self
     
 
 class NodesQuery(cogbuilder.Builder[testdata.NodesQuery]):    
-    __internal: testdata.NodesQuery
+    _internal: testdata.NodesQuery
 
     def __init__(self):
-        self.__internal = testdata.NodesQuery()
+        self._internal = testdata.NodesQuery()
 
     def build(self) -> testdata.NodesQuery:
-        return self.__internal    
+        return self._internal    
     
-    def type_val(self, type_val: typing.Literal["random", "response_small", "response_medium", "random edges"]) -> typing.Self:        
-        self.__internal.type_val = type_val
+    def type_val(self, type_val: typing.Literal["random", "response", "random edges"]) -> typing.Self:        
+        self._internal.type_val = type_val
     
         return self
     
     def count(self, count: int) -> typing.Self:        
-        self.__internal.count = count
-    
-        return self
-    
-    def seed(self, seed: int) -> typing.Self:        
-        self.__internal.seed = seed
+        self._internal.count = count
     
         return self
     
 
 class USAQuery(cogbuilder.Builder[testdata.USAQuery]):    
-    __internal: testdata.USAQuery
+    _internal: testdata.USAQuery
 
     def __init__(self):
-        self.__internal = testdata.USAQuery()
+        self._internal = testdata.USAQuery()
 
     def build(self) -> testdata.USAQuery:
-        return self.__internal    
+        return self._internal    
     
     def mode(self, mode: str) -> typing.Self:        
-        self.__internal.mode = mode
+        self._internal.mode = mode
     
         return self
     
     def period(self, period: str) -> typing.Self:        
-        self.__internal.period = period
+        self._internal.period = period
     
         return self
     
     def fields(self, fields: list[str]) -> typing.Self:        
-        self.__internal.fields = fields
+        self._internal.fields = fields
     
         return self
     
     def states(self, states: list[str]) -> typing.Self:        
-        self.__internal.states = states
+        self._internal.states = states
     
         return self
     
 
 class CSVWave(cogbuilder.Builder[testdata.CSVWave]):    
-    __internal: testdata.CSVWave
+    _internal: testdata.CSVWave
 
     def __init__(self):
-        self.__internal = testdata.CSVWave()
+        self._internal = testdata.CSVWave()
 
     def build(self) -> testdata.CSVWave:
-        return self.__internal    
+        return self._internal    
     
     def time_step(self, time_step: int) -> typing.Self:        
-        self.__internal.time_step = time_step
+        self._internal.time_step = time_step
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def values_csv(self, values_csv: str) -> typing.Self:        
-        self.__internal.values_csv = values_csv
+        self._internal.values_csv = values_csv
     
         return self
     
     def labels(self, labels: str) -> typing.Self:        
-        self.__internal.labels = labels
+        self._internal.labels = labels
     
         return self
     
 
 class Scenario(cogbuilder.Builder[testdata.Scenario]):    
     """
     TODO: Should this live here given it's not used in the dataquery?
     """
     
-    __internal: testdata.Scenario
+    _internal: testdata.Scenario
 
     def __init__(self):
-        self.__internal = testdata.Scenario()
+        self._internal = testdata.Scenario()
 
     def build(self) -> testdata.Scenario:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: str) -> typing.Self:        
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def name(self, name: str) -> typing.Self:        
-        self.__internal.name = name
+        self._internal.name = name
     
         return self
     
     def string_input(self, string_input: str) -> typing.Self:        
-        self.__internal.string_input = string_input
+        self._internal.string_input = string_input
     
         return self
     
     def description(self, description: str) -> typing.Self:        
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def hide_alias_field(self, hide_alias_field: bool) -> typing.Self:        
-        self.__internal.hide_alias_field = hide_alias_field
+        self._internal.hide_alias_field = hide_alias_field
     
         return self
     
 
 class Dataquery(cogbuilder.Builder[testdata.Dataquery]):    
-    __internal: testdata.Dataquery
+    _internal: testdata.Dataquery
 
     def __init__(self):
-        self.__internal = testdata.Dataquery()
+        self._internal = testdata.Dataquery()
 
     def build(self) -> testdata.Dataquery:
-        return self.__internal    
+        return self._internal    
     
     def alias(self, alias: str) -> typing.Self:        
-        self.__internal.alias = alias
+        self._internal.alias = alias
     
         return self
     
     def scenario_id(self, scenario_id: testdata.TestDataQueryType) -> typing.Self:        
-        self.__internal.scenario_id = scenario_id
+        self._internal.scenario_id = scenario_id
     
         return self
     
     def string_input(self, string_input: str) -> typing.Self:        
-        self.__internal.string_input = string_input
+        self._internal.string_input = string_input
     
         return self
     
     def stream(self, stream: cogbuilder.Builder[testdata.StreamingQuery]) -> typing.Self:        
         stream_resource = stream.build()
-        self.__internal.stream = stream_resource
+        self._internal.stream = stream_resource
     
         return self
     
     def pulse_wave(self, pulse_wave: cogbuilder.Builder[testdata.PulseWaveQuery]) -> typing.Self:        
         pulse_wave_resource = pulse_wave.build()
-        self.__internal.pulse_wave = pulse_wave_resource
+        self._internal.pulse_wave = pulse_wave_resource
     
         return self
     
     def sim(self, sim: cogbuilder.Builder[testdata.SimulationQuery]) -> typing.Self:        
         sim_resource = sim.build()
-        self.__internal.sim = sim_resource
+        self._internal.sim = sim_resource
     
         return self
     
     def csv_wave(self, csv_wave: list[cogbuilder.Builder[testdata.CSVWave]]) -> typing.Self:        
         csv_wave_resources = [r1.build() for r1 in csv_wave]
-        self.__internal.csv_wave = csv_wave_resources
+        self._internal.csv_wave = csv_wave_resources
     
         return self
     
     def labels(self, labels: str) -> typing.Self:        
-        self.__internal.labels = labels
+        self._internal.labels = labels
     
         return self
     
     def lines(self, lines: int) -> typing.Self:        
-        self.__internal.lines = lines
+        self._internal.lines = lines
     
         return self
     
     def level_column(self, level_column: bool) -> typing.Self:        
-        self.__internal.level_column = level_column
+        self._internal.level_column = level_column
     
         return self
     
     def channel(self, channel: str) -> typing.Self:        
-        self.__internal.channel = channel
+        self._internal.channel = channel
     
         return self
     
     def nodes(self, nodes: cogbuilder.Builder[testdata.NodesQuery]) -> typing.Self:        
         nodes_resource = nodes.build()
-        self.__internal.nodes = nodes_resource
+        self._internal.nodes = nodes_resource
     
         return self
     
     def csv_file_name(self, csv_file_name: str) -> typing.Self:        
-        self.__internal.csv_file_name = csv_file_name
+        self._internal.csv_file_name = csv_file_name
     
         return self
     
     def csv_content(self, csv_content: str) -> typing.Self:        
-        self.__internal.csv_content = csv_content
+        self._internal.csv_content = csv_content
     
         return self
     
     def raw_frame_content(self, raw_frame_content: str) -> typing.Self:        
-        self.__internal.raw_frame_content = raw_frame_content
+        self._internal.raw_frame_content = raw_frame_content
     
         return self
     
     def series_count(self, series_count: int) -> typing.Self:        
-        self.__internal.series_count = series_count
+        self._internal.series_count = series_count
     
         return self
     
     def usa(self, usa: cogbuilder.Builder[testdata.USAQuery]) -> typing.Self:        
         usa_resource = usa.build()
-        self.__internal.usa = usa_resource
+        self._internal.usa = usa_resource
     
         return self
     
     def error_type(self, error_type: typing.Literal["server_panic", "frontend_exception", "frontend_observable"]) -> typing.Self:        
-        self.__internal.error_type = error_type
+        self._internal.error_type = error_type
     
         return self
     
     def span_count(self, span_count: int) -> typing.Self:        
-        self.__internal.span_count = span_count
+        self._internal.span_count = span_count
     
         return self
     
     def points(self, points: list[list[typing.Union[str, int]]]) -> typing.Self:        
-        self.__internal.points = points
+        self._internal.points = points
     
         return self
     
     def drop_percent(self, drop_percent: float) -> typing.Self:        
-        self.__internal.drop_percent = drop_percent
-    
-        return self
-    
-    def flamegraph_diff(self, flamegraph_diff: bool) -> typing.Self:        
-        self.__internal.flamegraph_diff = flamegraph_diff
+        self._internal.drop_percent = drop_percent
     
         return self
     
     def ref_id(self, ref_id: str) -> typing.Self:        
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
     
         return self
     
     def hide(self, hide: bool) -> typing.Self:        
-        self.__internal.hide = hide
+        self._internal.hide = hide
     
         return self
     
     def query_type(self, query_type: str) -> typing.Self:        
-        self.__internal.query_type = query_type
+        self._internal.query_type = query_type
     
         return self
     
     def datasource(self, datasource: object) -> typing.Self:        
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
 
 class Key(cogbuilder.Builder[testdata.Key]):    
-    __internal: testdata.Key
+    _internal: testdata.Key
 
     def __init__(self):
-        self.__internal = testdata.Key()
+        self._internal = testdata.Key()
 
     def build(self) -> testdata.Key:
-        return self.__internal    
+        return self._internal    
     
     def type_val(self, type_val: str) -> typing.Self:        
-        self.__internal.type_val = type_val
+        self._internal.type_val = type_val
     
         return self
     
     def tick(self, tick: float) -> typing.Self:        
-        self.__internal.tick = tick
+        self._internal.tick = tick
     
         return self
     
     def uid(self, uid: str) -> typing.Self:        
-        self.__internal.uid = uid
+        self._internal.uid = uid
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/text.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/news.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,193 +1,183 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import text
+from ..models import news
 from ..cog import variants as cogvariants
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "text"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "news"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -195,82 +185,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -280,189 +243,183 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def mode(self, mode: text.TextMode) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = text.Options()
-        
-        assert isinstance(self.__internal.options, text.Options)
-        
-        self.__internal.options.mode = mode
-    
-        return self
-    
-    def code(self, code: text.CodeOptions) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = text.Options()
+    def feed_url(self, feed_url: str) -> typing.Self:    
+        """
+        empty/missing will default to grafana blog
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = news.Options()
         
-        assert isinstance(self.__internal.options, text.Options)
+        assert isinstance(self._internal.options, news.Options)
         
-        self.__internal.options.code = code
+        self._internal.options.feed_url = feed_url
     
         return self
     
-    def content(self, content: str) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = text.Options()
+    def show_image(self, show_image: bool) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = news.Options()
         
-        assert isinstance(self.__internal.options, text.Options)
+        assert isinstance(self._internal.options, news.Options)
         
-        self.__internal.options.content = content
+        self._internal.options.show_image = show_image
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/timeseries.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/timeseries.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "timeseries"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "timeseries"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,822 +244,802 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def timezone(self, timezone: list[common.TimeZone]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = timeseries.Options()
+        if self._internal.options is None:
+            self._internal.options = timeseries.Options()
         
-        assert isinstance(self.__internal.options, timeseries.Options)
+        assert isinstance(self._internal.options, timeseries.Options)
         
-        self.__internal.options.timezone = timezone
+        self._internal.options.timezone = timezone
     
         return self
     
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = timeseries.Options()
+        if self._internal.options is None:
+            self._internal.options = timeseries.Options()
         
-        assert isinstance(self.__internal.options, timeseries.Options)
+        assert isinstance(self._internal.options, timeseries.Options)
         
         legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.legend = legend_resource
     
         return self
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = timeseries.Options()
+        if self._internal.options is None:
+            self._internal.options = timeseries.Options()
         
-        assert isinstance(self.__internal.options, timeseries.Options)
+        assert isinstance(self._internal.options, timeseries.Options)
         
         tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
     def draw_style(self, draw_style: common.GraphDrawStyle) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.draw_style = draw_style
+        self._internal.field_config.defaults.custom.draw_style = draw_style
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.gradient_mode = gradient_mode
+        self._internal.field_config.defaults.custom.gradient_mode = gradient_mode
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
+        self._internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
     
         return self
     
     def line_color(self, line_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_color = line_color
+        self._internal.field_config.defaults.custom.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_interpolation = line_interpolation
+        self._internal.field_config.defaults.custom.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
         line_style_resource = line_style.build()
-        self.__internal.field_config.defaults.custom.line_style = line_style_resource
+        self._internal.field_config.defaults.custom.line_style = line_style_resource
     
         return self
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_color = fill_color
+        self._internal.field_config.defaults.custom.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.show_points = show_points
+        self._internal.field_config.defaults.custom.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_size = point_size
+        self._internal.field_config.defaults.custom.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_color = point_color
+        self._internal.field_config.defaults.custom.point_color = point_color
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_alignment = bar_alignment
+        self._internal.field_config.defaults.custom.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
+        self._internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
     
         return self
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
         stacking_resource = stacking.build()
-        self.__internal.field_config.defaults.custom.stacking = stacking_resource
+        self._internal.field_config.defaults.custom.stacking = stacking_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def transform(self, transform: common.GraphTransform) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.transform = transform
+        self._internal.field_config.defaults.custom.transform = transform
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.span_nulls = span_nulls
+        self._internal.field_config.defaults.custom.span_nulls = span_nulls
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_below_to = fill_below_to
+        self._internal.field_config.defaults.custom.fill_below_to = fill_below_to
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_symbol = point_symbol
+        self._internal.field_config.defaults.custom.point_symbol = point_symbol
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = timeseries.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = timeseries.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, timeseries.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, timeseries.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_max_width = bar_max_width
+        self._internal.field_config.defaults.custom.bar_max_width = bar_max_width
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/trend.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/candlestick.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,194 +1,184 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 from ..cog import builder as cogbuilder
 from ..models import dashboard
-from ..models import trend
+from ..models import candlestick
 from ..cog import variants as cogvariants
 from ..models import common
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "trend"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "candlestick"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,826 +244,865 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
-    def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = trend.Options()
+    def mode(self, mode: candlestick.VizDisplayMode) -> typing.Self:    
+        """
+        Sets which dimensions are used for the visualization
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
         
-        assert isinstance(self.__internal.options, trend.Options)
+        assert isinstance(self._internal.options, candlestick.Options)
         
-        legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.mode = mode
+    
+        return self
+    
+    def candle_style(self, candle_style: candlestick.CandleStyle) -> typing.Self:    
+        """
+        Sets the style of the candlesticks
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
+        
+        assert isinstance(self._internal.options, candlestick.Options)
+        
+        self._internal.options.candle_style = candle_style
     
         return self
     
-    def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = trend.Options()
+    def color_strategy(self, color_strategy: candlestick.ColorStrategy) -> typing.Self:    
+        """
+        Sets the color strategy for the candlesticks
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
         
-        assert isinstance(self.__internal.options, trend.Options)
+        assert isinstance(self._internal.options, candlestick.Options)
         
-        tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.color_strategy = color_strategy
     
         return self
     
-    def x_field(self, x_field: str) -> typing.Self:    
+    def fields(self, fields: candlestick.CandlestickFieldMap) -> typing.Self:    
         """
-        Name of the x field to use (defaults to first number)
+        Map fields to appropriate dimension
         """
             
-        if self.__internal.options is None:
-            self.__internal.options = trend.Options()
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
         
-        assert isinstance(self.__internal.options, trend.Options)
+        assert isinstance(self._internal.options, candlestick.Options)
         
-        self.__internal.options.x_field = x_field
+        self._internal.options.fields = fields
+    
+        return self
+    
+    def colors(self, colors: candlestick.CandlestickColors) -> typing.Self:    
+        """
+        Set which colors are used when the price movement is up or down
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
+        
+        assert isinstance(self._internal.options, candlestick.Options)
+        
+        self._internal.options.colors = colors
+    
+        return self
+    
+    def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
+        
+        assert isinstance(self._internal.options, candlestick.Options)
+        
+        legend_resource = legend.build()
+        self._internal.options.legend = legend_resource
+    
+        return self
+    
+    def include_all_fields(self, include_all_fields: bool) -> typing.Self:    
+        """
+        When enabled, all fields will be sent to the graph
+        """
+            
+        if self._internal.options is None:
+            self._internal.options = candlestick.Options()
+        
+        assert isinstance(self._internal.options, candlestick.Options)
+        
+        self._internal.options.include_all_fields = include_all_fields
     
         return self
     
     def draw_style(self, draw_style: common.GraphDrawStyle) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.draw_style = draw_style
+        self._internal.field_config.defaults.custom.draw_style = draw_style
     
         return self
     
     def gradient_mode(self, gradient_mode: common.GraphGradientMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.gradient_mode = gradient_mode
+        self._internal.field_config.defaults.custom.gradient_mode = gradient_mode
     
         return self
     
     def thresholds_style(self, thresholds_style: cogbuilder.Builder[common.GraphThresholdsStyleConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
         thresholds_style_resource = thresholds_style.build()
-        self.__internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
+        self._internal.field_config.defaults.custom.thresholds_style = thresholds_style_resource
     
         return self
     
     def line_color(self, line_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_color = line_color
+        self._internal.field_config.defaults.custom.line_color = line_color
     
         return self
     
     def line_width(self, line_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def line_interpolation(self, line_interpolation: common.LineInterpolation) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_interpolation = line_interpolation
+        self._internal.field_config.defaults.custom.line_interpolation = line_interpolation
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
         line_style_resource = line_style.build()
-        self.__internal.field_config.defaults.custom.line_style = line_style_resource
+        self._internal.field_config.defaults.custom.line_style = line_style_resource
     
         return self
     
     def fill_color(self, fill_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_color = fill_color
+        self._internal.field_config.defaults.custom.fill_color = fill_color
     
         return self
     
     def fill_opacity(self, fill_opacity: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_opacity = fill_opacity
+        self._internal.field_config.defaults.custom.fill_opacity = fill_opacity
     
         return self
     
     def show_points(self, show_points: common.VisibilityMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.show_points = show_points
+        self._internal.field_config.defaults.custom.show_points = show_points
     
         return self
     
     def point_size(self, point_size: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_size = point_size
+        self._internal.field_config.defaults.custom.point_size = point_size
     
         return self
     
     def point_color(self, point_color: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_color = point_color
+        self._internal.field_config.defaults.custom.point_color = point_color
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def bar_alignment(self, bar_alignment: common.BarAlignment) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_alignment = bar_alignment
+        self._internal.field_config.defaults.custom.bar_alignment = bar_alignment
     
         return self
     
     def bar_width_factor(self, bar_width_factor: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
+        self._internal.field_config.defaults.custom.bar_width_factor = bar_width_factor
     
         return self
     
     def stacking(self, stacking: cogbuilder.Builder[common.StackingConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
         stacking_resource = stacking.build()
-        self.__internal.field_config.defaults.custom.stacking = stacking_resource
+        self._internal.field_config.defaults.custom.stacking = stacking_resource
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def transform(self, transform: common.GraphTransform) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.transform = transform
+        self._internal.field_config.defaults.custom.transform = transform
     
         return self
     
     def span_nulls(self, span_nulls: typing.Union[bool, float]) -> typing.Self:    
         """
         Indicate if null values should be treated as gaps or connected.
         When the value is a number, it represents the maximum delta in the
         X axis that should be considered connected.  For timeseries, this is milliseconds
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.span_nulls = span_nulls
+        self._internal.field_config.defaults.custom.span_nulls = span_nulls
     
         return self
     
     def fill_below_to(self, fill_below_to: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.fill_below_to = fill_below_to
+        self._internal.field_config.defaults.custom.fill_below_to = fill_below_to
     
         return self
     
     def point_symbol(self, point_symbol: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.point_symbol = point_symbol
+        self._internal.field_config.defaults.custom.point_symbol = point_symbol
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
     
     def bar_max_width(self, bar_max_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = trend.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = candlestick.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, trend.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, candlestick.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.bar_max_width = bar_max_width
+        self._internal.field_config.defaults.custom.bar_max_width = bar_max_width
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/builders/xychart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/builders/xychart.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,186 +9,176 @@
 
 
 class Panel(cogbuilder.Builder[dashboard.Panel]):    
     """
     Dashboard panels are the basic visualization building blocks.
     """
     
-    __internal: dashboard.Panel
+    _internal: dashboard.Panel
 
     def __init__(self):
-        self.__internal = dashboard.Panel()        
-        self.__internal.type_val = "xychart"
+        self._internal = dashboard.Panel()        
+        self._internal.type_val = "xychart"
 
     def build(self) -> dashboard.Panel:
-        return self.__internal    
+        return self._internal    
     
     def id_val(self, id_val: int) -> typing.Self:    
         """
         Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
         """
             
-        self.__internal.id_val = id_val
+        self._internal.id_val = id_val
     
         return self
     
     def with_target(self, targets: cogbuilder.Builder[cogvariants.Dataquery]) -> typing.Self:    
         """
         Depends on the panel plugin. See the plugin documentation for details.
         """
             
-        if self.__internal.targets is None:
-            self.__internal.targets = []
+        if self._internal.targets is None:
+            self._internal.targets = []
         
         targets_resource = targets.build()
-        self.__internal.targets.append(targets_resource)
+        self._internal.targets.append(targets_resource)
     
         return self
     
     def title(self, title: str) -> typing.Self:    
         """
         Panel title.
         """
             
-        self.__internal.title = title
+        self._internal.title = title
     
         return self
     
     def description(self, description: str) -> typing.Self:    
         """
         Panel description.
         """
             
-        self.__internal.description = description
+        self._internal.description = description
     
         return self
     
     def transparent(self, transparent: bool) -> typing.Self:    
         """
         Whether to display the panel without a background.
         """
             
-        self.__internal.transparent = transparent
+        self._internal.transparent = transparent
     
         return self
     
     def datasource(self, datasource: dashboard.DataSourceRef) -> typing.Self:    
         """
         The datasource used in all targets.
         """
             
-        self.__internal.datasource = datasource
+        self._internal.datasource = datasource
     
         return self
     
     def height(self, h: int) -> typing.Self:    
         """
         Panel height. The height is the number of rows from the top edge of the panel.
         """
             
         if not h > 0:
             raise ValueError("h must be > 0")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.h = h
+        self._internal.grid_pos.h = h
     
         return self
     
     def span(self, w: int) -> typing.Self:    
         """
         Panel width. The width is the number of columns from the left edge of the panel.
         """
             
         if not w > 0:
             raise ValueError("w must be > 0")
         if not w <= 24:
             raise ValueError("w must be <= 24")
-        if self.__internal.grid_pos is None:
-            self.__internal.grid_pos = dashboard.GridPos()
+        if self._internal.grid_pos is None:
+            self._internal.grid_pos = dashboard.GridPos()
         
-        assert isinstance(self.__internal.grid_pos, dashboard.GridPos)
+        assert isinstance(self._internal.grid_pos, dashboard.GridPos)
         
-        self.__internal.grid_pos.w = w
+        self._internal.grid_pos.w = w
     
         return self
     
     def links(self, links: list[cogbuilder.Builder[dashboard.DashboardLink]]) -> typing.Self:    
         """
         Panel links.
         """
             
         links_resources = [r1.build() for r1 in links]
-        self.__internal.links = links_resources
+        self._internal.links = links_resources
     
         return self
     
     def repeat(self, repeat: str) -> typing.Self:    
         """
         Name of template variable to repeat for.
         """
             
-        self.__internal.repeat = repeat
+        self._internal.repeat = repeat
     
         return self
     
     def repeat_direction(self, repeat_direction: typing.Literal["h", "v"]) -> typing.Self:    
         """
         Direction to repeat in if 'repeat' is set.
         `h` for horizontal, `v` for vertical.
         """
             
-        self.__internal.repeat_direction = repeat_direction
-    
-        return self
-    
-    def max_per_row(self, max_per_row: float) -> typing.Self:    
-        """
-        Option for repeated panels that controls max items per row
-        Only relevant for horizontally repeated panels
-        """
-            
-        self.__internal.max_per_row = max_per_row
+        self._internal.repeat_direction = repeat_direction
     
         return self
     
     def max_data_points(self, max_data_points: float) -> typing.Self:    
         """
         The maximum number of data points that the panel queries are retrieving.
         """
             
-        self.__internal.max_data_points = max_data_points
+        self._internal.max_data_points = max_data_points
     
         return self
     
     def with_transformation(self, transformations: dashboard.DataTransformerConfig) -> typing.Self:    
         """
         List of transformations that are applied to the panel data before rendering.
         When there are multiple transformations, Grafana applies them in the order they are listed.
         Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
         """
             
-        if self.__internal.transformations is None:
-            self.__internal.transformations = []
+        if self._internal.transformations is None:
+            self._internal.transformations = []
         
-        self.__internal.transformations.append(transformations)
+        self._internal.transformations.append(transformations)
     
         return self
     
     def interval(self, interval: str) -> typing.Self:    
         """
         The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
         This value must be formatted as a number followed by a valid time
         identifier like: "40s", "3d", etc.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.interval = interval
+        self._internal.interval = interval
     
         return self
     
     def time_from(self, time_from: str) -> typing.Self:    
         """
         Overrides the relative time range for individual panels,
         which causes them to be different than what is selected in
@@ -196,82 +186,55 @@
         time periods or days on the same dashboard.
         The value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),
         `now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_from = time_from
+        self._internal.time_from = time_from
     
         return self
     
     def time_shift(self, time_shift: str) -> typing.Self:    
         """
         Overrides the time range for individual panels by shifting its start and end relative to the time picker.
         For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
         Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
         See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
         """
             
-        self.__internal.time_shift = time_shift
-    
-        return self
-    
-    def hide_time_override(self, hide_time_override: bool) -> typing.Self:    
-        """
-        Controls if the timeFrom or timeShift overrides are shown in the panel header
-        """
-            
-        self.__internal.hide_time_override = hide_time_override
+        self._internal.time_shift = time_shift
     
         return self
     
     def library_panel(self, library_panel: dashboard.LibraryPanelRef) -> typing.Self:    
         """
         Dynamically load the panel
         """
             
-        self.__internal.library_panel = library_panel
-    
-        return self
-    
-    def cache_timeout(self, cache_timeout: str) -> typing.Self:    
-        """
-        Sets panel queries cache timeout.
-        """
-            
-        self.__internal.cache_timeout = cache_timeout
-    
-        return self
-    
-    def query_caching_ttl(self, query_caching_ttl: float) -> typing.Self:    
-        """
-        Overrides the data source configured time-to-live for a query cache item in milliseconds
-        """
-            
-        self.__internal.query_caching_ttl = query_caching_ttl
+        self._internal.library_panel = library_panel
     
         return self
     
     def display_name(self, display_name: str) -> typing.Self:    
         """
         The display value for this field.  This supports template variables blank is auto
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.display_name = display_name
+        self._internal.field_config.defaults.display_name = display_name
     
         return self
     
     def unit(self, unit: str) -> typing.Self:    
         """
         Unit a field should use. The unit you select is applied to all fields except time.
         You can use the units ID availables in Grafana or a custom unit.
@@ -281,608 +244,580 @@
         `prefix:<prefix>` for custom unit that should go before value.
         `time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.
         `si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
         `count:<unit>` for a custom count unit.
         `currency:<unit>` for custom a currency unit.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.unit = unit
+        self._internal.field_config.defaults.unit = unit
     
         return self
     
     def decimals(self, decimals: float) -> typing.Self:    
         """
         Specify the number of decimals Grafana includes in the rendered value.
         If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
         For example 1.1234 will display as 1.12 and 100.456 will display as 100.
         To display all decimals, set the unit to `String`.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.decimals = decimals
+        self._internal.field_config.defaults.decimals = decimals
     
         return self
     
     def min_val(self, min_val: float) -> typing.Self:    
         """
         The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.min_val = min_val
+        self._internal.field_config.defaults.min_val = min_val
     
         return self
     
     def max_val(self, max_val: float) -> typing.Self:    
         """
         The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.max_val = max_val
+        self._internal.field_config.defaults.max_val = max_val
     
         return self
     
     def mappings(self, mappings: list[dashboard.ValueMapping]) -> typing.Self:    
         """
         Convert input values into a display string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.mappings = mappings
+        self._internal.field_config.defaults.mappings = mappings
     
         return self
     
     def thresholds(self, thresholds: cogbuilder.Builder[dashboard.ThresholdsConfig]) -> typing.Self:    
         """
         Map numeric values to states
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
         thresholds_resource = thresholds.build()
-        self.__internal.field_config.defaults.thresholds = thresholds_resource
+        self._internal.field_config.defaults.thresholds = thresholds_resource
     
         return self
     
     def no_value(self, no_value: str) -> typing.Self:    
         """
         Alternative to empty string
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        self.__internal.field_config.defaults.no_value = no_value
+        self._internal.field_config.defaults.no_value = no_value
     
         return self
     
     def with_override(self, matcher: dashboard.MatcherConfig, properties: list[dashboard.DynamicConfigValue]) -> typing.Self:    
         """
         Overrides are the options applied to specific fields overriding the defaults.
         """
             
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.overrides is None:
-            self.__internal.field_config.overrides = []
+        if self._internal.field_config.overrides is None:
+            self._internal.field_config.overrides = []
         
-        self.__internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
+        self._internal.field_config.overrides.append(dashboard.DashboardFieldConfigSourceOverrides(
             matcher=matcher,
             properties=properties,
         ))
     
         return self
     
     def show(self, show: xychart.ScatterShow) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.show = show
+        self._internal.field_config.defaults.custom.show = show
     
         return self
     
     def point_size(self, point_size: cogbuilder.Builder[common.ScaleDimensionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         point_size_resource = point_size.build()
-        self.__internal.field_config.defaults.custom.point_size = point_size_resource
+        self._internal.field_config.defaults.custom.point_size = point_size_resource
     
         return self
     
     def point_color(self, point_color: cogbuilder.Builder[common.ColorDimensionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         point_color_resource = point_color.build()
-        self.__internal.field_config.defaults.custom.point_color = point_color_resource
+        self._internal.field_config.defaults.custom.point_color = point_color_resource
     
         return self
     
     def line_color(self, line_color: cogbuilder.Builder[common.ColorDimensionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         line_color_resource = line_color.build()
-        self.__internal.field_config.defaults.custom.line_color = line_color_resource
+        self._internal.field_config.defaults.custom.line_color = line_color_resource
     
         return self
     
     def line_width(self, line_width: int) -> typing.Self:        
         if not line_width >= 0:
             raise ValueError("line_width must be >= 0")
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.line_width = line_width
+        self._internal.field_config.defaults.custom.line_width = line_width
     
         return self
     
     def line_style(self, line_style: cogbuilder.Builder[common.LineStyle]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         line_style_resource = line_style.build()
-        self.__internal.field_config.defaults.custom.line_style = line_style_resource
+        self._internal.field_config.defaults.custom.line_style = line_style_resource
     
         return self
     
     def label(self, label: common.VisibilityMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.label = label
+        self._internal.field_config.defaults.custom.label = label
     
         return self
     
     def hide_from(self, hide_from: cogbuilder.Builder[common.HideSeriesConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         hide_from_resource = hide_from.build()
-        self.__internal.field_config.defaults.custom.hide_from = hide_from_resource
+        self._internal.field_config.defaults.custom.hide_from = hide_from_resource
     
         return self
     
     def axis_placement(self, axis_placement: common.AxisPlacement) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_placement = axis_placement
+        self._internal.field_config.defaults.custom.axis_placement = axis_placement
     
         return self
     
     def axis_color_mode(self, axis_color_mode: common.AxisColorMode) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
+        self._internal.field_config.defaults.custom.axis_color_mode = axis_color_mode
     
         return self
     
     def axis_label(self, axis_label: str) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_label = axis_label
+        self._internal.field_config.defaults.custom.axis_label = axis_label
     
         return self
     
     def axis_width(self, axis_width: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_width = axis_width
+        self._internal.field_config.defaults.custom.axis_width = axis_width
     
         return self
     
     def axis_soft_min(self, axis_soft_min: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
+        self._internal.field_config.defaults.custom.axis_soft_min = axis_soft_min
     
         return self
     
     def axis_soft_max(self, axis_soft_max: float) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
+        self._internal.field_config.defaults.custom.axis_soft_max = axis_soft_max
     
         return self
     
     def axis_grid_show(self, axis_grid_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
+        self._internal.field_config.defaults.custom.axis_grid_show = axis_grid_show
     
         return self
     
     def scale_distribution(self, scale_distribution: cogbuilder.Builder[common.ScaleDistributionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         scale_distribution_resource = scale_distribution.build()
-        self.__internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
-    
-        return self
-    
-    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
-        
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
-        
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
-        
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
-        
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
-        
-        self.__internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
+        self._internal.field_config.defaults.custom.scale_distribution = scale_distribution_resource
     
         return self
     
     def label_value(self, label_value: cogbuilder.Builder[common.TextDimensionConfig]) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
         label_value_resource = label_value.build()
-        self.__internal.field_config.defaults.custom.label_value = label_value_resource
+        self._internal.field_config.defaults.custom.label_value = label_value_resource
     
         return self
     
-    def axis_border_show(self, axis_border_show: bool) -> typing.Self:        
-        if self.__internal.field_config is None:
-            self.__internal.field_config = dashboard.FieldConfigSource()
+    def axis_centered_zero(self, axis_centered_zero: bool) -> typing.Self:        
+        if self._internal.field_config is None:
+            self._internal.field_config = dashboard.FieldConfigSource()
         
-        assert isinstance(self.__internal.field_config, dashboard.FieldConfigSource)
+        assert isinstance(self._internal.field_config, dashboard.FieldConfigSource)
         
-        if self.__internal.field_config.defaults is None:
-            self.__internal.field_config.defaults = dashboard.FieldConfig()
+        if self._internal.field_config.defaults is None:
+            self._internal.field_config.defaults = dashboard.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults, dashboard.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults, dashboard.FieldConfig)
         
-        if self.__internal.field_config.defaults.custom is None:
-            self.__internal.field_config.defaults.custom = xychart.FieldConfig()
+        if self._internal.field_config.defaults.custom is None:
+            self._internal.field_config.defaults.custom = xychart.FieldConfig()
         
-        assert isinstance(self.__internal.field_config.defaults.custom, xychart.FieldConfig)
+        assert isinstance(self._internal.field_config.defaults.custom, xychart.FieldConfig)
         
-        self.__internal.field_config.defaults.custom.axis_border_show = axis_border_show
+        self._internal.field_config.defaults.custom.axis_centered_zero = axis_centered_zero
     
         return self
     
     def series_mapping(self, series_mapping: xychart.SeriesMapping) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = xychart.Options()
+        if self._internal.options is None:
+            self._internal.options = xychart.Options()
         
-        assert isinstance(self.__internal.options, xychart.Options)
+        assert isinstance(self._internal.options, xychart.Options)
         
-        self.__internal.options.series_mapping = series_mapping
+        self._internal.options.series_mapping = series_mapping
     
         return self
     
-    def dims(self, dims: xychart.XYDimensionConfig) -> typing.Self:    
-        """
-        Table Mode (auto)
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = xychart.Options()
+    def dims(self, dims: xychart.XYDimensionConfig) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = xychart.Options()
         
-        assert isinstance(self.__internal.options, xychart.Options)
+        assert isinstance(self._internal.options, xychart.Options)
         
-        self.__internal.options.dims = dims
+        self._internal.options.dims = dims
     
         return self
     
     def legend(self, legend: cogbuilder.Builder[common.VizLegendOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = xychart.Options()
+        if self._internal.options is None:
+            self._internal.options = xychart.Options()
         
-        assert isinstance(self.__internal.options, xychart.Options)
+        assert isinstance(self._internal.options, xychart.Options)
         
         legend_resource = legend.build()
-        self.__internal.options.legend = legend_resource
+        self._internal.options.legend = legend_resource
     
         return self
     
     def tooltip(self, tooltip: cogbuilder.Builder[common.VizTooltipOptions]) -> typing.Self:        
-        if self.__internal.options is None:
-            self.__internal.options = xychart.Options()
+        if self._internal.options is None:
+            self._internal.options = xychart.Options()
         
-        assert isinstance(self.__internal.options, xychart.Options)
+        assert isinstance(self._internal.options, xychart.Options)
         
         tooltip_resource = tooltip.build()
-        self.__internal.options.tooltip = tooltip_resource
+        self._internal.options.tooltip = tooltip_resource
     
         return self
     
-    def series(self, series: list[xychart.ScatterSeriesConfig]) -> typing.Self:    
-        """
-        Manual Mode
-        """
-            
-        if self.__internal.options is None:
-            self.__internal.options = xychart.Options()
+    def series(self, series: list[xychart.ScatterSeriesConfig]) -> typing.Self:        
+        if self._internal.options is None:
+            self._internal.options = xychart.Options()
         
-        assert isinstance(self.__internal.options, xychart.Options)
+        assert isinstance(self._internal.options, xychart.Options)
         
-        self.__internal.options.series = series
+        self._internal.options.series = series
     
         return self
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/plugins.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/plugins.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
-from ..models import googlecloudmonitoring
-from ..models import news
-from ..models import statetimeline
-from ..models import xychart
-from ..models import debug
-from ..models import bargauge
 from ..models import barchart
-from ..models import candlestick
-from ..models import text
-from ..models import trend
-from ..models import elasticsearch
-from ..models import heatmap
-from ..models import histogram
 from ..models import prometheus
+from ..models import parca
+from ..models import testdata
+from ..models import text
+from ..models import nodegraph
 from ..models import table
-from ..models import canvas
+from ..models import heatmap
 from ..models import datagrid
-from ..models import grafanapyroscope
-from ..models import statushistory
-from ..models import cloudwatch
+from ..models import elasticsearch
+from ..models import gauge
 from ..models import geomap
-from ..models import nodegraph
-from ..models import annotationslist
-from ..models import loki
+from ..models import piechart
 from ..models import stat
-from ..models import testdata
+from ..models import statushistory
+from ..models import bargauge
+from ..models import grafanapyroscope
+from ..models import logs
+from ..models import loki
+from ..models import news
+from ..models import canvas
+from ..models import tempo
+from ..models import annotationslist
+from ..models import googlecloudmonitoring
+from ..models import histogram
 from ..models import timeseries
+from ..models import alertgroups
 from ..models import azuremonitor
+from ..models import candlestick
+from ..models import cloudwatch
 from ..models import dashboardlist
-from ..models import gauge
-from ..models import logs
-from ..models import parca
-from ..models import piechart
-from ..models import alertgroups
-from ..models import tempo
+from ..models import debug
+from ..models import statetimeline
+from ..models import xychart
+from ..models import trend
 from . import runtime as cogruntime
 
 
 def register_default_plugins():
     # Panelcfg variants
     cogruntime.register_panelcfg_variant(alertgroups.variant_config())
     cogruntime.register_panelcfg_variant(annotationslist.variant_config())
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/cog/runtime.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/cog/runtime.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/accesspolicy.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/accesspolicy.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/alertgroups.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/alertgroups.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/annotationslist.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/annotationslist.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/azuremonitor.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/azuremonitor.py`

 * *Files 2% similar despite different names*

```diff
@@ -312,76 +312,62 @@
 
     # KQL query to be executed.
     query: typing.Optional[str]
     # Specifies the format results should be returned as.
     result_format: typing.Optional['ResultFormat']
     # Array of resource URIs to be queried.
     resources: typing.Optional[list[str]]
-    # If set to true the dashboard time range will be used as a filter for the query. Otherwise the query time ranges will be used. Defaults to false.
-    dashboard_time: typing.Optional[bool]
-    # If dashboardTime is set to true this value dictates which column the time filter will be applied to. Defaults to the first tables timeSpan column, the first datetime column found, or TimeGenerated
-    time_column: typing.Optional[str]
-    # Workspace ID. This was removed in Grafana 8, but remains for backwards compat.
+    # If set to true the intersection of time ranges specified in the query and Grafana will be used. Otherwise the query time ranges will be used. Defaults to false
+    intersect_time: typing.Optional[bool]
+    # Workspace ID. This was removed in Grafana 8, but remains for backwards compat
     workspace: typing.Optional[str]
     # @deprecated Use resources instead
     resource: typing.Optional[str]
-    # @deprecated Use dashboardTime instead
-    intersect_time: typing.Optional[bool]
 
-    def __init__(self, query: typing.Optional[str] = None, result_format: typing.Optional['ResultFormat'] = None, resources: typing.Optional[list[str]] = None, dashboard_time: typing.Optional[bool] = None, time_column: typing.Optional[str] = None, workspace: typing.Optional[str] = None, resource: typing.Optional[str] = None, intersect_time: typing.Optional[bool] = None):
+    def __init__(self, query: typing.Optional[str] = None, result_format: typing.Optional['ResultFormat'] = None, resources: typing.Optional[list[str]] = None, intersect_time: typing.Optional[bool] = None, workspace: typing.Optional[str] = None, resource: typing.Optional[str] = None):
         self.query = query
         self.result_format = result_format
         self.resources = resources
-        self.dashboard_time = dashboard_time
-        self.time_column = time_column
+        self.intersect_time = intersect_time
         self.workspace = workspace
         self.resource = resource
-        self.intersect_time = intersect_time
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.query is not None:
             payload["query"] = self.query
         if self.result_format is not None:
             payload["resultFormat"] = self.result_format
         if self.resources is not None:
             payload["resources"] = self.resources
-        if self.dashboard_time is not None:
-            payload["dashboardTime"] = self.dashboard_time
-        if self.time_column is not None:
-            payload["timeColumn"] = self.time_column
+        if self.intersect_time is not None:
+            payload["intersectTime"] = self.intersect_time
         if self.workspace is not None:
             payload["workspace"] = self.workspace
         if self.resource is not None:
             payload["resource"] = self.resource
-        if self.intersect_time is not None:
-            payload["intersectTime"] = self.intersect_time
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "query" in data:
             args["query"] = data["query"]
         if "resultFormat" in data:
             args["result_format"] = data["resultFormat"]
         if "resources" in data:
             args["resources"] = data["resources"]
-        if "dashboardTime" in data:
-            args["dashboard_time"] = data["dashboardTime"]
-        if "timeColumn" in data:
-            args["time_column"] = data["timeColumn"]
+        if "intersectTime" in data:
+            args["intersect_time"] = data["intersectTime"]
         if "workspace" in data:
             args["workspace"] = data["workspace"]
         if "resource" in data:
-            args["resource"] = data["resource"]
-        if "intersectTime" in data:
-            args["intersect_time"] = data["intersectTime"]        
+            args["resource"] = data["resource"]        
 
         return cls(**args)
 
 
 class AzureTracesQuery:
     """
     Application Insights Traces sub-query properties
@@ -480,15 +466,14 @@
         return cls(**args)
 
 
 class ResultFormat(enum.StrEnum):
     TABLE = "table"
     TIME_SERIES = "time_series"
     TRACE = "trace"
-    LOGS = "logs"
 
 
 class AzureResourceGraphQuery:
     # Azure Resource Graph KQL query to be executed.
     query: typing.Optional[str]
     # Specifies the format results should be returned as. Defaults to table.
     result_format: typing.Optional[str]
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/barchart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/barchart.py`

 * *Files 3% similar despite different names*

```diff
@@ -128,36 +128,34 @@
     axis_color_mode: typing.Optional[common.AxisColorMode]
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional[common.ScaleDistributionConfig]
-    axis_centered_zero: typing.Optional[bool]
     hide_from: typing.Optional[common.HideSeriesConfig]
     # Threshold rendering
     thresholds_style: typing.Optional[common.GraphThresholdsStyleConfig]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
 
-    def __init__(self, line_width: typing.Optional[int] = 1, fill_opacity: typing.Optional[int] = 80, gradient_mode: typing.Optional[common.GraphGradientMode] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, axis_centered_zero: typing.Optional[bool] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, thresholds_style: typing.Optional[common.GraphThresholdsStyleConfig] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, line_width: typing.Optional[int] = 1, fill_opacity: typing.Optional[int] = 80, gradient_mode: typing.Optional[common.GraphGradientMode] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, thresholds_style: typing.Optional[common.GraphThresholdsStyleConfig] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.line_width = line_width
         self.fill_opacity = fill_opacity
         self.gradient_mode = gradient_mode if gradient_mode is not None else common.GraphGradientMode.NONE
         self.axis_placement = axis_placement
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.hide_from = hide_from
         self.thresholds_style = thresholds_style
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.line_width is not None:
             payload["lineWidth"] = self.line_width
         if self.fill_opacity is not None:
@@ -176,22 +174,20 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.hide_from is not None:
             payload["hideFrom"] = self.hide_from
         if self.thresholds_style is not None:
             payload["thresholdsStyle"] = self.thresholds_style
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "lineWidth" in data:
@@ -212,22 +208,20 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = common.ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "hideFrom" in data:
             args["hide_from"] = common.HideSeriesConfig.from_json(data["hideFrom"])
         if "thresholdsStyle" in data:
             args["thresholds_style"] = common.GraphThresholdsStyleConfig.from_json(data["thresholdsStyle"])
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/bargauge.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/bargauge.py`

 * *Files 27% similar despite different names*

```diff
@@ -4,78 +4,63 @@
 import typing
 from ..cog import runtime as cogruntime
 
 
 class Options:
     display_mode: common.BarGaugeDisplayMode
     value_mode: common.BarGaugeValueMode
-    name_placement: common.BarGaugeNamePlacement
     show_unfilled: bool
-    sizing: common.BarGaugeSizing
     min_viz_width: int
-    min_viz_height: int
     reduce_options: common.ReduceDataOptions
     text: typing.Optional[common.VizTextDisplayOptions]
-    max_viz_height: int
+    min_viz_height: int
     orientation: common.VizOrientation
 
-    def __init__(self, display_mode: typing.Optional[common.BarGaugeDisplayMode] = None, value_mode: typing.Optional[common.BarGaugeValueMode] = None, name_placement: typing.Optional[common.BarGaugeNamePlacement] = None, show_unfilled: bool = True, sizing: typing.Optional[common.BarGaugeSizing] = None, min_viz_width: int = 8, min_viz_height: int = 16, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, max_viz_height: int = 300, orientation: typing.Optional[common.VizOrientation] = None):
+    def __init__(self, display_mode: typing.Optional[common.BarGaugeDisplayMode] = None, value_mode: typing.Optional[common.BarGaugeValueMode] = None, show_unfilled: bool = True, min_viz_width: int = 0, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, min_viz_height: int = 10, orientation: typing.Optional[common.VizOrientation] = None):
         self.display_mode = display_mode if display_mode is not None else common.BarGaugeDisplayMode.GRADIENT
         self.value_mode = value_mode if value_mode is not None else common.BarGaugeValueMode.COLOR
-        self.name_placement = name_placement if name_placement is not None else common.BarGaugeNamePlacement.AUTO
         self.show_unfilled = show_unfilled
-        self.sizing = sizing if sizing is not None else common.BarGaugeSizing.AUTO
         self.min_viz_width = min_viz_width
-        self.min_viz_height = min_viz_height
         self.reduce_options = reduce_options if reduce_options is not None else common.ReduceDataOptions()
         self.text = text
-        self.max_viz_height = max_viz_height
+        self.min_viz_height = min_viz_height
         self.orientation = orientation if orientation is not None else common.VizOrientation.AUTO
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "displayMode": self.display_mode,
             "valueMode": self.value_mode,
-            "namePlacement": self.name_placement,
             "showUnfilled": self.show_unfilled,
-            "sizing": self.sizing,
             "minVizWidth": self.min_viz_width,
-            "minVizHeight": self.min_viz_height,
             "reduceOptions": self.reduce_options,
-            "maxVizHeight": self.max_viz_height,
+            "minVizHeight": self.min_viz_height,
             "orientation": self.orientation,
         }
         if self.text is not None:
             payload["text"] = self.text
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "displayMode" in data:
             args["display_mode"] = data["displayMode"]
         if "valueMode" in data:
             args["value_mode"] = data["valueMode"]
-        if "namePlacement" in data:
-            args["name_placement"] = data["namePlacement"]
         if "showUnfilled" in data:
             args["show_unfilled"] = data["showUnfilled"]
-        if "sizing" in data:
-            args["sizing"] = data["sizing"]
         if "minVizWidth" in data:
             args["min_viz_width"] = data["minVizWidth"]
-        if "minVizHeight" in data:
-            args["min_viz_height"] = data["minVizHeight"]
         if "reduceOptions" in data:
             args["reduce_options"] = common.ReduceDataOptions.from_json(data["reduceOptions"])
         if "text" in data:
             args["text"] = common.VizTextDisplayOptions.from_json(data["text"])
-        if "maxVizHeight" in data:
-            args["max_viz_height"] = data["maxVizHeight"]
+        if "minVizHeight" in data:
+            args["min_viz_height"] = data["minVizHeight"]
         if "orientation" in data:
             args["orientation"] = data["orientation"]        
 
         return cls(**args)
 
 
 def variant_config():
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/candlestick.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/candlestick.py`

 * *Files 4% similar despite different names*

```diff
@@ -114,37 +114,34 @@
     # Sets the color strategy for the candlesticks
     color_strategy: 'ColorStrategy'
     # Map fields to appropriate dimension
     fields: 'CandlestickFieldMap'
     # Set which colors are used when the price movement is up or down
     colors: 'CandlestickColors'
     legend: common.VizLegendOptions
-    tooltip: common.VizTooltipOptions
     # When enabled, all fields will be sent to the graph
     include_all_fields: typing.Optional[bool]
 
-    def __init__(self, mode: typing.Optional['VizDisplayMode'] = None, candle_style: typing.Optional['CandleStyle'] = None, color_strategy: typing.Optional['ColorStrategy'] = None, fields: typing.Optional['CandlestickFieldMap'] = None, colors: typing.Optional['CandlestickColors'] = None, legend: typing.Optional[common.VizLegendOptions] = None, tooltip: typing.Optional[common.VizTooltipOptions] = None, include_all_fields: typing.Optional[bool] = False):
+    def __init__(self, mode: typing.Optional['VizDisplayMode'] = None, candle_style: typing.Optional['CandleStyle'] = None, color_strategy: typing.Optional['ColorStrategy'] = None, fields: typing.Optional['CandlestickFieldMap'] = None, colors: typing.Optional['CandlestickColors'] = None, legend: typing.Optional[common.VizLegendOptions] = None, include_all_fields: typing.Optional[bool] = False):
         self.mode = mode if mode is not None else VizDisplayMode.CANDLES_VOLUME
         self.candle_style = candle_style if candle_style is not None else CandleStyle.CANDLES
         self.color_strategy = color_strategy if color_strategy is not None else ColorStrategy.OPEN_CLOSE
         self.fields = fields if fields is not None else CandlestickFieldMap()
         self.colors = colors if colors is not None else CandlestickColors(down="red", flat="gray", up="green")
         self.legend = legend if legend is not None else common.VizLegendOptions()
-        self.tooltip = tooltip if tooltip is not None else common.VizTooltipOptions()
         self.include_all_fields = include_all_fields
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "mode": self.mode,
             "candleStyle": self.candle_style,
             "colorStrategy": self.color_strategy,
             "fields": self.fields,
             "colors": self.colors,
             "legend": self.legend,
-            "tooltip": self.tooltip,
         }
         if self.include_all_fields is not None:
             payload["includeAllFields"] = self.include_all_fields
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
@@ -158,16 +155,14 @@
             args["color_strategy"] = data["colorStrategy"]
         if "fields" in data:
             args["fields"] = CandlestickFieldMap.from_json(data["fields"])
         if "colors" in data:
             args["colors"] = CandlestickColors.from_json(data["colors"])
         if "legend" in data:
             args["legend"] = common.VizLegendOptions.from_json(data["legend"])
-        if "tooltip" in data:
-            args["tooltip"] = common.VizTooltipOptions.from_json(data["tooltip"])
         if "includeAllFields" in data:
             args["include_all_fields"] = data["includeAllFields"]        
 
         return cls(**args)
 
 
 FieldConfig = common.GraphFieldConfig
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/canvas.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/canvas.py`

 * *Files 1% similar despite different names*

```diff
@@ -172,20 +172,14 @@
             args["color"] = common.ColorDimensionConfig.from_json(data["color"])
         if "width" in data:
             args["width"] = data["width"]        
 
         return cls(**args)
 
 
-class HttpRequestMethod(enum.StrEnum):
-    GET = "GET"
-    POST = "POST"
-    PUT = "PUT"
-
-
 class ConnectionCoordinates:
     x: float
     y: float
 
     def __init__(self, x: float = 0, y: float = 0):
         self.x = x
         self.y = y
@@ -328,51 +322,39 @@
 
 
 class Options:
     # Enable inline editing
     inline_editing: bool
     # Show all available element types
     show_advanced_types: bool
-    # Enable pan and zoom
-    pan_zoom: bool
-    # Enable infinite pan
-    infinite_pan: bool
     # The root element of canvas (frame), where all canvas elements are nested
     # TODO: Figure out how to define a default value for this
     root: 'CanvasOptionsRoot'
 
-    def __init__(self, inline_editing: bool = True, show_advanced_types: bool = True, pan_zoom: bool = True, infinite_pan: bool = True, root: typing.Optional['CanvasOptionsRoot'] = None):
+    def __init__(self, inline_editing: bool = True, show_advanced_types: bool = True, root: typing.Optional['CanvasOptionsRoot'] = None):
         self.inline_editing = inline_editing
         self.show_advanced_types = show_advanced_types
-        self.pan_zoom = pan_zoom
-        self.infinite_pan = infinite_pan
         self.root = root if root is not None else CanvasOptionsRoot()
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "inlineEditing": self.inline_editing,
             "showAdvancedTypes": self.show_advanced_types,
-            "panZoom": self.pan_zoom,
-            "infinitePan": self.infinite_pan,
             "root": self.root,
         }
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "inlineEditing" in data:
             args["inline_editing"] = data["inlineEditing"]
         if "showAdvancedTypes" in data:
             args["show_advanced_types"] = data["showAdvancedTypes"]
-        if "panZoom" in data:
-            args["pan_zoom"] = data["panZoom"]
-        if "infinitePan" in data:
-            args["infinite_pan"] = data["infinitePan"]
         if "root" in data:
             args["root"] = CanvasOptionsRoot.from_json(data["root"])        
 
         return cls(**args)
 
 
 class CanvasOptionsRoot:
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/cloudwatch.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/cloudwatch.py`

 * *Files 0% similar despite different names*

```diff
@@ -330,15 +330,15 @@
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "select" in data:
             args["select"] = QueryEditorFunctionExpression.from_json(data["select"])
         if "from" in data:
-            decoding_map: dict[str, typing.Union[typing.Type[QueryEditorPropertyExpression], typing.Type[QueryEditorFunctionExpression]]] = {"property": QueryEditorPropertyExpression, "function": QueryEditorFunctionExpression}
+            decoding_map: dict[str, typing.Union[typing.Type[QueryEditorFunctionExpression], typing.Type[QueryEditorPropertyExpression]]] = {"function": QueryEditorFunctionExpression, "property": QueryEditorPropertyExpression}
             args["from_val"] = decoding_map[data["from"]["type"]].from_json(data["from"])
         if "where" in data:
             args["where"] = QueryEditorArrayExpression.from_json(data["where"])
         if "groupBy" in data:
             args["group_by"] = QueryEditorArrayExpression.from_json(data["groupBy"])
         if "orderBy" in data:
             args["order_by"] = QueryEditorFunctionExpression.from_json(data["orderBy"])
@@ -896,15 +896,15 @@
         return cls(**args)
 
 
 CloudWatchQuery = typing.Union['CloudWatchMetricsQuery', 'CloudWatchLogsQuery', 'CloudWatchAnnotationQuery']
 
 
 def variant_config() -> cogruntime.DataqueryConfig:
-    decoding_map: dict[str, typing.Union[typing.Type[CloudWatchAnnotationQuery], typing.Type[CloudWatchMetricsQuery], typing.Type[CloudWatchLogsQuery]]] = {"Annotations": CloudWatchAnnotationQuery, "Metrics": CloudWatchMetricsQuery, "Logs": CloudWatchLogsQuery}
+    decoding_map: dict[str, typing.Union[typing.Type[CloudWatchMetricsQuery], typing.Type[CloudWatchLogsQuery], typing.Type[CloudWatchAnnotationQuery]]] = {"Metrics": CloudWatchMetricsQuery, "Logs": CloudWatchLogsQuery, "Annotations": CloudWatchAnnotationQuery}
     return cogruntime.DataqueryConfig(
         identifier="cloudwatch",
         from_json_hook=lambda data: decoding_map[data["queryMode"]].from_json(data),
     )
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/common.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/common.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,13 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
-import enum
 import typing
 from ..cog import variants as cogvariants
 from ..cog import runtime as cogruntime
-
-
-class DataTopic(enum.StrEnum):
-    """
-    A topic is attached to DataFrame metadata in query results.
-    This specifies where the data should be used.
-    """
-
-    SERIES = "series"
-    ANNOTATIONS = "annotations"
-    ALERT_STATES = "alertStates"
+import enum
 
 
 class DataSourceJsonData:
     """
     TODO docs
     """
 
@@ -847,27 +836,25 @@
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional['ScaleDistributionConfig']
     axis_centered_zero: typing.Optional[bool]
-    axis_border_show: typing.Optional[bool]
 
-    def __init__(self, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, axis_centered_zero: typing.Optional[bool] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.axis_placement = axis_placement
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
         self.axis_centered_zero = axis_centered_zero
-        self.axis_border_show = axis_border_show
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.axis_placement is not None:
             payload["axisPlacement"] = self.axis_placement
         if self.axis_color_mode is not None:
@@ -882,16 +869,14 @@
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
         if self.axis_centered_zero is not None:
             payload["axisCenteredZero"] = self.axis_centered_zero
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "axisPlacement" in data:
@@ -907,17 +892,15 @@
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = ScaleDistributionConfig.from_json(data["scaleDistribution"])
         if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
 
 
 class HideSeriesConfig:
     """
     TODO docs
@@ -1037,15 +1020,15 @@
         
         if "hideFrom" in data:
             args["hide_from"] = HideSeriesConfig.from_json(data["hideFrom"])        
 
         return cls(**args)
 
 
-class GraphThresholdsStyleMode(enum.StrEnum):
+class GraphTresholdsStyleMode(enum.StrEnum):
     """
     TODO docs
     """
 
     OFF = "off"
     LINE = "line"
     DASHED = "dashed"
@@ -1056,18 +1039,18 @@
 
 
 class GraphThresholdsStyleConfig:
     """
     TODO docs
     """
 
-    mode: 'GraphThresholdsStyleMode'
+    mode: 'GraphTresholdsStyleMode'
 
-    def __init__(self, mode: typing.Optional['GraphThresholdsStyleMode'] = None):
-        self.mode = mode if mode is not None else GraphThresholdsStyleMode.OFF
+    def __init__(self, mode: typing.Optional['GraphTresholdsStyleMode'] = None):
+        self.mode = mode if mode is not None else GraphTresholdsStyleMode.OFF
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "mode": self.mode,
         }
         return payload
 
@@ -1442,30 +1425,29 @@
     axis_color_mode: typing.Optional['AxisColorMode']
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional['ScaleDistributionConfig']
-    axis_centered_zero: typing.Optional[bool]
     bar_alignment: typing.Optional['BarAlignment']
     bar_width_factor: typing.Optional[float]
     stacking: typing.Optional['StackingConfig']
     hide_from: typing.Optional['HideSeriesConfig']
     transform: typing.Optional['GraphTransform']
     # Indicate if null values should be treated as gaps or connected.
     # When the value is a number, it represents the maximum delta in the
     # X axis that should be considered connected.  For timeseries, this is milliseconds
     span_nulls: typing.Optional[typing.Union[bool, float]]
     fill_below_to: typing.Optional[str]
     point_symbol: typing.Optional[str]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
     bar_max_width: typing.Optional[float]
 
-    def __init__(self, draw_style: typing.Optional['GraphDrawStyle'] = None, gradient_mode: typing.Optional['GraphGradientMode'] = None, thresholds_style: typing.Optional['GraphThresholdsStyleConfig'] = None, line_color: typing.Optional[str] = None, line_width: typing.Optional[float] = None, line_interpolation: typing.Optional['LineInterpolation'] = None, line_style: typing.Optional['LineStyle'] = None, fill_color: typing.Optional[str] = None, fill_opacity: typing.Optional[float] = None, show_points: typing.Optional['VisibilityMode'] = None, point_size: typing.Optional[float] = None, point_color: typing.Optional[str] = None, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, axis_centered_zero: typing.Optional[bool] = None, bar_alignment: typing.Optional['BarAlignment'] = None, bar_width_factor: typing.Optional[float] = None, stacking: typing.Optional['StackingConfig'] = None, hide_from: typing.Optional['HideSeriesConfig'] = None, transform: typing.Optional['GraphTransform'] = None, span_nulls: typing.Optional[typing.Union[bool, float]] = None, fill_below_to: typing.Optional[str] = None, point_symbol: typing.Optional[str] = None, axis_border_show: typing.Optional[bool] = None, bar_max_width: typing.Optional[float] = None):
+    def __init__(self, draw_style: typing.Optional['GraphDrawStyle'] = None, gradient_mode: typing.Optional['GraphGradientMode'] = None, thresholds_style: typing.Optional['GraphThresholdsStyleConfig'] = None, line_color: typing.Optional[str] = None, line_width: typing.Optional[float] = None, line_interpolation: typing.Optional['LineInterpolation'] = None, line_style: typing.Optional['LineStyle'] = None, fill_color: typing.Optional[str] = None, fill_opacity: typing.Optional[float] = None, show_points: typing.Optional['VisibilityMode'] = None, point_size: typing.Optional[float] = None, point_color: typing.Optional[str] = None, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, bar_alignment: typing.Optional['BarAlignment'] = None, bar_width_factor: typing.Optional[float] = None, stacking: typing.Optional['StackingConfig'] = None, hide_from: typing.Optional['HideSeriesConfig'] = None, transform: typing.Optional['GraphTransform'] = None, span_nulls: typing.Optional[typing.Union[bool, float]] = None, fill_below_to: typing.Optional[str] = None, point_symbol: typing.Optional[str] = None, axis_centered_zero: typing.Optional[bool] = None, bar_max_width: typing.Optional[float] = None):
         self.draw_style = draw_style
         self.gradient_mode = gradient_mode
         self.thresholds_style = thresholds_style
         self.line_color = line_color
         self.line_width = line_width
         self.line_interpolation = line_interpolation
         self.line_style = line_style
@@ -1478,24 +1460,23 @@
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.bar_alignment = bar_alignment
         self.bar_width_factor = bar_width_factor
         self.stacking = stacking
         self.hide_from = hide_from
         self.transform = transform
         self.span_nulls = span_nulls
         self.fill_below_to = fill_below_to
         self.point_symbol = point_symbol
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
         self.bar_max_width = bar_max_width
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.draw_style is not None:
             payload["drawStyle"] = self.draw_style
@@ -1533,16 +1514,14 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.bar_alignment is not None:
             payload["barAlignment"] = self.bar_alignment
         if self.bar_width_factor is not None:
             payload["barWidthFactor"] = self.bar_width_factor
         if self.stacking is not None:
             payload["stacking"] = self.stacking
         if self.hide_from is not None:
@@ -1551,16 +1530,16 @@
             payload["transform"] = self.transform
         if self.span_nulls is not None:
             payload["spanNulls"] = self.span_nulls
         if self.fill_below_to is not None:
             payload["fillBelowTo"] = self.fill_below_to
         if self.point_symbol is not None:
             payload["pointSymbol"] = self.point_symbol
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.bar_max_width is not None:
             payload["barMaxWidth"] = self.bar_max_width
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
@@ -1601,16 +1580,14 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "barAlignment" in data:
             args["bar_alignment"] = data["barAlignment"]
         if "barWidthFactor" in data:
             args["bar_width_factor"] = data["barWidthFactor"]
         if "stacking" in data:
             args["stacking"] = StackingConfig.from_json(data["stacking"])
         if "hideFrom" in data:
@@ -1619,16 +1596,16 @@
             args["transform"] = data["transform"]
         if "spanNulls" in data:
             args["span_nulls"] = data["spanNulls"]
         if "fillBelowTo" in data:
             args["fill_below_to"] = data["fillBelowTo"]
         if "pointSymbol" in data:
             args["point_symbol"] = data["pointSymbol"]
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "barMaxWidth" in data:
             args["bar_max_width"] = data["barMaxWidth"]        
 
         return cls(**args)
 
 
 class VizLegendOptions:
@@ -1719,72 +1696,41 @@
     """
 
     COLOR = "color"
     TEXT = "text"
     HIDDEN = "hidden"
 
 
-class BarGaugeNamePlacement(enum.StrEnum):
-    """
-    Allows for the bar gauge name to be placed explicitly
-    """
-
-    AUTO = "auto"
-    TOP = "top"
-    LEFT = "left"
-
-
-class BarGaugeSizing(enum.StrEnum):
-    """
-    Allows for the bar gauge size to be set explicitly
-    """
-
-    AUTO = "auto"
-    MANUAL = "manual"
-
-
 class VizTooltipOptions:
     """
     TODO docs
     """
 
     mode: 'TooltipDisplayMode'
     sort: 'SortOrder'
-    max_width: typing.Optional[float]
-    max_height: typing.Optional[float]
 
-    def __init__(self, mode: typing.Optional['TooltipDisplayMode'] = None, sort: typing.Optional['SortOrder'] = None, max_width: typing.Optional[float] = None, max_height: typing.Optional[float] = None):
+    def __init__(self, mode: typing.Optional['TooltipDisplayMode'] = None, sort: typing.Optional['SortOrder'] = None):
         self.mode = mode if mode is not None else TooltipDisplayMode.SINGLE
         self.sort = sort if sort is not None else SortOrder.ASCENDING
-        self.max_width = max_width
-        self.max_height = max_height
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "mode": self.mode,
             "sort": self.sort,
         }
-        if self.max_width is not None:
-            payload["maxWidth"] = self.max_width
-        if self.max_height is not None:
-            payload["maxHeight"] = self.max_height
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "mode" in data:
             args["mode"] = data["mode"]
         if "sort" in data:
-            args["sort"] = data["sort"]
-        if "maxWidth" in data:
-            args["max_width"] = data["maxWidth"]
-        if "maxHeight" in data:
-            args["max_height"] = data["maxHeight"]        
+            args["sort"] = data["sort"]        
 
         return cls(**args)
 
 
 Labels = dict[str, str]
 
 
@@ -1803,15 +1749,14 @@
     GRADIENT_GAUGE = "gradient-gauge"
     LCD_GAUGE = "lcd-gauge"
     JSON_VIEW = "json-view"
     BASIC_GAUGE = "basic"
     IMAGE = "image"
     GAUGE = "gauge"
     SPARKLINE = "sparkline"
-    DATA_LINKS = "data-links"
     CUSTOM = "custom"
 
 
 class TableCellBackgroundDisplayMode(enum.StrEnum):
     """
     Display mode to the "Colored Background" display
     mode for table cells. Either displays a solid color (basic mode)
@@ -1990,36 +1935,14 @@
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         return cls(**args)
 
 
-class TableDataLinksCellOptions:
-    """
-    Show data links in the cell
-    """
-
-    type_val: typing.Literal["data-links"]
-
-    def __init__(self, ):
-        self.type_val = "data-links"
-
-    def to_json(self) -> dict[str, object]:
-        payload: dict[str, object] = {
-            "type": self.type_val,
-        }
-        return payload
-
-    @classmethod
-    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
-        args: dict[str, typing.Any] = {}
-        return cls(**args)
-
-
 class TableBarGaugeCellOptions:
     """
     Gauge cell options
     """
 
     type_val: typing.Literal["gauge"]
     mode: typing.Optional['BarGaugeDisplayMode']
@@ -2074,31 +1997,29 @@
     axis_color_mode: typing.Optional['AxisColorMode']
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional['ScaleDistributionConfig']
-    axis_centered_zero: typing.Optional[bool]
     bar_alignment: typing.Optional['BarAlignment']
     bar_width_factor: typing.Optional[float]
     stacking: typing.Optional['StackingConfig']
     hide_from: typing.Optional['HideSeriesConfig']
-    hide_value: typing.Optional[bool]
     transform: typing.Optional['GraphTransform']
     # Indicate if null values should be treated as gaps or connected.
     # When the value is a number, it represents the maximum delta in the
     # X axis that should be considered connected.  For timeseries, this is milliseconds
     span_nulls: typing.Optional[typing.Union[bool, float]]
     fill_below_to: typing.Optional[str]
     point_symbol: typing.Optional[str]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
     bar_max_width: typing.Optional[float]
 
-    def __init__(self, draw_style: typing.Optional['GraphDrawStyle'] = None, gradient_mode: typing.Optional['GraphGradientMode'] = None, thresholds_style: typing.Optional['GraphThresholdsStyleConfig'] = None, line_color: typing.Optional[str] = None, line_width: typing.Optional[float] = None, line_interpolation: typing.Optional['LineInterpolation'] = None, line_style: typing.Optional['LineStyle'] = None, fill_color: typing.Optional[str] = None, fill_opacity: typing.Optional[float] = None, show_points: typing.Optional['VisibilityMode'] = None, point_size: typing.Optional[float] = None, point_color: typing.Optional[str] = None, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, axis_centered_zero: typing.Optional[bool] = None, bar_alignment: typing.Optional['BarAlignment'] = None, bar_width_factor: typing.Optional[float] = None, stacking: typing.Optional['StackingConfig'] = None, hide_from: typing.Optional['HideSeriesConfig'] = None, hide_value: typing.Optional[bool] = None, transform: typing.Optional['GraphTransform'] = None, span_nulls: typing.Optional[typing.Union[bool, float]] = None, fill_below_to: typing.Optional[str] = None, point_symbol: typing.Optional[str] = None, axis_border_show: typing.Optional[bool] = None, bar_max_width: typing.Optional[float] = None):
+    def __init__(self, draw_style: typing.Optional['GraphDrawStyle'] = None, gradient_mode: typing.Optional['GraphGradientMode'] = None, thresholds_style: typing.Optional['GraphThresholdsStyleConfig'] = None, line_color: typing.Optional[str] = None, line_width: typing.Optional[float] = None, line_interpolation: typing.Optional['LineInterpolation'] = None, line_style: typing.Optional['LineStyle'] = None, fill_color: typing.Optional[str] = None, fill_opacity: typing.Optional[float] = None, show_points: typing.Optional['VisibilityMode'] = None, point_size: typing.Optional[float] = None, point_color: typing.Optional[str] = None, axis_placement: typing.Optional['AxisPlacement'] = None, axis_color_mode: typing.Optional['AxisColorMode'] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional['ScaleDistributionConfig'] = None, bar_alignment: typing.Optional['BarAlignment'] = None, bar_width_factor: typing.Optional[float] = None, stacking: typing.Optional['StackingConfig'] = None, hide_from: typing.Optional['HideSeriesConfig'] = None, transform: typing.Optional['GraphTransform'] = None, span_nulls: typing.Optional[typing.Union[bool, float]] = None, fill_below_to: typing.Optional[str] = None, point_symbol: typing.Optional[str] = None, axis_centered_zero: typing.Optional[bool] = None, bar_max_width: typing.Optional[float] = None):
         self.type_val = "sparkline"
         self.draw_style = draw_style
         self.gradient_mode = gradient_mode
         self.thresholds_style = thresholds_style
         self.line_color = line_color
         self.line_width = line_width
         self.line_interpolation = line_interpolation
@@ -2112,25 +2033,23 @@
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.bar_alignment = bar_alignment
         self.bar_width_factor = bar_width_factor
         self.stacking = stacking
         self.hide_from = hide_from
-        self.hide_value = hide_value
         self.transform = transform
         self.span_nulls = span_nulls
         self.fill_below_to = fill_below_to
         self.point_symbol = point_symbol
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
         self.bar_max_width = bar_max_width
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "type": self.type_val,
         }
         if self.draw_style is not None:
@@ -2169,36 +2088,32 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.bar_alignment is not None:
             payload["barAlignment"] = self.bar_alignment
         if self.bar_width_factor is not None:
             payload["barWidthFactor"] = self.bar_width_factor
         if self.stacking is not None:
             payload["stacking"] = self.stacking
         if self.hide_from is not None:
             payload["hideFrom"] = self.hide_from
-        if self.hide_value is not None:
-            payload["hideValue"] = self.hide_value
         if self.transform is not None:
             payload["transform"] = self.transform
         if self.span_nulls is not None:
             payload["spanNulls"] = self.span_nulls
         if self.fill_below_to is not None:
             payload["fillBelowTo"] = self.fill_below_to
         if self.point_symbol is not None:
             payload["pointSymbol"] = self.point_symbol
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.bar_max_width is not None:
             payload["barMaxWidth"] = self.bar_max_width
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
@@ -2239,36 +2154,32 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "barAlignment" in data:
             args["bar_alignment"] = data["barAlignment"]
         if "barWidthFactor" in data:
             args["bar_width_factor"] = data["barWidthFactor"]
         if "stacking" in data:
             args["stacking"] = StackingConfig.from_json(data["stacking"])
         if "hideFrom" in data:
             args["hide_from"] = HideSeriesConfig.from_json(data["hideFrom"])
-        if "hideValue" in data:
-            args["hide_value"] = data["hideValue"]
         if "transform" in data:
             args["transform"] = data["transform"]
         if "spanNulls" in data:
             args["span_nulls"] = data["spanNulls"]
         if "fillBelowTo" in data:
             args["fill_below_to"] = data["fillBelowTo"]
         if "pointSymbol" in data:
             args["point_symbol"] = data["pointSymbol"]
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "barMaxWidth" in data:
             args["bar_max_width"] = data["barMaxWidth"]        
 
         return cls(**args)
 
 
 class TableColoredBackgroundCellOptions:
@@ -2309,15 +2220,15 @@
     SM = "sm"
     MD = "md"
     LG = "lg"
 
 
 # Table cell options. Each cell has a display mode
 # and other potential options for that display.
-TableCellOptions = typing.Union['TableAutoCellOptions', 'TableSparklineCellOptions', 'TableBarGaugeCellOptions', 'TableColoredBackgroundCellOptions', 'TableColorTextCellOptions', 'TableImageCellOptions', 'TableDataLinksCellOptions', 'TableJsonViewCellOptions']
+TableCellOptions = typing.Union['TableAutoCellOptions', 'TableSparklineCellOptions', 'TableBarGaugeCellOptions', 'TableColoredBackgroundCellOptions', 'TableColorTextCellOptions', 'TableImageCellOptions', 'TableJsonViewCellOptions']
 
 
 # Use UTC/GMT timezone
 TimeZoneUtc: typing.Literal["utc"] = "utc"
 
 
 # Use the timezone defined by end user web browser
@@ -2542,15 +2453,15 @@
     # This field is deprecated in favor of using cellOptions
     display_mode: typing.Optional['TableCellDisplayMode']
     cell_options: typing.Optional['TableCellOptions']
     # ?? default is missing or false ??
     hidden: typing.Optional[bool]
     inspect: bool
     filterable: typing.Optional[bool]
-    # Hides any header for a column, useful for columns that show some static content or buttons.
+    # Hides any header for a column, usefull for columns that show some static content or buttons.
     hide_header: typing.Optional[bool]
 
     def __init__(self, width: typing.Optional[float] = None, min_width: typing.Optional[float] = None, align: typing.Optional['FieldTextAlignment'] = None, display_mode: typing.Optional['TableCellDisplayMode'] = None, cell_options: typing.Optional['TableCellOptions'] = None, hidden: typing.Optional[bool] = None, inspect: bool = False, filterable: typing.Optional[bool] = None, hide_header: typing.Optional[bool] = None):
         self.width = width
         self.min_width = min_width
         self.align = align if align is not None else FieldTextAlignment.AUTO
         self.display_mode = display_mode
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/dashboard.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/dashboard.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,36 +19,39 @@
     # This property should only be used in dashboards defined by plugins.  It is a quick check
     # to see if the version has changed since the last time.
     revision: typing.Optional[int]
     # ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal
     gnet_id: typing.Optional[str]
     # Tags associated with dashboard.
     tags: typing.Optional[list[str]]
+    # Theme of dashboard.
+    # Default value: dark.
+    style: typing.Literal["light", "dark"]
     # Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc".
     timezone: typing.Optional[str]
     # Whether a dashboard is editable or not.
-    editable: typing.Optional[bool]
+    editable: bool
     # Configuration of dashboard cursor sync behavior.
     # Accepted values are 0 (sync turned off), 1 (shared crosshair), 2 (shared crosshair and tooltip).
-    graph_tooltip: typing.Optional['DashboardCursorSync']
+    graph_tooltip: 'DashboardCursorSync'
     # Time range for dashboard.
     # Accepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.
     time: typing.Optional['DashboardDashboardTime']
     # Configuration of the time picker shown at the top of a dashboard.
-    timepicker: typing.Optional['TimePickerConfig']
+    timepicker: typing.Optional['TimePicker']
     # The month that the fiscal year starts on.  0 = January, 11 = December
     fiscal_year_start_month: typing.Optional[int]
     # When set to true, the dashboard will redraw panels at an interval matching the pixel width.
     # This will keep data "moving left" regardless of the query refresh rate. This setting helps
     # avoid dashboards presenting stale live data
     live_now: typing.Optional[bool]
     # Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".
     week_start: typing.Optional[str]
     # Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".
-    refresh: typing.Optional[str]
+    refresh: typing.Optional[typing.Union[str, typing.Literal[False]]]
     # Version of the JSON schema, incremented each time a Grafana update brings
     # changes to said schema.
     schema_version: int
     # Version of the dashboard, incremented each time the dashboard is updated.
     version: typing.Optional[int]
     # List of dashboard panels
     panels: typing.Optional[list[typing.Union['Panel', 'RowPanel']]]
@@ -60,22 +63,23 @@
     # See https://grafana.com/docs/grafana/latest/dashboards/build-dashboards/annotate-visualizations/
     annotations: 'AnnotationContainer'
     # Links with references to other dashboards or external websites.
     links: typing.Optional[list['DashboardLink']]
     # Snapshot options. They are present only if the dashboard is a snapshot.
     snapshot: typing.Optional['Snapshot']
 
-    def __init__(self, id_val: typing.Optional[int] = None, uid: typing.Optional[str] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, revision: typing.Optional[int] = None, gnet_id: typing.Optional[str] = None, tags: typing.Optional[list[str]] = None, timezone: typing.Optional[str] = "browser", editable: typing.Optional[bool] = True, graph_tooltip: typing.Optional['DashboardCursorSync'] = None, time: typing.Optional['DashboardDashboardTime'] = None, timepicker: typing.Optional['TimePickerConfig'] = None, fiscal_year_start_month: typing.Optional[int] = 0, live_now: typing.Optional[bool] = None, week_start: typing.Optional[str] = None, refresh: typing.Optional[str] = None, schema_version: int = 36, version: typing.Optional[int] = None, panels: typing.Optional[list[typing.Union['Panel', 'RowPanel']]] = None, templating: typing.Optional['DashboardDashboardTemplating'] = None, annotations: typing.Optional['AnnotationContainer'] = None, links: typing.Optional[list['DashboardLink']] = None, snapshot: typing.Optional['Snapshot'] = None):
+    def __init__(self, id_val: typing.Optional[int] = None, uid: typing.Optional[str] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, revision: typing.Optional[int] = None, gnet_id: typing.Optional[str] = None, tags: typing.Optional[list[str]] = None, style: typing.Optional[typing.Literal["light", "dark"]] = None, timezone: typing.Optional[str] = "browser", editable: bool = True, graph_tooltip: typing.Optional['DashboardCursorSync'] = None, time: typing.Optional['DashboardDashboardTime'] = None, timepicker: typing.Optional['TimePicker'] = None, fiscal_year_start_month: typing.Optional[int] = 0, live_now: typing.Optional[bool] = None, week_start: typing.Optional[str] = None, refresh: typing.Optional[typing.Union[str, typing.Literal[False]]] = None, schema_version: int = 36, version: typing.Optional[int] = None, panels: typing.Optional[list[typing.Union['Panel', 'RowPanel']]] = None, templating: typing.Optional['DashboardDashboardTemplating'] = None, annotations: typing.Optional['AnnotationContainer'] = None, links: typing.Optional[list['DashboardLink']] = None, snapshot: typing.Optional['Snapshot'] = None):
         self.id_val = id_val
         self.uid = uid
         self.title = title
         self.description = description
         self.revision = revision
         self.gnet_id = gnet_id
         self.tags = tags
+        self.style = style if style is not None else "dark"
         self.timezone = timezone
         self.editable = editable
         self.graph_tooltip = graph_tooltip if graph_tooltip is not None else DashboardCursorSync.OFF
         self.time = time
         self.timepicker = timepicker
         self.fiscal_year_start_month = fiscal_year_start_month
         self.live_now = live_now
@@ -87,14 +91,17 @@
         self.templating = templating if templating is not None else DashboardDashboardTemplating()
         self.annotations = annotations if annotations is not None else AnnotationContainer()
         self.links = links
         self.snapshot = snapshot
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
+            "style": self.style,
+            "editable": self.editable,
+            "graphTooltip": self.graph_tooltip,
             "schemaVersion": self.schema_version,
             "templating": self.templating,
             "annotations": self.annotations,
         }
         if self.id_val is not None:
             payload["id"] = self.id_val
         if self.uid is not None:
@@ -107,18 +114,14 @@
             payload["revision"] = self.revision
         if self.gnet_id is not None:
             payload["gnetId"] = self.gnet_id
         if self.tags is not None:
             payload["tags"] = self.tags
         if self.timezone is not None:
             payload["timezone"] = self.timezone
-        if self.editable is not None:
-            payload["editable"] = self.editable
-        if self.graph_tooltip is not None:
-            payload["graphTooltip"] = self.graph_tooltip
         if self.time is not None:
             payload["time"] = self.time
         if self.timepicker is not None:
             payload["timepicker"] = self.timepicker
         if self.fiscal_year_start_month is not None:
             payload["fiscalYearStartMonth"] = self.fiscal_year_start_month
         if self.live_now is not None:
@@ -151,24 +154,26 @@
             args["description"] = data["description"]
         if "revision" in data:
             args["revision"] = data["revision"]
         if "gnetId" in data:
             args["gnet_id"] = data["gnetId"]
         if "tags" in data:
             args["tags"] = data["tags"]
+        if "style" in data:
+            args["style"] = data["style"]
         if "timezone" in data:
             args["timezone"] = data["timezone"]
         if "editable" in data:
             args["editable"] = data["editable"]
         if "graphTooltip" in data:
             args["graph_tooltip"] = data["graphTooltip"]
         if "time" in data:
             args["time"] = DashboardDashboardTime.from_json(data["time"])
         if "timepicker" in data:
-            args["timepicker"] = TimePickerConfig.from_json(data["timepicker"])
+            args["timepicker"] = TimePicker.from_json(data["timepicker"])
         if "fiscalYearStartMonth" in data:
             args["fiscal_year_start_month"] = data["fiscalYearStartMonth"]
         if "liveNow" in data:
             args["live_now"] = data["liveNow"]
         if "weekStart" in data:
             args["week_start"] = data["weekStart"]
         if "refresh" in data:
@@ -322,27 +327,24 @@
     icon_color: str
     # Filters to apply when fetching annotations
     filter_val: typing.Optional['AnnotationPanelFilter']
     # TODO.. this should just be a normal query target
     target: typing.Optional['AnnotationTarget']
     # TODO -- this should not exist here, it is based on the --grafana-- datasource
     type_val: typing.Optional[str]
-    # Set to 1 for the standard annotation query all dashboards have by default.
-    built_in: typing.Optional[float]
 
-    def __init__(self, name: str = "", datasource: typing.Optional['DataSourceRef'] = None, enable: bool = True, hide: typing.Optional[bool] = False, icon_color: str = "", filter_val: typing.Optional['AnnotationPanelFilter'] = None, target: typing.Optional['AnnotationTarget'] = None, type_val: typing.Optional[str] = None, built_in: typing.Optional[float] = 0):
+    def __init__(self, name: str = "", datasource: typing.Optional['DataSourceRef'] = None, enable: bool = True, hide: typing.Optional[bool] = False, icon_color: str = "", filter_val: typing.Optional['AnnotationPanelFilter'] = None, target: typing.Optional['AnnotationTarget'] = None, type_val: typing.Optional[str] = None):
         self.name = name
         self.datasource = datasource if datasource is not None else DataSourceRef()
         self.enable = enable
         self.hide = hide
         self.icon_color = icon_color
         self.filter_val = filter_val
         self.target = target
         self.type_val = type_val
-        self.built_in = built_in
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "name": self.name,
             "datasource": self.datasource,
             "enable": self.enable,
             "iconColor": self.icon_color,
@@ -351,16 +353,14 @@
             payload["hide"] = self.hide
         if self.filter_val is not None:
             payload["filter"] = self.filter_val
         if self.target is not None:
             payload["target"] = self.target
         if self.type_val is not None:
             payload["type"] = self.type_val
-        if self.built_in is not None:
-            payload["builtIn"] = self.built_in
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "name" in data:
@@ -374,42 +374,44 @@
         if "iconColor" in data:
             args["icon_color"] = data["iconColor"]
         if "filter" in data:
             args["filter_val"] = AnnotationPanelFilter.from_json(data["filter"])
         if "target" in data:
             args["target"] = AnnotationTarget.from_json(data["target"])
         if "type" in data:
-            args["type_val"] = data["type"]
-        if "builtIn" in data:
-            args["built_in"] = data["builtIn"]        
+            args["type_val"] = data["type"]        
 
         return cls(**args)
 
 
 class VariableModel:
     """
     A variable is a placeholder for a value. You can use variables in metric queries and in panel titles.
     """
 
+    # Unique numeric identifier for the variable.
+    id_val: str
     # Type of variable
     type_val: 'VariableType'
     # Name of variable
     name: str
     # Optional display name
     label: typing.Optional[str]
     # Visibility configuration for the variable
-    hide: typing.Optional['VariableHide']
+    hide: 'VariableHide'
     # Whether the variable value should be managed by URL query params or not
-    skip_url_sync: typing.Optional[bool]
+    skip_url_sync: bool
     # Description of variable. It can be defined but `null`.
     description: typing.Optional[str]
     # Query used to fetch values for a variable
     query: typing.Optional[typing.Union[str, object]]
     # Data source used to fetch values for a variable. It can be defined but `null`.
     datasource: typing.Optional['DataSourceRef']
+    # Format to use while fetching all values from data source, eg: wildcard, glob, regex, pipe, etc.
+    all_format: typing.Optional[str]
     # Shows current selected variable text/value on the dashboard
     current: typing.Optional['VariableOption']
     # Whether multiple values can be selected or not from variable value list
     multi: typing.Optional[bool]
     # Options that can be selected for a variable.
     options: typing.Optional[list['VariableOption']]
     # Options to config when to refresh a variable
@@ -420,49 +422,52 @@
     include_all: typing.Optional[bool]
     # Custom all value
     all_value: typing.Optional[str]
     # Optional field, if you want to extract part of a series name or metric node segment.
     # Named capture groups can be used to separate the display text and value.
     regex: typing.Optional[str]
 
-    def __init__(self, type_val: typing.Optional['VariableType'] = None, name: str = "", label: typing.Optional[str] = None, hide: typing.Optional['VariableHide'] = None, skip_url_sync: typing.Optional[bool] = False, description: typing.Optional[str] = None, query: typing.Optional[typing.Union[str, object]] = None, datasource: typing.Optional['DataSourceRef'] = None, current: typing.Optional['VariableOption'] = None, multi: typing.Optional[bool] = False, options: typing.Optional[list['VariableOption']] = None, refresh: typing.Optional['VariableRefresh'] = None, sort: typing.Optional['VariableSort'] = None, include_all: typing.Optional[bool] = False, all_value: typing.Optional[str] = None, regex: typing.Optional[str] = None):
+    def __init__(self, id_val: str = "00000000-0000-0000-0000-000000000000", type_val: typing.Optional['VariableType'] = None, name: str = "", label: typing.Optional[str] = None, hide: typing.Optional['VariableHide'] = None, skip_url_sync: bool = False, description: typing.Optional[str] = None, query: typing.Optional[typing.Union[str, object]] = None, datasource: typing.Optional['DataSourceRef'] = None, all_format: typing.Optional[str] = None, current: typing.Optional['VariableOption'] = None, multi: typing.Optional[bool] = False, options: typing.Optional[list['VariableOption']] = None, refresh: typing.Optional['VariableRefresh'] = None, sort: typing.Optional['VariableSort'] = None, include_all: typing.Optional[bool] = False, all_value: typing.Optional[str] = None, regex: typing.Optional[str] = None):
+        self.id_val = id_val
         self.type_val = type_val if type_val is not None else VariableType.QUERY
         self.name = name
         self.label = label
-        self.hide = hide
+        self.hide = hide if hide is not None else VariableHide.DONT_HIDE
         self.skip_url_sync = skip_url_sync
         self.description = description
         self.query = query
         self.datasource = datasource
+        self.all_format = all_format
         self.current = current
         self.multi = multi
         self.options = options
         self.refresh = refresh
         self.sort = sort
         self.include_all = include_all
         self.all_value = all_value
         self.regex = regex
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
+            "id": self.id_val,
             "type": self.type_val,
             "name": self.name,
+            "hide": self.hide,
+            "skipUrlSync": self.skip_url_sync,
         }
         if self.label is not None:
             payload["label"] = self.label
-        if self.hide is not None:
-            payload["hide"] = self.hide
-        if self.skip_url_sync is not None:
-            payload["skipUrlSync"] = self.skip_url_sync
         if self.description is not None:
             payload["description"] = self.description
         if self.query is not None:
             payload["query"] = self.query
         if self.datasource is not None:
             payload["datasource"] = self.datasource
+        if self.all_format is not None:
+            payload["allFormat"] = self.all_format
         if self.current is not None:
             payload["current"] = self.current
         if self.multi is not None:
             payload["multi"] = self.multi
         if self.options is not None:
             payload["options"] = self.options
         if self.refresh is not None:
@@ -477,14 +482,16 @@
             payload["regex"] = self.regex
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
+        if "id" in data:
+            args["id_val"] = data["id"]
         if "type" in data:
             args["type_val"] = data["type"]
         if "name" in data:
             args["name"] = data["name"]
         if "label" in data:
             args["label"] = data["label"]
         if "hide" in data:
@@ -493,14 +500,16 @@
             args["skip_url_sync"] = data["skipUrlSync"]
         if "description" in data:
             args["description"] = data["description"]
         if "query" in data:
             args["query"] = data["query"]
         if "datasource" in data:
             args["datasource"] = DataSourceRef.from_json(data["datasource"])
+        if "allFormat" in data:
+            args["all_format"] = data["allFormat"]
         if "current" in data:
             args["current"] = VariableOption.from_json(data["current"])
         if "multi" in data:
             args["multi"] = data["multi"]
         if "options" in data:
             args["options"] = data["options"]
         if "refresh" in data:
@@ -588,27 +597,36 @@
     `0`: No sorting
     `1`: Alphabetical ASC
     `2`: Alphabetical DESC
     `3`: Numerical ASC
     `4`: Numerical DESC
     `5`: Alphabetical Case Insensitive ASC
     `6`: Alphabetical Case Insensitive DESC
-    `7`: Natural ASC
-    `8`: Natural DESC
     """
 
     DISABLED = 0
     ALPHABETICAL_ASC = 1
     ALPHABETICAL_DESC = 2
     NUMERICAL_ASC = 3
     NUMERICAL_DESC = 4
     ALPHABETICAL_CASE_INSENSITIVE_ASC = 5
     ALPHABETICAL_CASE_INSENSITIVE_DESC = 6
-    NATURAL_ASC = 7
-    NATURAL_DESC = 8
+
+
+class LoadingState(enum.StrEnum):
+    """
+    Loading status
+    Accepted values are `NotStarted` (the request is not started), `Loading` (waiting for response), `Streaming` (pulling continuous data), `Done` (response received successfully) or `Error` (failed request).
+    """
+
+    NOT_STARTED = "NotStarted"
+    LOADING = "Loading"
+    STREAMING = "Streaming"
+    DONE = "Done"
+    ERROR = "Error"
 
 
 class DataSourceRef:
     """
     Ref to a DataSource instance
     """
 
@@ -652,27 +670,27 @@
     # Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)
     type_val: 'DashboardLinkType'
     # Icon name to be displayed with the link
     icon: str
     # Tooltip to display when the user hovers their mouse over it
     tooltip: str
     # Link URL. Only required/valid if the type is link
-    url: typing.Optional[str]
+    url: str
     # List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards
     tags: list[str]
     # If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards
     as_dropdown: bool
     # If true, the link will be opened in a new tab
     target_blank: bool
     # If true, includes current template variables values in the link as query params
     include_vars: bool
     # If true, includes current time range in the link as query params
     keep_time: bool
 
-    def __init__(self, title: str = "", type_val: typing.Optional['DashboardLinkType'] = None, icon: str = "", tooltip: str = "", url: typing.Optional[str] = None, tags: typing.Optional[list[str]] = None, as_dropdown: bool = False, target_blank: bool = False, include_vars: bool = False, keep_time: bool = False):
+    def __init__(self, title: str = "", type_val: typing.Optional['DashboardLinkType'] = None, icon: str = "", tooltip: str = "", url: str = "", tags: typing.Optional[list[str]] = None, as_dropdown: bool = False, target_blank: bool = False, include_vars: bool = False, keep_time: bool = False):
         self.title = title
         self.type_val = type_val if type_val is not None else DashboardLinkType.LINK
         self.icon = icon
         self.tooltip = tooltip
         self.url = url
         self.tags = tags if tags is not None else []
         self.as_dropdown = as_dropdown
@@ -682,22 +700,21 @@
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "title": self.title,
             "type": self.type_val,
             "icon": self.icon,
             "tooltip": self.tooltip,
+            "url": self.url,
             "tags": self.tags,
             "asDropdown": self.as_dropdown,
             "targetBlank": self.target_blank,
             "includeVars": self.include_vars,
             "keepTime": self.keep_time,
         }
-        if self.url is not None:
-            payload["url"] = self.url
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "title" in data:
@@ -744,15 +761,14 @@
     `textbox`: Display a free text input field with an optional default value.
     `custom`: Define the variable options manually using a comma-separated list.
     `system`: Variables defined by Grafana. See: https://grafana.com/docs/grafana/latest/dashboards/variables/add-template-variables/#global-variables
     """
 
     QUERY = "query"
     ADHOC = "adhoc"
-    GROUPBY = "groupby"
     CONSTANT = "constant"
     DATASOURCE = "datasource"
     INTERVAL = "interval"
     TEXTBOX = "textbox"
     CUSTOM = "custom"
     SYSTEM = "system"
 
@@ -1190,108 +1206,51 @@
 
     # Unique identifier of transformer
     id_val: str
     # Disabled transformations are skipped
     disabled: typing.Optional[bool]
     # Optional frame matcher. When missing it will be applied to all results
     filter_val: typing.Optional['MatcherConfig']
-    # Where to pull DataFrames from as input to transformation
-    topic: typing.Optional[typing.Literal["series", "annotations", "alertStates"]]
     # Options to be passed to the transformer
     # Valid options depend on the transformer id
     options: object
 
-    def __init__(self, id_val: str = "", disabled: typing.Optional[bool] = None, filter_val: typing.Optional['MatcherConfig'] = None, topic: typing.Optional[typing.Literal["series", "annotations", "alertStates"]] = None, options: object = None):
+    def __init__(self, id_val: str = "", disabled: typing.Optional[bool] = None, filter_val: typing.Optional['MatcherConfig'] = None, options: object = None):
         self.id_val = id_val
         self.disabled = disabled
         self.filter_val = filter_val
-        self.topic = topic
         self.options = options
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "id": self.id_val,
             "options": self.options,
         }
         if self.disabled is not None:
             payload["disabled"] = self.disabled
         if self.filter_val is not None:
             payload["filter"] = self.filter_val
-        if self.topic is not None:
-            payload["topic"] = self.topic
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "id" in data:
             args["id_val"] = data["id"]
         if "disabled" in data:
             args["disabled"] = data["disabled"]
         if "filter" in data:
             args["filter_val"] = MatcherConfig.from_json(data["filter"])
-        if "topic" in data:
-            args["topic"] = data["topic"]
         if "options" in data:
             args["options"] = data["options"]        
 
         return cls(**args)
 
 
-class TimePickerConfig:
-    """
-    Time picker configuration
-    It defines the default config for the time picker and the refresh picker for the specific dashboard.
-    """
-
-    # Whether timepicker is visible or not.
-    hidden: typing.Optional[bool]
-    # Interval options available in the refresh picker dropdown.
-    refresh_intervals: typing.Optional[list[str]]
-    # Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
-    time_options: typing.Optional[list[str]]
-    # Override the now time by entering a time delay. Use this option to accommodate known delays in data aggregation to avoid null values.
-    now_delay: typing.Optional[str]
-
-    def __init__(self, hidden: typing.Optional[bool] = False, refresh_intervals: typing.Optional[list[str]] = None, time_options: typing.Optional[list[str]] = None, now_delay: typing.Optional[str] = None):
-        self.hidden = hidden
-        self.refresh_intervals = refresh_intervals if refresh_intervals is not None else ["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
-        self.time_options = time_options if time_options is not None else ["5m", "15m", "1h", "6h", "12h", "24h", "2d", "7d", "30d"]
-        self.now_delay = now_delay
-
-    def to_json(self) -> dict[str, object]:
-        payload: dict[str, object] = {
-        }
-        if self.hidden is not None:
-            payload["hidden"] = self.hidden
-        if self.refresh_intervals is not None:
-            payload["refresh_intervals"] = self.refresh_intervals
-        if self.time_options is not None:
-            payload["time_options"] = self.time_options
-        if self.now_delay is not None:
-            payload["nowDelay"] = self.now_delay
-        return payload
-
-    @classmethod
-    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
-        args: dict[str, typing.Any] = {}
-        
-        if "hidden" in data:
-            args["hidden"] = data["hidden"]
-        if "refresh_intervals" in data:
-            args["refresh_intervals"] = data["refresh_intervals"]
-        if "time_options" in data:
-            args["time_options"] = data["time_options"]
-        if "nowDelay" in data:
-            args["now_delay"] = data["nowDelay"]        
-
-        return cls(**args)
-
-
 class DashboardCursorSync(enum.IntEnum):
     """
     0 for no shared crosshair or tooltip (default).
     1 for shared crosshair.
     2 for shared crosshair AND shared tooltip.
     """
 
@@ -1313,16 +1272,14 @@
     created: str
     # Time when the snapshot expires, default is never to expire
     expires: str
     # Is the snapshot saved in an external grafana instance
     external: bool
     # external url, if snapshot was shared in external grafana instance
     external_url: str
-    # original url, url of the dashboard that was snapshotted
-    original_url: str
     # Unique identifier of the snapshot
     id_val: int
     # Optional, defined the unique key of the snapshot, required if external is true
     key: str
     # Optional, name of the snapshot
     name: str
     # org id of the snapshot
@@ -1330,35 +1287,33 @@
     # last time when the snapshot was updated
     updated: str
     # url of the snapshot, if snapshot was shared internally
     url: typing.Optional[str]
     # user id of the snapshot creator
     user_id: int
 
-    def __init__(self, created: str = "", expires: str = "", external: bool = False, external_url: str = "", original_url: str = "", id_val: int = 0, key: str = "", name: str = "", org_id: int = 0, updated: str = "", url: typing.Optional[str] = None, user_id: int = 0):
+    def __init__(self, created: str = "", expires: str = "", external: bool = False, external_url: str = "", id_val: int = 0, key: str = "", name: str = "", org_id: int = 0, updated: str = "", url: typing.Optional[str] = None, user_id: int = 0):
         self.created = created
         self.expires = expires
         self.external = external
         self.external_url = external_url
-        self.original_url = original_url
         self.id_val = id_val
         self.key = key
         self.name = name
         self.org_id = org_id
         self.updated = updated
         self.url = url
         self.user_id = user_id
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "created": self.created,
             "expires": self.expires,
             "external": self.external,
             "externalUrl": self.external_url,
-            "originalUrl": self.original_url,
             "id": self.id_val,
             "key": self.key,
             "name": self.name,
             "orgId": self.org_id,
             "updated": self.updated,
             "userId": self.user_id,
         }
@@ -1374,16 +1329,14 @@
             args["created"] = data["created"]
         if "expires" in data:
             args["expires"] = data["expires"]
         if "external" in data:
             args["external"] = data["external"]
         if "externalUrl" in data:
             args["external_url"] = data["externalUrl"]
-        if "originalUrl" in data:
-            args["original_url"] = data["originalUrl"]
         if "id" in data:
             args["id_val"] = data["id"]
         if "key" in data:
             args["key"] = data["key"]
         if "name" in data:
             args["name"] = data["name"]
         if "orgId" in data:
@@ -1405,42 +1358,43 @@
 
     # The panel plugin type id. This is used to find the plugin to display the panel.
     type_val: str
     # Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.
     id_val: typing.Optional[int]
     # The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.
     plugin_version: typing.Optional[str]
+    # Tags for the panel.
+    tags: typing.Optional[list[str]]
     # Depends on the panel plugin. See the plugin documentation for details.
     targets: typing.Optional[list[cogvariants.Dataquery]]
     # Panel title.
     title: typing.Optional[str]
     # Panel description.
     description: typing.Optional[str]
     # Whether to display the panel without a background.
-    transparent: typing.Optional[bool]
+    transparent: bool
     # The datasource used in all targets.
     datasource: typing.Optional['DataSourceRef']
     # Grid position.
     grid_pos: typing.Optional['GridPos']
     # Panel links.
     links: typing.Optional[list['DashboardLink']]
     # Name of template variable to repeat for.
     repeat: typing.Optional[str]
     # Direction to repeat in if 'repeat' is set.
     # `h` for horizontal, `v` for vertical.
     repeat_direction: typing.Optional[typing.Literal["h", "v"]]
-    # Option for repeated panels that controls max items per row
-    # Only relevant for horizontally repeated panels
-    max_per_row: typing.Optional[float]
+    # Id of the repeating panel.
+    repeat_panel_id: typing.Optional[int]
     # The maximum number of data points that the panel queries are retrieving.
     max_data_points: typing.Optional[float]
     # List of transformations that are applied to the panel data before rendering.
     # When there are multiple transformations, Grafana applies them in the order they are listed.
     # Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
-    transformations: typing.Optional[list['DataTransformerConfig']]
+    transformations: list['DataTransformerConfig']
     # The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
     # This value must be formatted as a number followed by a valid time
     # identifier like: "40s", "3d", etc.
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     interval: typing.Optional[str]
     # Overrides the relative time range for individual panels,
     # which causes them to be different than what is selected in
@@ -1452,115 +1406,101 @@
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     time_from: typing.Optional[str]
     # Overrides the time range for individual panels by shifting its start and end relative to the time picker.
     # For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
     # Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     time_shift: typing.Optional[str]
-    # Controls if the timeFrom or timeShift overrides are shown in the panel header
-    hide_time_override: typing.Optional[bool]
     # Dynamically load the panel
     library_panel: typing.Optional['LibraryPanelRef']
-    # Sets panel queries cache timeout.
-    cache_timeout: typing.Optional[str]
-    # Overrides the data source configured time-to-live for a query cache item in milliseconds
-    query_caching_ttl: typing.Optional[float]
     # It depends on the panel plugin. They are specified by the Options field in panel plugin schemas.
-    options: typing.Optional[object]
+    options: object
     # Field options allow you to change how the data is displayed in your visualizations.
-    field_config: typing.Optional['FieldConfigSource']
+    field_config: 'FieldConfigSource'
 
-    def __init__(self, type_val: str = "", id_val: typing.Optional[int] = None, plugin_version: typing.Optional[str] = None, targets: typing.Optional[list[cogvariants.Dataquery]] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, transparent: typing.Optional[bool] = False, datasource: typing.Optional['DataSourceRef'] = None, grid_pos: typing.Optional['GridPos'] = None, links: typing.Optional[list['DashboardLink']] = None, repeat: typing.Optional[str] = None, repeat_direction: typing.Optional[typing.Literal["h", "v"]] = None, max_per_row: typing.Optional[float] = None, max_data_points: typing.Optional[float] = None, transformations: typing.Optional[list['DataTransformerConfig']] = None, interval: typing.Optional[str] = None, time_from: typing.Optional[str] = None, time_shift: typing.Optional[str] = None, hide_time_override: typing.Optional[bool] = None, library_panel: typing.Optional['LibraryPanelRef'] = None, cache_timeout: typing.Optional[str] = None, query_caching_ttl: typing.Optional[float] = None, options: typing.Optional[object] = None, field_config: typing.Optional['FieldConfigSource'] = None):
+    def __init__(self, type_val: str = "", id_val: typing.Optional[int] = None, plugin_version: typing.Optional[str] = None, tags: typing.Optional[list[str]] = None, targets: typing.Optional[list[cogvariants.Dataquery]] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, transparent: bool = False, datasource: typing.Optional['DataSourceRef'] = None, grid_pos: typing.Optional['GridPos'] = None, links: typing.Optional[list['DashboardLink']] = None, repeat: typing.Optional[str] = None, repeat_direction: typing.Optional[typing.Literal["h", "v"]] = None, repeat_panel_id: typing.Optional[int] = None, max_data_points: typing.Optional[float] = None, transformations: typing.Optional[list['DataTransformerConfig']] = None, interval: typing.Optional[str] = None, time_from: typing.Optional[str] = None, time_shift: typing.Optional[str] = None, library_panel: typing.Optional['LibraryPanelRef'] = None, options: object = None, field_config: typing.Optional['FieldConfigSource'] = None):
         self.type_val = type_val
         self.id_val = id_val
         self.plugin_version = plugin_version
+        self.tags = tags
         self.targets = targets
         self.title = title
         self.description = description
         self.transparent = transparent
         self.datasource = datasource
         self.grid_pos = grid_pos
         self.links = links
         self.repeat = repeat
         self.repeat_direction = repeat_direction if repeat_direction is not None else "h"
-        self.max_per_row = max_per_row
+        self.repeat_panel_id = repeat_panel_id
         self.max_data_points = max_data_points
-        self.transformations = transformations
+        self.transformations = transformations if transformations is not None else []
         self.interval = interval
         self.time_from = time_from
         self.time_shift = time_shift
-        self.hide_time_override = hide_time_override
         self.library_panel = library_panel
-        self.cache_timeout = cache_timeout
-        self.query_caching_ttl = query_caching_ttl
         self.options = options
-        self.field_config = field_config
+        self.field_config = field_config if field_config is not None else FieldConfigSource()
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "type": self.type_val,
+            "transparent": self.transparent,
+            "transformations": self.transformations,
+            "options": self.options,
+            "fieldConfig": self.field_config,
         }
         if self.id_val is not None:
             payload["id"] = self.id_val
         if self.plugin_version is not None:
             payload["pluginVersion"] = self.plugin_version
+        if self.tags is not None:
+            payload["tags"] = self.tags
         if self.targets is not None:
             payload["targets"] = self.targets
         if self.title is not None:
             payload["title"] = self.title
         if self.description is not None:
             payload["description"] = self.description
-        if self.transparent is not None:
-            payload["transparent"] = self.transparent
         if self.datasource is not None:
             payload["datasource"] = self.datasource
         if self.grid_pos is not None:
             payload["gridPos"] = self.grid_pos
         if self.links is not None:
             payload["links"] = self.links
         if self.repeat is not None:
             payload["repeat"] = self.repeat
         if self.repeat_direction is not None:
             payload["repeatDirection"] = self.repeat_direction
-        if self.max_per_row is not None:
-            payload["maxPerRow"] = self.max_per_row
+        if self.repeat_panel_id is not None:
+            payload["repeatPanelId"] = self.repeat_panel_id
         if self.max_data_points is not None:
             payload["maxDataPoints"] = self.max_data_points
-        if self.transformations is not None:
-            payload["transformations"] = self.transformations
         if self.interval is not None:
             payload["interval"] = self.interval
         if self.time_from is not None:
             payload["timeFrom"] = self.time_from
         if self.time_shift is not None:
             payload["timeShift"] = self.time_shift
-        if self.hide_time_override is not None:
-            payload["hideTimeOverride"] = self.hide_time_override
         if self.library_panel is not None:
             payload["libraryPanel"] = self.library_panel
-        if self.cache_timeout is not None:
-            payload["cacheTimeout"] = self.cache_timeout
-        if self.query_caching_ttl is not None:
-            payload["queryCachingTTL"] = self.query_caching_ttl
-        if self.options is not None:
-            payload["options"] = self.options
-        if self.field_config is not None:
-            payload["fieldConfig"] = self.field_config
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "type" in data:
             args["type_val"] = data["type"]
         if "id" in data:
             args["id_val"] = data["id"]
         if "pluginVersion" in data:
             args["plugin_version"] = data["pluginVersion"]
+        if "tags" in data:
+            args["tags"] = data["tags"]
         if "targets" in data:
             args["targets"] = [cogruntime.dataquery_from_json(dataquery_json, data["datasource"]["type"] if data.get("datasource") is not None and data["datasource"].get("type", "") != "" else "") for dataquery_json in data["targets"]]
         if "title" in data:
             args["title"] = data["title"]
         if "description" in data:
             args["description"] = data["description"]
         if "transparent" in data:
@@ -1571,34 +1511,28 @@
             args["grid_pos"] = GridPos.from_json(data["gridPos"])
         if "links" in data:
             args["links"] = data["links"]
         if "repeat" in data:
             args["repeat"] = data["repeat"]
         if "repeatDirection" in data:
             args["repeat_direction"] = data["repeatDirection"]
-        if "maxPerRow" in data:
-            args["max_per_row"] = data["maxPerRow"]
+        if "repeatPanelId" in data:
+            args["repeat_panel_id"] = data["repeatPanelId"]
         if "maxDataPoints" in data:
             args["max_data_points"] = data["maxDataPoints"]
         if "transformations" in data:
             args["transformations"] = data["transformations"]
         if "interval" in data:
             args["interval"] = data["interval"]
         if "timeFrom" in data:
             args["time_from"] = data["timeFrom"]
         if "timeShift" in data:
             args["time_shift"] = data["timeShift"]
-        if "hideTimeOverride" in data:
-            args["hide_time_override"] = data["hideTimeOverride"]
         if "libraryPanel" in data:
             args["library_panel"] = LibraryPanelRef.from_json(data["libraryPanel"])
-        if "cacheTimeout" in data:
-            args["cache_timeout"] = data["cacheTimeout"]
-        if "queryCachingTTL" in data:
-            args["query_caching_ttl"] = data["queryCachingTTL"]
         if "options" in data:
             config = cogruntime.panelcfg_config(data.get("type", ""))
             if config is not None and config.options_from_json_hook is not None:
                 args["options"] = config.options_from_json_hook(data["options"])
             else:
                 args["options"] = data["options"]
         if "fieldConfig" in data:
@@ -1967,14 +1901,116 @@
             args["panels"] = data["panels"]
         if "repeat" in data:
             args["repeat"] = data["repeat"]        
 
         return cls(**args)
 
 
+class GraphPanel:
+    """
+    Support for legacy graph panel.
+    @deprecated this a deprecated panel type
+    """
+
+    type_val: typing.Literal["graph"]
+    # @deprecated this is part of deprecated graph panel
+    legend: typing.Optional['DashboardGraphPanelLegend']
+
+    def __init__(self, legend: typing.Optional['DashboardGraphPanelLegend'] = None):
+        self.type_val = "graph"
+        self.legend = legend
+
+    def to_json(self) -> dict[str, object]:
+        payload: dict[str, object] = {
+            "type": self.type_val,
+        }
+        if self.legend is not None:
+            payload["legend"] = self.legend
+        return payload
+
+    @classmethod
+    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
+        args: dict[str, typing.Any] = {}
+        
+        if "legend" in data:
+            args["legend"] = DashboardGraphPanelLegend.from_json(data["legend"])        
+
+        return cls(**args)
+
+
+class HeatmapPanel:
+    """
+    Support for legacy heatmap panel.
+    @deprecated this a deprecated panel type
+    """
+
+    type_val: typing.Literal["heatmap"]
+
+    def __init__(self, ):
+        self.type_val = "heatmap"
+
+    def to_json(self) -> dict[str, object]:
+        payload: dict[str, object] = {
+            "type": self.type_val,
+        }
+        return payload
+
+    @classmethod
+    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
+        args: dict[str, typing.Any] = {}
+        return cls(**args)
+
+
+class TimePicker:
+    # Whether timepicker is visible or not.
+    hidden: bool
+    # Interval options available in the refresh picker dropdown.
+    refresh_intervals: list[str]
+    # Whether timepicker is collapsed or not. Has no effect on provisioned dashboard.
+    collapse: bool
+    # Whether timepicker is enabled or not. Has no effect on provisioned dashboard.
+    enable: bool
+    # Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.
+    time_options: list[str]
+
+    def __init__(self, hidden: bool = False, refresh_intervals: typing.Optional[list[str]] = None, collapse: bool = False, enable: bool = True, time_options: typing.Optional[list[str]] = None):
+        self.hidden = hidden
+        self.refresh_intervals = refresh_intervals if refresh_intervals is not None else ["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
+        self.collapse = collapse
+        self.enable = enable
+        self.time_options = time_options if time_options is not None else ["5m", "15m", "1h", "6h", "12h", "24h", "2d", "7d", "30d"]
+
+    def to_json(self) -> dict[str, object]:
+        payload: dict[str, object] = {
+            "hidden": self.hidden,
+            "refresh_intervals": self.refresh_intervals,
+            "collapse": self.collapse,
+            "enable": self.enable,
+            "time_options": self.time_options,
+        }
+        return payload
+
+    @classmethod
+    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
+        args: dict[str, typing.Any] = {}
+        
+        if "hidden" in data:
+            args["hidden"] = data["hidden"]
+        if "refresh_intervals" in data:
+            args["refresh_intervals"] = data["refresh_intervals"]
+        if "collapse" in data:
+            args["collapse"] = data["collapse"]
+        if "enable" in data:
+            args["enable"] = data["enable"]
+        if "time_options" in data:
+            args["time_options"] = data["time_options"]        
+
+        return cls(**args)
+
+
 class DashboardDashboardTime:
     from_val: str
     to: str
 
     def __init__(self, from_val: str = "now-6h", to: str = "now"):
         self.from_val = from_val
         self.to = to
@@ -2138,8 +2174,42 @@
             args["matcher"] = MatcherConfig.from_json(data["matcher"])
         if "properties" in data:
             args["properties"] = data["properties"]        
 
         return cls(**args)
 
 
+class DashboardGraphPanelLegend:
+    show: bool
+    sort: typing.Optional[str]
+    sort_desc: typing.Optional[bool]
+
+    def __init__(self, show: bool = True, sort: typing.Optional[str] = None, sort_desc: typing.Optional[bool] = None):
+        self.show = show
+        self.sort = sort
+        self.sort_desc = sort_desc
+
+    def to_json(self) -> dict[str, object]:
+        payload: dict[str, object] = {
+            "show": self.show,
+        }
+        if self.sort is not None:
+            payload["sort"] = self.sort
+        if self.sort_desc is not None:
+            payload["sortDesc"] = self.sort_desc
+        return payload
+
+    @classmethod
+    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
+        args: dict[str, typing.Any] = {}
+        
+        if "show" in data:
+            args["show"] = data["show"]
+        if "sort" in data:
+            args["sort"] = data["sort"]
+        if "sortDesc" in data:
+            args["sort_desc"] = data["sortDesc"]        
+
+        return cls(**args)
+
+
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/dashboardlist.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/dashboardlist.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,31 +9,28 @@
     include_vars: bool
     show_starred: bool
     show_recently_viewed: bool
     show_search: bool
     show_headings: bool
     max_items: int
     query: str
-    tags: list[str]
-    # folderId is deprecated, and migrated to folderUid on panel init
     folder_id: typing.Optional[int]
-    folder_uid: typing.Optional[str]
+    tags: list[str]
 
-    def __init__(self, keep_time: bool = False, include_vars: bool = False, show_starred: bool = True, show_recently_viewed: bool = False, show_search: bool = False, show_headings: bool = True, max_items: int = 10, query: str = "", tags: typing.Optional[list[str]] = None, folder_id: typing.Optional[int] = None, folder_uid: typing.Optional[str] = None):
+    def __init__(self, keep_time: bool = False, include_vars: bool = False, show_starred: bool = True, show_recently_viewed: bool = False, show_search: bool = False, show_headings: bool = True, max_items: int = 10, query: str = "", folder_id: typing.Optional[int] = None, tags: typing.Optional[list[str]] = None):
         self.keep_time = keep_time
         self.include_vars = include_vars
         self.show_starred = show_starred
         self.show_recently_viewed = show_recently_viewed
         self.show_search = show_search
         self.show_headings = show_headings
         self.max_items = max_items
         self.query = query
-        self.tags = tags if tags is not None else []
         self.folder_id = folder_id
-        self.folder_uid = folder_uid
+        self.tags = tags if tags is not None else []
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "keepTime": self.keep_time,
             "includeVars": self.include_vars,
             "showStarred": self.show_starred,
             "showRecentlyViewed": self.show_recently_viewed,
@@ -41,16 +38,14 @@
             "showHeadings": self.show_headings,
             "maxItems": self.max_items,
             "query": self.query,
             "tags": self.tags,
         }
         if self.folder_id is not None:
             payload["folderId"] = self.folder_id
-        if self.folder_uid is not None:
-            payload["folderUID"] = self.folder_uid
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "keepTime" in data:
@@ -65,20 +60,18 @@
             args["show_search"] = data["showSearch"]
         if "showHeadings" in data:
             args["show_headings"] = data["showHeadings"]
         if "maxItems" in data:
             args["max_items"] = data["maxItems"]
         if "query" in data:
             args["query"] = data["query"]
-        if "tags" in data:
-            args["tags"] = data["tags"]
         if "folderId" in data:
             args["folder_id"] = data["folderId"]
-        if "folderUID" in data:
-            args["folder_uid"] = data["folderUID"]        
+        if "tags" in data:
+            args["tags"] = data["tags"]        
 
         return cls(**args)
 
 
 def variant_config():
     return cogruntime.PanelCfgConfig(
         identifier="dashlist",
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/datagrid.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/datagrid.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/debug.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/debug.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/elasticsearch.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/elasticsearch.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/gauge.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/gauge.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,64 +3,49 @@
 from ..models import common
 import typing
 from ..cog import runtime as cogruntime
 
 
 class Options:
     show_threshold_labels: bool
-    show_threshold_markers: bool
-    sizing: common.BarGaugeSizing
-    min_viz_width: int
     reduce_options: common.ReduceDataOptions
     text: typing.Optional[common.VizTextDisplayOptions]
-    min_viz_height: int
+    show_threshold_markers: bool
     orientation: common.VizOrientation
 
-    def __init__(self, show_threshold_labels: bool = False, show_threshold_markers: bool = True, sizing: typing.Optional[common.BarGaugeSizing] = None, min_viz_width: int = 75, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, min_viz_height: int = 75, orientation: typing.Optional[common.VizOrientation] = None):
+    def __init__(self, show_threshold_labels: bool = False, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, show_threshold_markers: bool = True, orientation: typing.Optional[common.VizOrientation] = None):
         self.show_threshold_labels = show_threshold_labels
-        self.show_threshold_markers = show_threshold_markers
-        self.sizing = sizing if sizing is not None else common.BarGaugeSizing.AUTO
-        self.min_viz_width = min_viz_width
         self.reduce_options = reduce_options if reduce_options is not None else common.ReduceDataOptions()
         self.text = text
-        self.min_viz_height = min_viz_height
+        self.show_threshold_markers = show_threshold_markers
         self.orientation = orientation if orientation is not None else common.VizOrientation.AUTO
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "showThresholdLabels": self.show_threshold_labels,
-            "showThresholdMarkers": self.show_threshold_markers,
-            "sizing": self.sizing,
-            "minVizWidth": self.min_viz_width,
             "reduceOptions": self.reduce_options,
-            "minVizHeight": self.min_viz_height,
+            "showThresholdMarkers": self.show_threshold_markers,
             "orientation": self.orientation,
         }
         if self.text is not None:
             payload["text"] = self.text
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "showThresholdLabels" in data:
             args["show_threshold_labels"] = data["showThresholdLabels"]
-        if "showThresholdMarkers" in data:
-            args["show_threshold_markers"] = data["showThresholdMarkers"]
-        if "sizing" in data:
-            args["sizing"] = data["sizing"]
-        if "minVizWidth" in data:
-            args["min_viz_width"] = data["minVizWidth"]
         if "reduceOptions" in data:
             args["reduce_options"] = common.ReduceDataOptions.from_json(data["reduceOptions"])
         if "text" in data:
             args["text"] = common.VizTextDisplayOptions.from_json(data["text"])
-        if "minVizHeight" in data:
-            args["min_viz_height"] = data["minVizHeight"]
+        if "showThresholdMarkers" in data:
+            args["show_threshold_markers"] = data["showThresholdMarkers"]
         if "orientation" in data:
             args["orientation"] = data["orientation"]        
 
         return cls(**args)
 
 
 def variant_config():
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/geomap.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/geomap.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/googlecloudmonitoring.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/googlecloudmonitoring.py`

 * *Files 10% similar despite different names*

```diff
@@ -24,33 +24,30 @@
     # queryType: #QueryType
     # Time Series List sub-query properties.
     time_series_list: typing.Optional['TimeSeriesList']
     # Time Series sub-query properties.
     time_series_query: typing.Optional['TimeSeriesQuery']
     # SLO sub-query properties.
     slo_query: typing.Optional['SLOQuery']
-    # PromQL sub-query properties.
-    prom_ql_query: typing.Optional['PromQLQuery']
     # For mixed data sources the selected datasource is on the query level.
     # For non mixed scenarios this is undefined.
     # TODO find a better way to do this ^ that's friendly to schema
     # TODO this shouldn't be unknown but DataSourceRef | null
     datasource: typing.Optional[object]
     # Time interval in milliseconds.
     interval_ms: typing.Optional[float]
 
-    def __init__(self, ref_id: str = "", hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, alias_by: typing.Optional[str] = None, time_series_list: typing.Optional['TimeSeriesList'] = None, time_series_query: typing.Optional['TimeSeriesQuery'] = None, slo_query: typing.Optional['SLOQuery'] = None, prom_ql_query: typing.Optional['PromQLQuery'] = None, datasource: typing.Optional[object] = None, interval_ms: typing.Optional[float] = None):
+    def __init__(self, ref_id: str = "", hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, alias_by: typing.Optional[str] = None, time_series_list: typing.Optional['TimeSeriesList'] = None, time_series_query: typing.Optional['TimeSeriesQuery'] = None, slo_query: typing.Optional['SLOQuery'] = None, datasource: typing.Optional[object] = None, interval_ms: typing.Optional[float] = None):
         self.ref_id = ref_id
         self.hide = hide
         self.query_type = query_type
         self.alias_by = alias_by
         self.time_series_list = time_series_list
         self.time_series_query = time_series_query
         self.slo_query = slo_query
-        self.prom_ql_query = prom_ql_query
         self.datasource = datasource
         self.interval_ms = interval_ms
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "refId": self.ref_id,
         }
@@ -62,16 +59,14 @@
             payload["aliasBy"] = self.alias_by
         if self.time_series_list is not None:
             payload["timeSeriesList"] = self.time_series_list
         if self.time_series_query is not None:
             payload["timeSeriesQuery"] = self.time_series_query
         if self.slo_query is not None:
             payload["sloQuery"] = self.slo_query
-        if self.prom_ql_query is not None:
-            payload["promQLQuery"] = self.prom_ql_query
         if self.datasource is not None:
             payload["datasource"] = self.datasource
         if self.interval_ms is not None:
             payload["intervalMs"] = self.interval_ms
         return payload
 
     @classmethod
@@ -88,16 +83,14 @@
             args["alias_by"] = data["aliasBy"]
         if "timeSeriesList" in data:
             args["time_series_list"] = TimeSeriesList.from_json(data["timeSeriesList"])
         if "timeSeriesQuery" in data:
             args["time_series_query"] = TimeSeriesQuery.from_json(data["timeSeriesQuery"])
         if "sloQuery" in data:
             args["slo_query"] = SLOQuery.from_json(data["sloQuery"])
-        if "promQLQuery" in data:
-            args["prom_ql_query"] = PromQLQuery.from_json(data["promQLQuery"])
         if "datasource" in data:
             args["datasource"] = data["datasource"]
         if "intervalMs" in data:
             args["interval_ms"] = data["intervalMs"]        
 
         return cls(**args)
 
@@ -114,15 +107,14 @@
     Defines the supported queryTypes.
     """
 
     TIME_SERIES_LIST = "timeSeriesList"
     TIME_SERIES_QUERY = "timeSeriesQuery"
     SLO = "slo"
     ANNOTATION = "annotation"
-    PROMQL = "promQL"
 
 
 class TimeSeriesList:
     """
     Time Series List sub-query properties.
     """
 
@@ -136,44 +128,44 @@
     per_series_aligner: typing.Optional[str]
     # Array of labels to group data by.
     group_bys: typing.Optional[list[str]]
     # Array of filters to query data by. Labels that can be filtered on are defined by the metric.
     filters: typing.Optional[list[str]]
     # Data view, defaults to FULL.
     view: typing.Optional[str]
-    # Annotation title.
-    title: typing.Optional[str]
-    # Annotation text.
-    text: typing.Optional[str]
     # Only present if a preprocessor is selected. Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
     secondary_cross_series_reducer: typing.Optional[str]
     # Only present if a preprocessor is selected. Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
     secondary_alignment_period: typing.Optional[str]
     # Only present if a preprocessor is selected. Alignment function to be used. Defaults to ALIGN_MEAN.
     secondary_per_series_aligner: typing.Optional[str]
     # Only present if a preprocessor is selected. Array of labels to group data by.
     secondary_group_bys: typing.Optional[list[str]]
     # Preprocessor is not part of the API, but is used to store the preprocessor and not affect the UI for the rest of parameters
     preprocessor: typing.Optional['PreprocessorType']
+    # Annotation title.
+    title: typing.Optional[str]
+    # Annotation text.
+    text: typing.Optional[str]
 
-    def __init__(self, project_name: str = "", cross_series_reducer: str = "", alignment_period: typing.Optional[str] = None, per_series_aligner: typing.Optional[str] = None, group_bys: typing.Optional[list[str]] = None, filters: typing.Optional[list[str]] = None, view: typing.Optional[str] = None, title: typing.Optional[str] = None, text: typing.Optional[str] = None, secondary_cross_series_reducer: typing.Optional[str] = None, secondary_alignment_period: typing.Optional[str] = None, secondary_per_series_aligner: typing.Optional[str] = None, secondary_group_bys: typing.Optional[list[str]] = None, preprocessor: typing.Optional['PreprocessorType'] = None):
+    def __init__(self, project_name: str = "", cross_series_reducer: str = "", alignment_period: typing.Optional[str] = None, per_series_aligner: typing.Optional[str] = None, group_bys: typing.Optional[list[str]] = None, filters: typing.Optional[list[str]] = None, view: typing.Optional[str] = None, secondary_cross_series_reducer: typing.Optional[str] = None, secondary_alignment_period: typing.Optional[str] = None, secondary_per_series_aligner: typing.Optional[str] = None, secondary_group_bys: typing.Optional[list[str]] = None, preprocessor: typing.Optional['PreprocessorType'] = None, title: typing.Optional[str] = None, text: typing.Optional[str] = None):
         self.project_name = project_name
         self.cross_series_reducer = cross_series_reducer
         self.alignment_period = alignment_period
         self.per_series_aligner = per_series_aligner
         self.group_bys = group_bys
         self.filters = filters
         self.view = view
-        self.title = title
-        self.text = text
         self.secondary_cross_series_reducer = secondary_cross_series_reducer
         self.secondary_alignment_period = secondary_alignment_period
         self.secondary_per_series_aligner = secondary_per_series_aligner
         self.secondary_group_bys = secondary_group_bys
         self.preprocessor = preprocessor
+        self.title = title
+        self.text = text
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "projectName": self.project_name,
             "crossSeriesReducer": self.cross_series_reducer,
         }
         if self.alignment_period is not None:
@@ -182,28 +174,28 @@
             payload["perSeriesAligner"] = self.per_series_aligner
         if self.group_bys is not None:
             payload["groupBys"] = self.group_bys
         if self.filters is not None:
             payload["filters"] = self.filters
         if self.view is not None:
             payload["view"] = self.view
-        if self.title is not None:
-            payload["title"] = self.title
-        if self.text is not None:
-            payload["text"] = self.text
         if self.secondary_cross_series_reducer is not None:
             payload["secondaryCrossSeriesReducer"] = self.secondary_cross_series_reducer
         if self.secondary_alignment_period is not None:
             payload["secondaryAlignmentPeriod"] = self.secondary_alignment_period
         if self.secondary_per_series_aligner is not None:
             payload["secondaryPerSeriesAligner"] = self.secondary_per_series_aligner
         if self.secondary_group_bys is not None:
             payload["secondaryGroupBys"] = self.secondary_group_bys
         if self.preprocessor is not None:
             payload["preprocessor"] = self.preprocessor
+        if self.title is not None:
+            payload["title"] = self.title
+        if self.text is not None:
+            payload["text"] = self.text
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "projectName" in data:
@@ -216,42 +208,159 @@
             args["per_series_aligner"] = data["perSeriesAligner"]
         if "groupBys" in data:
             args["group_bys"] = data["groupBys"]
         if "filters" in data:
             args["filters"] = data["filters"]
         if "view" in data:
             args["view"] = data["view"]
-        if "title" in data:
-            args["title"] = data["title"]
-        if "text" in data:
-            args["text"] = data["text"]
         if "secondaryCrossSeriesReducer" in data:
             args["secondary_cross_series_reducer"] = data["secondaryCrossSeriesReducer"]
         if "secondaryAlignmentPeriod" in data:
             args["secondary_alignment_period"] = data["secondaryAlignmentPeriod"]
         if "secondaryPerSeriesAligner" in data:
             args["secondary_per_series_aligner"] = data["secondaryPerSeriesAligner"]
         if "secondaryGroupBys" in data:
             args["secondary_group_bys"] = data["secondaryGroupBys"]
         if "preprocessor" in data:
-            args["preprocessor"] = data["preprocessor"]        
+            args["preprocessor"] = data["preprocessor"]
+        if "title" in data:
+            args["title"] = data["title"]
+        if "text" in data:
+            args["text"] = data["text"]        
 
         return cls(**args)
 
 
 class PreprocessorType(enum.StrEnum):
     """
     Types of pre-processor available. Defined by the metric.
     """
 
     NONE = "none"
     RATE = "rate"
     DELTA = "delta"
 
 
+class AnnotationQuery:
+    """
+    Annotation sub-query properties.
+    """
+
+    # GCP project to execute the query against.
+    project_name: str
+    # Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
+    cross_series_reducer: str
+    # Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
+    alignment_period: typing.Optional[str]
+    # Alignment function to be used. Defaults to ALIGN_MEAN.
+    per_series_aligner: typing.Optional[str]
+    # Array of labels to group data by.
+    group_bys: typing.Optional[list[str]]
+    # Array of filters to query data by. Labels that can be filtered on are defined by the metric.
+    filters: typing.Optional[list[str]]
+    # Data view, defaults to FULL.
+    view: typing.Optional[str]
+    # Only present if a preprocessor is selected. Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.
+    secondary_cross_series_reducer: typing.Optional[str]
+    # Only present if a preprocessor is selected. Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.
+    secondary_alignment_period: typing.Optional[str]
+    # Only present if a preprocessor is selected. Alignment function to be used. Defaults to ALIGN_MEAN.
+    secondary_per_series_aligner: typing.Optional[str]
+    # Only present if a preprocessor is selected. Array of labels to group data by.
+    secondary_group_bys: typing.Optional[list[str]]
+    # Annotation title.
+    title: typing.Optional[str]
+    # Preprocessor is not part of the API, but is used to store the preprocessor and not affect the UI for the rest of parameters
+    preprocessor: typing.Optional['PreprocessorType']
+    # Annotation text.
+    text: typing.Optional[str]
+
+    def __init__(self, project_name: str = "", cross_series_reducer: str = "", alignment_period: typing.Optional[str] = None, per_series_aligner: typing.Optional[str] = None, group_bys: typing.Optional[list[str]] = None, filters: typing.Optional[list[str]] = None, view: typing.Optional[str] = None, secondary_cross_series_reducer: typing.Optional[str] = None, secondary_alignment_period: typing.Optional[str] = None, secondary_per_series_aligner: typing.Optional[str] = None, secondary_group_bys: typing.Optional[list[str]] = None, title: typing.Optional[str] = None, preprocessor: typing.Optional['PreprocessorType'] = None, text: typing.Optional[str] = None):
+        self.project_name = project_name
+        self.cross_series_reducer = cross_series_reducer
+        self.alignment_period = alignment_period
+        self.per_series_aligner = per_series_aligner
+        self.group_bys = group_bys
+        self.filters = filters
+        self.view = view
+        self.secondary_cross_series_reducer = secondary_cross_series_reducer
+        self.secondary_alignment_period = secondary_alignment_period
+        self.secondary_per_series_aligner = secondary_per_series_aligner
+        self.secondary_group_bys = secondary_group_bys
+        self.title = title
+        self.preprocessor = preprocessor
+        self.text = text
+
+    def to_json(self) -> dict[str, object]:
+        payload: dict[str, object] = {
+            "projectName": self.project_name,
+            "crossSeriesReducer": self.cross_series_reducer,
+        }
+        if self.alignment_period is not None:
+            payload["alignmentPeriod"] = self.alignment_period
+        if self.per_series_aligner is not None:
+            payload["perSeriesAligner"] = self.per_series_aligner
+        if self.group_bys is not None:
+            payload["groupBys"] = self.group_bys
+        if self.filters is not None:
+            payload["filters"] = self.filters
+        if self.view is not None:
+            payload["view"] = self.view
+        if self.secondary_cross_series_reducer is not None:
+            payload["secondaryCrossSeriesReducer"] = self.secondary_cross_series_reducer
+        if self.secondary_alignment_period is not None:
+            payload["secondaryAlignmentPeriod"] = self.secondary_alignment_period
+        if self.secondary_per_series_aligner is not None:
+            payload["secondaryPerSeriesAligner"] = self.secondary_per_series_aligner
+        if self.secondary_group_bys is not None:
+            payload["secondaryGroupBys"] = self.secondary_group_bys
+        if self.title is not None:
+            payload["title"] = self.title
+        if self.preprocessor is not None:
+            payload["preprocessor"] = self.preprocessor
+        if self.text is not None:
+            payload["text"] = self.text
+        return payload
+
+    @classmethod
+    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
+        args: dict[str, typing.Any] = {}
+        
+        if "projectName" in data:
+            args["project_name"] = data["projectName"]
+        if "crossSeriesReducer" in data:
+            args["cross_series_reducer"] = data["crossSeriesReducer"]
+        if "alignmentPeriod" in data:
+            args["alignment_period"] = data["alignmentPeriod"]
+        if "perSeriesAligner" in data:
+            args["per_series_aligner"] = data["perSeriesAligner"]
+        if "groupBys" in data:
+            args["group_bys"] = data["groupBys"]
+        if "filters" in data:
+            args["filters"] = data["filters"]
+        if "view" in data:
+            args["view"] = data["view"]
+        if "secondaryCrossSeriesReducer" in data:
+            args["secondary_cross_series_reducer"] = data["secondaryCrossSeriesReducer"]
+        if "secondaryAlignmentPeriod" in data:
+            args["secondary_alignment_period"] = data["secondaryAlignmentPeriod"]
+        if "secondaryPerSeriesAligner" in data:
+            args["secondary_per_series_aligner"] = data["secondaryPerSeriesAligner"]
+        if "secondaryGroupBys" in data:
+            args["secondary_group_bys"] = data["secondaryGroupBys"]
+        if "title" in data:
+            args["title"] = data["title"]
+        if "preprocessor" in data:
+            args["preprocessor"] = data["preprocessor"]
+        if "text" in data:
+            args["text"] = data["text"]        
+
+        return cls(**args)
+
+
 class TimeSeriesQuery:
     """
     Time Series sub-query properties.
     """
 
     # GCP project to execute the query against.
     project_name: str
@@ -369,53 +478,14 @@
             args["goal"] = data["goal"]
         if "lookbackPeriod" in data:
             args["lookback_period"] = data["lookbackPeriod"]        
 
         return cls(**args)
 
 
-class PromQLQuery:
-    """
-    PromQL sub-query properties.
-    """
-
-    # GCP project to execute the query against.
-    project_name: str
-    # PromQL expression/query to be executed.
-    expr: str
-    # PromQL min step
-    step: str
-
-    def __init__(self, project_name: str = "", expr: str = "", step: str = ""):
-        self.project_name = project_name
-        self.expr = expr
-        self.step = step
-
-    def to_json(self) -> dict[str, object]:
-        payload: dict[str, object] = {
-            "projectName": self.project_name,
-            "expr": self.expr,
-            "step": self.step,
-        }
-        return payload
-
-    @classmethod
-    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
-        args: dict[str, typing.Any] = {}
-        
-        if "projectName" in data:
-            args["project_name"] = data["projectName"]
-        if "expr" in data:
-            args["expr"] = data["expr"]
-        if "step" in data:
-            args["step"] = data["step"]        
-
-        return cls(**args)
-
-
 class MetricQuery:
     """
     @deprecated This type is for migration purposes only. Replaced by TimeSeriesList Metric sub-query properties.
     """
 
     # GCP project to execute the query against.
     project_name: str
@@ -565,15 +635,15 @@
     ALIGN_PERCENTILE_05 = "ALIGN_PERCENTILE_05"
     ALIGN_PERCENT_CHANGE = "ALIGN_PERCENT_CHANGE"
     ALIGN_NONE = "ALIGN_NONE"
 
 
 class LegacyCloudMonitoringAnnotationQuery:
     """
-    @deprecated Use TimeSeriesList instead. Legacy annotation query properties for migration purposes.
+    @deprecated Use AnnotationQuery instead. Legacy annotation query properties for migration purposes.
     """
 
     # GCP project to execute the query against.
     project_name: str
     metric_type: str
     # Query refId.
     ref_id: str
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/grafanapyroscope.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/grafanapyroscope.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,49 +2,45 @@
 
 import enum
 from ..cog import variants as cogvariants
 import typing
 from ..cog import runtime as cogruntime
 
 
-class PyroscopeQueryType(enum.StrEnum):
+class PhlareQueryType(enum.StrEnum):
     METRICS = "metrics"
     PROFILE = "profile"
     BOTH = "both"
 
 
 class Dataquery(cogvariants.Dataquery):
     label_selector: typing.Optional[str]
-    span_selector: typing.Optional[list[str]]
     profile_type_id: typing.Optional[str]
     group_by: typing.Optional[list[str]]
     max_nodes: typing.Optional[int]
     ref_id: typing.Optional[str]
     hide: typing.Optional[bool]
     query_type: typing.Optional[str]
     datasource: typing.Optional[object]
 
-    def __init__(self, label_selector: typing.Optional[str] = "{}", span_selector: typing.Optional[list[str]] = None, profile_type_id: typing.Optional[str] = None, group_by: typing.Optional[list[str]] = None, max_nodes: typing.Optional[int] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None):
+    def __init__(self, label_selector: typing.Optional[str] = "{}", profile_type_id: typing.Optional[str] = None, group_by: typing.Optional[list[str]] = None, max_nodes: typing.Optional[int] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None):
         self.label_selector = label_selector
-        self.span_selector = span_selector
         self.profile_type_id = profile_type_id
         self.group_by = group_by
         self.max_nodes = max_nodes
         self.ref_id = ref_id
         self.hide = hide
         self.query_type = query_type
         self.datasource = datasource
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.label_selector is not None:
             payload["labelSelector"] = self.label_selector
-        if self.span_selector is not None:
-            payload["spanSelector"] = self.span_selector
         if self.profile_type_id is not None:
             payload["profileTypeId"] = self.profile_type_id
         if self.group_by is not None:
             payload["groupBy"] = self.group_by
         if self.max_nodes is not None:
             payload["maxNodes"] = self.max_nodes
         if self.ref_id is not None:
@@ -59,16 +55,14 @@
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "labelSelector" in data:
             args["label_selector"] = data["labelSelector"]
-        if "spanSelector" in data:
-            args["span_selector"] = data["spanSelector"]
         if "profileTypeId" in data:
             args["profile_type_id"] = data["profileTypeId"]
         if "groupBy" in data:
             args["group_by"] = data["groupBy"]
         if "maxNodes" in data:
             args["max_nodes"] = data["maxNodes"]
         if "refId" in data:
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/heatmap.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/heatmap.py`

 * *Files 3% similar despite different names*

```diff
@@ -120,35 +120,33 @@
     axis_color_mode: typing.Optional[common.AxisColorMode]
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional[common.ScaleDistributionConfig]
-    axis_centered_zero: typing.Optional[bool]
     # Sets the maximum value for the yAxis
     max_val: typing.Optional[float]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
 
-    def __init__(self, unit: typing.Optional[str] = None, reverse: typing.Optional[bool] = None, decimals: typing.Optional[float] = None, min_val: typing.Optional[float] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, axis_centered_zero: typing.Optional[bool] = None, max_val: typing.Optional[float] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, unit: typing.Optional[str] = None, reverse: typing.Optional[bool] = None, decimals: typing.Optional[float] = None, min_val: typing.Optional[float] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, max_val: typing.Optional[float] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.unit = unit
         self.reverse = reverse
         self.decimals = decimals
         self.min_val = min_val
         self.axis_placement = axis_placement
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.max_val = max_val
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.unit is not None:
             payload["unit"] = self.unit
         if self.reverse is not None:
@@ -169,20 +167,18 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.max_val is not None:
             payload["max"] = self.max_val
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "unit" in data:
@@ -205,20 +201,18 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = common.ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "max" in data:
             args["max_val"] = data["max"]
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
 
 
 class CellValues:
     """
     Controls cell value options
@@ -290,58 +284,39 @@
 
 
 class HeatmapTooltip:
     """
     Controls tooltip options
     """
 
-    # Controls how the tooltip is shown
-    mode: common.TooltipDisplayMode
-    max_height: typing.Optional[float]
-    max_width: typing.Optional[float]
+    # Controls if the tooltip is shown
+    show: bool
     # Controls if the tooltip shows a histogram of the y-axis values
     y_histogram: typing.Optional[bool]
-    # Controls if the tooltip shows a color scale in header
-    show_color_scale: typing.Optional[bool]
 
-    def __init__(self, mode: typing.Optional[common.TooltipDisplayMode] = None, max_height: typing.Optional[float] = None, max_width: typing.Optional[float] = None, y_histogram: typing.Optional[bool] = None, show_color_scale: typing.Optional[bool] = None):
-        self.mode = mode if mode is not None else common.TooltipDisplayMode.SINGLE
-        self.max_height = max_height
-        self.max_width = max_width
+    def __init__(self, show: bool = False, y_histogram: typing.Optional[bool] = None):
+        self.show = show
         self.y_histogram = y_histogram
-        self.show_color_scale = show_color_scale
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
-            "mode": self.mode,
+            "show": self.show,
         }
-        if self.max_height is not None:
-            payload["maxHeight"] = self.max_height
-        if self.max_width is not None:
-            payload["maxWidth"] = self.max_width
         if self.y_histogram is not None:
             payload["yHistogram"] = self.y_histogram
-        if self.show_color_scale is not None:
-            payload["showColorScale"] = self.show_color_scale
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
-        if "mode" in data:
-            args["mode"] = data["mode"]
-        if "maxHeight" in data:
-            args["max_height"] = data["maxHeight"]
-        if "maxWidth" in data:
-            args["max_width"] = data["maxWidth"]
+        if "show" in data:
+            args["show"] = data["show"]
         if "yHistogram" in data:
-            args["y_histogram"] = data["yHistogram"]
-        if "showColorScale" in data:
-            args["show_color_scale"] = data["showColorScale"]        
+            args["y_histogram"] = data["yHistogram"]        
 
         return cls(**args)
 
 
 class HeatmapLegend:
     """
     Controls legend options
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/histogram.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/histogram.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,54 +2,47 @@
 
 import typing
 from ..models import common
 from ..cog import runtime as cogruntime
 
 
 class Options:
-    # Bucket count (approx)
-    bucket_count: typing.Optional[int]
     # Size of each bucket
     bucket_size: typing.Optional[int]
     # Offset buckets by this amount
-    bucket_offset: typing.Optional[float]
+    bucket_offset: typing.Optional[int]
     legend: common.VizLegendOptions
     tooltip: common.VizTooltipOptions
     # Combines multiple series into a single histogram
     combine: typing.Optional[bool]
 
-    def __init__(self, bucket_count: typing.Optional[int] = 30, bucket_size: typing.Optional[int] = None, bucket_offset: typing.Optional[float] = 0, legend: typing.Optional[common.VizLegendOptions] = None, tooltip: typing.Optional[common.VizTooltipOptions] = None, combine: typing.Optional[bool] = None):
-        self.bucket_count = bucket_count
+    def __init__(self, bucket_size: typing.Optional[int] = None, bucket_offset: typing.Optional[int] = 0, legend: typing.Optional[common.VizLegendOptions] = None, tooltip: typing.Optional[common.VizTooltipOptions] = None, combine: typing.Optional[bool] = None):
         self.bucket_size = bucket_size
         self.bucket_offset = bucket_offset
         self.legend = legend if legend is not None else common.VizLegendOptions()
         self.tooltip = tooltip if tooltip is not None else common.VizTooltipOptions()
         self.combine = combine
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "legend": self.legend,
             "tooltip": self.tooltip,
         }
-        if self.bucket_count is not None:
-            payload["bucketCount"] = self.bucket_count
         if self.bucket_size is not None:
             payload["bucketSize"] = self.bucket_size
         if self.bucket_offset is not None:
             payload["bucketOffset"] = self.bucket_offset
         if self.combine is not None:
             payload["combine"] = self.combine
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
-        if "bucketCount" in data:
-            args["bucket_count"] = data["bucketCount"]
         if "bucketSize" in data:
             args["bucket_size"] = data["bucketSize"]
         if "bucketOffset" in data:
             args["bucket_offset"] = data["bucketOffset"]
         if "legend" in data:
             args["legend"] = common.VizLegendOptions.from_json(data["legend"])
         if "tooltip" in data:
@@ -69,36 +62,34 @@
     axis_color_mode: typing.Optional[common.AxisColorMode]
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional[common.ScaleDistributionConfig]
-    axis_centered_zero: typing.Optional[bool]
     hide_from: typing.Optional[common.HideSeriesConfig]
     # Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.
     # Gradient appearance is influenced by the Fill opacity setting.
     gradient_mode: typing.Optional[common.GraphGradientMode]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
 
-    def __init__(self, line_width: typing.Optional[int] = 1, fill_opacity: typing.Optional[int] = 80, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, axis_centered_zero: typing.Optional[bool] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, gradient_mode: typing.Optional[common.GraphGradientMode] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, line_width: typing.Optional[int] = 1, fill_opacity: typing.Optional[int] = 80, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, gradient_mode: typing.Optional[common.GraphGradientMode] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.line_width = line_width
         self.fill_opacity = fill_opacity
         self.axis_placement = axis_placement
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.hide_from = hide_from
         self.gradient_mode = gradient_mode if gradient_mode is not None else common.GraphGradientMode.NONE
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.line_width is not None:
             payload["lineWidth"] = self.line_width
         if self.fill_opacity is not None:
@@ -115,22 +106,20 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.hide_from is not None:
             payload["hideFrom"] = self.hide_from
         if self.gradient_mode is not None:
             payload["gradientMode"] = self.gradient_mode
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "lineWidth" in data:
@@ -149,22 +138,20 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = common.ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "hideFrom" in data:
             args["hide_from"] = common.HideSeriesConfig.from_json(data["hideFrom"])
         if "gradientMode" in data:
             args["gradient_mode"] = data["gradientMode"]
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/librarypanel.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/librarypanel.py`

 * *Files 6% similar despite different names*

```diff
@@ -167,40 +167,41 @@
 
 
 class LibrarypanelLibraryPanelModel:
     # The panel plugin type id. This is used to find the plugin to display the panel.
     type_val: str
     # The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.
     plugin_version: typing.Optional[str]
+    # Tags for the panel.
+    tags: typing.Optional[list[str]]
     # Depends on the panel plugin. See the plugin documentation for details.
     targets: typing.Optional[list[cogvariants.Dataquery]]
     # Panel title.
     title: typing.Optional[str]
     # Panel description.
     description: typing.Optional[str]
     # Whether to display the panel without a background.
-    transparent: typing.Optional[bool]
+    transparent: bool
     # The datasource used in all targets.
     datasource: typing.Optional[dashboard.DataSourceRef]
     # Panel links.
     links: typing.Optional[list[dashboard.DashboardLink]]
     # Name of template variable to repeat for.
     repeat: typing.Optional[str]
     # Direction to repeat in if 'repeat' is set.
     # `h` for horizontal, `v` for vertical.
     repeat_direction: typing.Optional[typing.Literal["h", "v"]]
-    # Option for repeated panels that controls max items per row
-    # Only relevant for horizontally repeated panels
-    max_per_row: typing.Optional[float]
+    # Id of the repeating panel.
+    repeat_panel_id: typing.Optional[int]
     # The maximum number of data points that the panel queries are retrieving.
     max_data_points: typing.Optional[float]
     # List of transformations that are applied to the panel data before rendering.
     # When there are multiple transformations, Grafana applies them in the order they are listed.
     # Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.
-    transformations: typing.Optional[list[dashboard.DataTransformerConfig]]
+    transformations: list[dashboard.DataTransformerConfig]
     # The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
     # This value must be formatted as a number followed by a valid time
     # identifier like: "40s", "3d", etc.
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     interval: typing.Optional[str]
     # Overrides the relative time range for individual panels,
     # which causes them to be different than what is selected in
@@ -212,102 +213,88 @@
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     time_from: typing.Optional[str]
     # Overrides the time range for individual panels by shifting its start and end relative to the time picker.
     # For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.
     # Note: Panel time overrides have no effect when the dashboard’s time range is absolute.
     # See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options
     time_shift: typing.Optional[str]
-    # Controls if the timeFrom or timeShift overrides are shown in the panel header
-    hide_time_override: typing.Optional[bool]
-    # Sets panel queries cache timeout.
-    cache_timeout: typing.Optional[str]
-    # Overrides the data source configured time-to-live for a query cache item in milliseconds
-    query_caching_ttl: typing.Optional[float]
     # It depends on the panel plugin. They are specified by the Options field in panel plugin schemas.
-    options: typing.Optional[object]
+    options: object
     # Field options allow you to change how the data is displayed in your visualizations.
-    field_config: typing.Optional[dashboard.FieldConfigSource]
+    field_config: dashboard.FieldConfigSource
 
-    def __init__(self, type_val: str = "", plugin_version: typing.Optional[str] = None, targets: typing.Optional[list[cogvariants.Dataquery]] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, transparent: typing.Optional[bool] = False, datasource: typing.Optional[dashboard.DataSourceRef] = None, links: typing.Optional[list[dashboard.DashboardLink]] = None, repeat: typing.Optional[str] = None, repeat_direction: typing.Optional[typing.Literal["h", "v"]] = None, max_per_row: typing.Optional[float] = None, max_data_points: typing.Optional[float] = None, transformations: typing.Optional[list[dashboard.DataTransformerConfig]] = None, interval: typing.Optional[str] = None, time_from: typing.Optional[str] = None, time_shift: typing.Optional[str] = None, hide_time_override: typing.Optional[bool] = None, cache_timeout: typing.Optional[str] = None, query_caching_ttl: typing.Optional[float] = None, options: typing.Optional[object] = None, field_config: typing.Optional[dashboard.FieldConfigSource] = None):
+    def __init__(self, type_val: str = "", plugin_version: typing.Optional[str] = None, tags: typing.Optional[list[str]] = None, targets: typing.Optional[list[cogvariants.Dataquery]] = None, title: typing.Optional[str] = None, description: typing.Optional[str] = None, transparent: bool = False, datasource: typing.Optional[dashboard.DataSourceRef] = None, links: typing.Optional[list[dashboard.DashboardLink]] = None, repeat: typing.Optional[str] = None, repeat_direction: typing.Optional[typing.Literal["h", "v"]] = None, repeat_panel_id: typing.Optional[int] = None, max_data_points: typing.Optional[float] = None, transformations: typing.Optional[list[dashboard.DataTransformerConfig]] = None, interval: typing.Optional[str] = None, time_from: typing.Optional[str] = None, time_shift: typing.Optional[str] = None, options: object = None, field_config: typing.Optional[dashboard.FieldConfigSource] = None):
         self.type_val = type_val
         self.plugin_version = plugin_version
+        self.tags = tags
         self.targets = targets
         self.title = title
         self.description = description
         self.transparent = transparent
         self.datasource = datasource
         self.links = links
         self.repeat = repeat
         self.repeat_direction = repeat_direction if repeat_direction is not None else "h"
-        self.max_per_row = max_per_row
+        self.repeat_panel_id = repeat_panel_id
         self.max_data_points = max_data_points
-        self.transformations = transformations
+        self.transformations = transformations if transformations is not None else []
         self.interval = interval
         self.time_from = time_from
         self.time_shift = time_shift
-        self.hide_time_override = hide_time_override
-        self.cache_timeout = cache_timeout
-        self.query_caching_ttl = query_caching_ttl
         self.options = options
-        self.field_config = field_config
+        self.field_config = field_config if field_config is not None else dashboard.FieldConfigSource()
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "type": self.type_val,
+            "transparent": self.transparent,
+            "transformations": self.transformations,
+            "options": self.options,
+            "fieldConfig": self.field_config,
         }
         if self.plugin_version is not None:
             payload["pluginVersion"] = self.plugin_version
+        if self.tags is not None:
+            payload["tags"] = self.tags
         if self.targets is not None:
             payload["targets"] = self.targets
         if self.title is not None:
             payload["title"] = self.title
         if self.description is not None:
             payload["description"] = self.description
-        if self.transparent is not None:
-            payload["transparent"] = self.transparent
         if self.datasource is not None:
             payload["datasource"] = self.datasource
         if self.links is not None:
             payload["links"] = self.links
         if self.repeat is not None:
             payload["repeat"] = self.repeat
         if self.repeat_direction is not None:
             payload["repeatDirection"] = self.repeat_direction
-        if self.max_per_row is not None:
-            payload["maxPerRow"] = self.max_per_row
+        if self.repeat_panel_id is not None:
+            payload["repeatPanelId"] = self.repeat_panel_id
         if self.max_data_points is not None:
             payload["maxDataPoints"] = self.max_data_points
-        if self.transformations is not None:
-            payload["transformations"] = self.transformations
         if self.interval is not None:
             payload["interval"] = self.interval
         if self.time_from is not None:
             payload["timeFrom"] = self.time_from
         if self.time_shift is not None:
             payload["timeShift"] = self.time_shift
-        if self.hide_time_override is not None:
-            payload["hideTimeOverride"] = self.hide_time_override
-        if self.cache_timeout is not None:
-            payload["cacheTimeout"] = self.cache_timeout
-        if self.query_caching_ttl is not None:
-            payload["queryCachingTTL"] = self.query_caching_ttl
-        if self.options is not None:
-            payload["options"] = self.options
-        if self.field_config is not None:
-            payload["fieldConfig"] = self.field_config
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "type" in data:
             args["type_val"] = data["type"]
         if "pluginVersion" in data:
             args["plugin_version"] = data["pluginVersion"]
+        if "tags" in data:
+            args["tags"] = data["tags"]
         if "targets" in data:
             args["targets"] = [cogruntime.dataquery_from_json(dataquery_json, data["datasource"]["type"] if data.get("datasource") is not None and data["datasource"].get("type", "") != "" else "") for dataquery_json in data["targets"]]
         if "title" in data:
             args["title"] = data["title"]
         if "description" in data:
             args["description"] = data["description"]
         if "transparent" in data:
@@ -316,32 +303,26 @@
             args["datasource"] = dashboard.DataSourceRef.from_json(data["datasource"])
         if "links" in data:
             args["links"] = data["links"]
         if "repeat" in data:
             args["repeat"] = data["repeat"]
         if "repeatDirection" in data:
             args["repeat_direction"] = data["repeatDirection"]
-        if "maxPerRow" in data:
-            args["max_per_row"] = data["maxPerRow"]
+        if "repeatPanelId" in data:
+            args["repeat_panel_id"] = data["repeatPanelId"]
         if "maxDataPoints" in data:
             args["max_data_points"] = data["maxDataPoints"]
         if "transformations" in data:
             args["transformations"] = data["transformations"]
         if "interval" in data:
             args["interval"] = data["interval"]
         if "timeFrom" in data:
             args["time_from"] = data["timeFrom"]
         if "timeShift" in data:
             args["time_shift"] = data["timeShift"]
-        if "hideTimeOverride" in data:
-            args["hide_time_override"] = data["hideTimeOverride"]
-        if "cacheTimeout" in data:
-            args["cache_timeout"] = data["cacheTimeout"]
-        if "queryCachingTTL" in data:
-            args["query_caching_ttl"] = data["queryCachingTTL"]
         if "options" in data:
             args["options"] = data["options"]
         if "fieldConfig" in data:
             args["field_config"] = dashboard.FieldConfigSource.from_json(data["fieldConfig"])        
 
         return cls(**args)
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/logs.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/logs.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,38 +5,35 @@
 from ..cog import runtime as cogruntime
 
 
 class Options:
     show_labels: bool
     show_common_labels: bool
     show_time: bool
-    show_log_context_toggle: bool
     wrap_log_message: bool
     prettify_log_message: bool
     enable_log_details: bool
     sort_order: common.LogsSortOrder
     dedup_strategy: common.LogsDedupStrategy
 
-    def __init__(self, show_labels: bool = False, show_common_labels: bool = False, show_time: bool = False, show_log_context_toggle: bool = False, wrap_log_message: bool = False, prettify_log_message: bool = False, enable_log_details: bool = False, sort_order: typing.Optional[common.LogsSortOrder] = None, dedup_strategy: typing.Optional[common.LogsDedupStrategy] = None):
+    def __init__(self, show_labels: bool = False, show_common_labels: bool = False, show_time: bool = False, wrap_log_message: bool = False, prettify_log_message: bool = False, enable_log_details: bool = False, sort_order: typing.Optional[common.LogsSortOrder] = None, dedup_strategy: typing.Optional[common.LogsDedupStrategy] = None):
         self.show_labels = show_labels
         self.show_common_labels = show_common_labels
         self.show_time = show_time
-        self.show_log_context_toggle = show_log_context_toggle
         self.wrap_log_message = wrap_log_message
         self.prettify_log_message = prettify_log_message
         self.enable_log_details = enable_log_details
         self.sort_order = sort_order if sort_order is not None else common.LogsSortOrder.DESCENDING
         self.dedup_strategy = dedup_strategy if dedup_strategy is not None else common.LogsDedupStrategy.NONE
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "showLabels": self.show_labels,
             "showCommonLabels": self.show_common_labels,
             "showTime": self.show_time,
-            "showLogContextToggle": self.show_log_context_toggle,
             "wrapLogMessage": self.wrap_log_message,
             "prettifyLogMessage": self.prettify_log_message,
             "enableLogDetails": self.enable_log_details,
             "sortOrder": self.sort_order,
             "dedupStrategy": self.dedup_strategy,
         }
         return payload
@@ -47,16 +44,14 @@
         
         if "showLabels" in data:
             args["show_labels"] = data["showLabels"]
         if "showCommonLabels" in data:
             args["show_common_labels"] = data["showCommonLabels"]
         if "showTime" in data:
             args["show_time"] = data["showTime"]
-        if "showLogContextToggle" in data:
-            args["show_log_context_toggle"] = data["showLogContextToggle"]
         if "wrapLogMessage" in data:
             args["wrap_log_message"] = data["wrapLogMessage"]
         if "prettifyLogMessage" in data:
             args["prettify_log_message"] = data["prettifyLogMessage"]
         if "enableLogDetails" in data:
             args["enable_log_details"] = data["enableLogDetails"]
         if "sortOrder" in data:
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/loki.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/loki.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,14 @@
     STREAM = "stream"
 
 
 class SupportingQueryType(enum.StrEnum):
     LOGS_VOLUME = "logsVolume"
     LOGS_SAMPLE = "logsSample"
     DATA_SAMPLE = "dataSample"
-    INFINITE_SCROLL = "infiniteScroll"
 
 
 class LokiQueryDirection(enum.StrEnum):
     FORWARD = "forward"
     BACKWARD = "backward"
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/news.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/news.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/nodegraph.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/nodegraph.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/parca.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/parca.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/piechart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/piechart.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/preferences.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/preferences.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,13 @@
 # Code generated - EDITING IS FUTILE. DO NOT EDIT.
 
 import typing
 
 
 class Preferences:
-    """
-    Spec defines user, team or org Grafana preferences
-    swagger:model Preferences
-    """
-
     # UID for the home dashboard
     home_dashboard_uid: typing.Optional[str]
     # The timezone selection
     # TODO: this should use the timezone defined in common
     timezone: typing.Optional[str]
     # day of the week (sunday, monday, etc)
     week_start: typing.Optional[str]
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/prometheus.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/prometheus.py`

 * *Files 14% similar despite different names*

```diff
@@ -22,33 +22,31 @@
     instant: typing.Optional[bool]
     range_val: typing.Optional[bool]
     exemplar: typing.Optional[bool]
     editor_mode: typing.Optional['QueryEditorMode']
     format_val: typing.Optional['PromQueryFormat']
     legend_format: typing.Optional[str]
     interval_factor: typing.Optional[float]
-    scope: typing.Optional['PrometheusDataqueryScope']
     ref_id: typing.Optional[str]
     hide: typing.Optional[bool]
     query_type: typing.Optional[str]
     datasource: typing.Optional[object]
     # An additional lower limit for the step parameter of the Prometheus query and for the
     # `$__interval` and `$__rate_interval` variables.
     interval: typing.Optional[str]
 
-    def __init__(self, expr: typing.Optional[str] = None, instant: typing.Optional[bool] = None, range_val: typing.Optional[bool] = None, exemplar: typing.Optional[bool] = None, editor_mode: typing.Optional['QueryEditorMode'] = None, format_val: typing.Optional['PromQueryFormat'] = None, legend_format: typing.Optional[str] = None, interval_factor: typing.Optional[float] = None, scope: typing.Optional['PrometheusDataqueryScope'] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None, interval: typing.Optional[str] = None):
+    def __init__(self, expr: typing.Optional[str] = None, instant: typing.Optional[bool] = None, range_val: typing.Optional[bool] = None, exemplar: typing.Optional[bool] = None, editor_mode: typing.Optional['QueryEditorMode'] = None, format_val: typing.Optional['PromQueryFormat'] = None, legend_format: typing.Optional[str] = None, interval_factor: typing.Optional[float] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None, interval: typing.Optional[str] = None):
         self.expr = expr
         self.instant = instant
         self.range_val = range_val
         self.exemplar = exemplar
         self.editor_mode = editor_mode
         self.format_val = format_val
         self.legend_format = legend_format
         self.interval_factor = interval_factor
-        self.scope = scope
         self.ref_id = ref_id
         self.hide = hide
         self.query_type = query_type
         self.datasource = datasource
         self.interval = interval
 
     def to_json(self) -> dict[str, object]:
@@ -66,16 +64,14 @@
             payload["editorMode"] = self.editor_mode
         if self.format_val is not None:
             payload["format"] = self.format_val
         if self.legend_format is not None:
             payload["legendFormat"] = self.legend_format
         if self.interval_factor is not None:
             payload["intervalFactor"] = self.interval_factor
-        if self.scope is not None:
-            payload["scope"] = self.scope
         if self.ref_id is not None:
             payload["refId"] = self.ref_id
         if self.hide is not None:
             payload["hide"] = self.hide
         if self.query_type is not None:
             payload["queryType"] = self.query_type
         if self.datasource is not None:
@@ -100,16 +96,14 @@
             args["editor_mode"] = data["editorMode"]
         if "format" in data:
             args["format_val"] = data["format"]
         if "legendFormat" in data:
             args["legend_format"] = data["legendFormat"]
         if "intervalFactor" in data:
             args["interval_factor"] = data["intervalFactor"]
-        if "scope" in data:
-            args["scope"] = PrometheusDataqueryScope.from_json(data["scope"])
         if "refId" in data:
             args["ref_id"] = data["refId"]
         if "hide" in data:
             args["hide"] = data["hide"]
         if "queryType" in data:
             args["query_type"] = data["queryType"]
         if "datasource" in data:
@@ -123,30 +117,8 @@
 def variant_config() -> cogruntime.DataqueryConfig:
     return cogruntime.DataqueryConfig(
         identifier="prometheus",
         from_json_hook=Dataquery.from_json,
     )
 
 
-class PrometheusDataqueryScope:
-    matchers: str
-
-    def __init__(self, matchers: str = ""):
-        self.matchers = matchers
-
-    def to_json(self) -> dict[str, object]:
-        payload: dict[str, object] = {
-            "matchers": self.matchers,
-        }
-        return payload
-
-    @classmethod
-    def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
-        args: dict[str, typing.Any] = {}
-        
-        if "matchers" in data:
-            args["matchers"] = data["matchers"]        
-
-        return cls(**args)
-
-
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/publicdashboard.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/publicdashboard.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/role.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/role.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/rolebinding.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/rolebinding.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/stat.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/stat.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,41 +5,35 @@
 from ..cog import runtime as cogruntime
 
 
 class Options:
     graph_mode: common.BigValueGraphMode
     color_mode: common.BigValueColorMode
     justify_mode: common.BigValueJustifyMode
-    text_mode: common.BigValueTextMode
-    wide_layout: bool
     reduce_options: common.ReduceDataOptions
     text: typing.Optional[common.VizTextDisplayOptions]
-    show_percent_change: bool
+    text_mode: common.BigValueTextMode
     orientation: common.VizOrientation
 
-    def __init__(self, graph_mode: typing.Optional[common.BigValueGraphMode] = None, color_mode: typing.Optional[common.BigValueColorMode] = None, justify_mode: typing.Optional[common.BigValueJustifyMode] = None, text_mode: typing.Optional[common.BigValueTextMode] = None, wide_layout: bool = True, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, show_percent_change: bool = False, orientation: typing.Optional[common.VizOrientation] = None):
+    def __init__(self, graph_mode: typing.Optional[common.BigValueGraphMode] = None, color_mode: typing.Optional[common.BigValueColorMode] = None, justify_mode: typing.Optional[common.BigValueJustifyMode] = None, reduce_options: typing.Optional[common.ReduceDataOptions] = None, text: typing.Optional[common.VizTextDisplayOptions] = None, text_mode: typing.Optional[common.BigValueTextMode] = None, orientation: typing.Optional[common.VizOrientation] = None):
         self.graph_mode = graph_mode if graph_mode is not None else common.BigValueGraphMode.AREA
         self.color_mode = color_mode if color_mode is not None else common.BigValueColorMode.VALUE
         self.justify_mode = justify_mode if justify_mode is not None else common.BigValueJustifyMode.AUTO
-        self.text_mode = text_mode if text_mode is not None else common.BigValueTextMode.AUTO
-        self.wide_layout = wide_layout
         self.reduce_options = reduce_options if reduce_options is not None else common.ReduceDataOptions()
         self.text = text
-        self.show_percent_change = show_percent_change
+        self.text_mode = text_mode if text_mode is not None else common.BigValueTextMode.AUTO
         self.orientation = orientation if orientation is not None else common.VizOrientation.AUTO
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "graphMode": self.graph_mode,
             "colorMode": self.color_mode,
             "justifyMode": self.justify_mode,
-            "textMode": self.text_mode,
-            "wideLayout": self.wide_layout,
             "reduceOptions": self.reduce_options,
-            "showPercentChange": self.show_percent_change,
+            "textMode": self.text_mode,
             "orientation": self.orientation,
         }
         if self.text is not None:
             payload["text"] = self.text
         return payload
 
     @classmethod
@@ -48,24 +42,20 @@
         
         if "graphMode" in data:
             args["graph_mode"] = data["graphMode"]
         if "colorMode" in data:
             args["color_mode"] = data["colorMode"]
         if "justifyMode" in data:
             args["justify_mode"] = data["justifyMode"]
-        if "textMode" in data:
-            args["text_mode"] = data["textMode"]
-        if "wideLayout" in data:
-            args["wide_layout"] = data["wideLayout"]
         if "reduceOptions" in data:
             args["reduce_options"] = common.ReduceDataOptions.from_json(data["reduceOptions"])
         if "text" in data:
             args["text"] = common.VizTextDisplayOptions.from_json(data["text"])
-        if "showPercentChange" in data:
-            args["show_percent_change"] = data["showPercentChange"]
+        if "textMode" in data:
+            args["text_mode"] = data["textMode"]
         if "orientation" in data:
             args["orientation"] = data["orientation"]        
 
         return cls(**args)
 
 
 def variant_config():
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/statetimeline.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/statetimeline.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/statushistory.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/statushistory.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/table.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/table.py`

 * *Files 2% similar despite different names*

```diff
@@ -58,19 +58,13 @@
             args["footer"] = common.TableFooterOptions.from_json(data["footer"])
         if "cellHeight" in data:
             args["cell_height"] = data["cellHeight"]        
 
         return cls(**args)
 
 
-FieldConfig = common.TableFieldOptions
-
-
-
-
-
 def variant_config():
     return cogruntime.PanelCfgConfig(
         identifier="table",
         options_from_json_hook=Options.from_json,
-        field_config_from_json_hook=FieldConfig.from_json,
+        field_config_from_json_hook=None,
     )
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/team.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/team.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/tempo.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/tempo.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,74 +15,64 @@
     # Note this does not always imply that the query should not be executed since
     # the results from a hidden query may be used as the input to other queries (SSE etc)
     hide: typing.Optional[bool]
     # Specify the query flavor
     # TODO make this required and give it a default
     query_type: typing.Optional[str]
     # TraceQL query or trace ID
-    query: typing.Optional[str]
+    query: str
     # @deprecated Logfmt query to filter traces by their tags. Example: http.status_code=200 error=true
     search: typing.Optional[str]
     # @deprecated Query traces by service name
     service_name: typing.Optional[str]
     # @deprecated Query traces by span name
     span_name: typing.Optional[str]
     # @deprecated Define the minimum duration to select traces. Use duration format, for example: 1.2s, 100ms
     min_duration: typing.Optional[str]
     # @deprecated Define the maximum duration to select traces. Use duration format, for example: 1.2s, 100ms
     max_duration: typing.Optional[str]
-    # Filters to be included in a PromQL query to select data for the service graph. Example: {client="app",service="app"}. Providing multiple values will produce union of results for each filter, using PromQL OR operator internally.
-    service_map_query: typing.Optional[typing.Union[str, list[str]]]
+    # Filters to be included in a PromQL query to select data for the service graph. Example: {client="app",service="app"}
+    service_map_query: typing.Optional[str]
     # Use service.namespace in addition to service.name to uniquely identify a service.
     service_map_include_namespace: typing.Optional[bool]
     # Defines the maximum number of traces that are returned from Tempo
     limit: typing.Optional[int]
-    # Defines the maximum number of spans per spanset that are returned from Tempo
-    spss: typing.Optional[int]
-    filters: list['TraceqlFilter']
-    # Filters that are used to query the metrics summary
-    group_by: typing.Optional[list['TraceqlFilter']]
     # For mixed data sources the selected datasource is on the query level.
     # For non mixed scenarios this is undefined.
     # TODO find a better way to do this ^ that's friendly to schema
     # TODO this shouldn't be unknown but DataSourceRef | null
     datasource: typing.Optional[object]
-    # The type of the table that is used to display the search results
-    table_type: typing.Optional['SearchTableType']
+    filters: list['TraceqlFilter']
 
-    def __init__(self, ref_id: str = "", hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, query: typing.Optional[str] = None, search: typing.Optional[str] = None, service_name: typing.Optional[str] = None, span_name: typing.Optional[str] = None, min_duration: typing.Optional[str] = None, max_duration: typing.Optional[str] = None, service_map_query: typing.Optional[typing.Union[str, list[str]]] = None, service_map_include_namespace: typing.Optional[bool] = None, limit: typing.Optional[int] = None, spss: typing.Optional[int] = None, filters: typing.Optional[list['TraceqlFilter']] = None, group_by: typing.Optional[list['TraceqlFilter']] = None, datasource: typing.Optional[object] = None, table_type: typing.Optional['SearchTableType'] = None):
+    def __init__(self, ref_id: str = "", hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, query: str = "", search: typing.Optional[str] = None, service_name: typing.Optional[str] = None, span_name: typing.Optional[str] = None, min_duration: typing.Optional[str] = None, max_duration: typing.Optional[str] = None, service_map_query: typing.Optional[str] = None, service_map_include_namespace: typing.Optional[bool] = None, limit: typing.Optional[int] = None, datasource: typing.Optional[object] = None, filters: typing.Optional[list['TraceqlFilter']] = None):
         self.ref_id = ref_id
         self.hide = hide
         self.query_type = query_type
         self.query = query
         self.search = search
         self.service_name = service_name
         self.span_name = span_name
         self.min_duration = min_duration
         self.max_duration = max_duration
         self.service_map_query = service_map_query
         self.service_map_include_namespace = service_map_include_namespace
         self.limit = limit
-        self.spss = spss
-        self.filters = filters if filters is not None else []
-        self.group_by = group_by
         self.datasource = datasource
-        self.table_type = table_type
+        self.filters = filters if filters is not None else []
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
             "refId": self.ref_id,
+            "query": self.query,
             "filters": self.filters,
         }
         if self.hide is not None:
             payload["hide"] = self.hide
         if self.query_type is not None:
             payload["queryType"] = self.query_type
-        if self.query is not None:
-            payload["query"] = self.query
         if self.search is not None:
             payload["search"] = self.search
         if self.service_name is not None:
             payload["serviceName"] = self.service_name
         if self.span_name is not None:
             payload["spanName"] = self.span_name
         if self.min_duration is not None:
@@ -91,22 +81,16 @@
             payload["maxDuration"] = self.max_duration
         if self.service_map_query is not None:
             payload["serviceMapQuery"] = self.service_map_query
         if self.service_map_include_namespace is not None:
             payload["serviceMapIncludeNamespace"] = self.service_map_include_namespace
         if self.limit is not None:
             payload["limit"] = self.limit
-        if self.spss is not None:
-            payload["spss"] = self.spss
-        if self.group_by is not None:
-            payload["groupBy"] = self.group_by
         if self.datasource is not None:
             payload["datasource"] = self.datasource
-        if self.table_type is not None:
-            payload["tableType"] = self.table_type
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "refId" in data:
@@ -129,24 +113,18 @@
             args["max_duration"] = data["maxDuration"]
         if "serviceMapQuery" in data:
             args["service_map_query"] = data["serviceMapQuery"]
         if "serviceMapIncludeNamespace" in data:
             args["service_map_include_namespace"] = data["serviceMapIncludeNamespace"]
         if "limit" in data:
             args["limit"] = data["limit"]
-        if "spss" in data:
-            args["spss"] = data["spss"]
-        if "filters" in data:
-            args["filters"] = data["filters"]
-        if "groupBy" in data:
-            args["group_by"] = data["groupBy"]
         if "datasource" in data:
             args["datasource"] = data["datasource"]
-        if "tableType" in data:
-            args["table_type"] = data["tableType"]        
+        if "filters" in data:
+            args["filters"] = data["filters"]        
 
         return cls(**args)
 
 
 def variant_config() -> cogruntime.DataqueryConfig:
     return cogruntime.DataqueryConfig(
         identifier="tempo",
@@ -176,29 +154,19 @@
 
     PENDING = "pending"
     STREAMING = "streaming"
     DONE = "done"
     ERROR = "error"
 
 
-class SearchTableType(enum.StrEnum):
-    """
-    The type of the table that is used to display the search results
-    """
-
-    TRACES = "traces"
-    SPANS = "spans"
-
-
 class TraceqlSearchScope(enum.StrEnum):
     """
     static fields are pre-set in the UI, dynamic fields are added by the user
     """
 
-    INTRINSIC = "intrinsic"
     UNSCOPED = "unscoped"
     RESOURCE = "resource"
     SPAN = "span"
 
 
 class TraceqlFilter:
     # Uniquely identify the filter, will not be used in the query generation
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/testdata.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/testdata.py`

 * *Files 5% similar despite different names*

```diff
@@ -35,22 +35,22 @@
     CSV_CONTENT = "csv_content"
     TRACE = "trace"
     MANUAL_ENTRY = "manual_entry"
     VARIABLES_QUERY = "variables-query"
 
 
 class StreamingQuery:
-    type_val: typing.Literal["signal", "logs", "fetch", "traces"]
+    type_val: typing.Literal["signal", "logs", "fetch"]
     speed: int
     spread: int
     noise: int
     bands: typing.Optional[int]
     url: typing.Optional[str]
 
-    def __init__(self, type_val: typing.Optional[typing.Literal["signal", "logs", "fetch", "traces"]] = None, speed: int = 0, spread: int = 0, noise: int = 0, bands: typing.Optional[int] = None, url: typing.Optional[str] = None):
+    def __init__(self, type_val: typing.Optional[typing.Literal["signal", "logs", "fetch"]] = None, speed: int = 0, spread: int = 0, noise: int = 0, bands: typing.Optional[int] = None, url: typing.Optional[str] = None):
         self.type_val = type_val if type_val is not None else "signal"
         self.speed = speed
         self.spread = spread
         self.noise = noise
         self.bands = bands
         self.url = url
 
@@ -171,44 +171,38 @@
         if "last" in data:
             args["last"] = data["last"]        
 
         return cls(**args)
 
 
 class NodesQuery:
-    type_val: typing.Optional[typing.Literal["random", "response_small", "response_medium", "random edges"]]
+    type_val: typing.Optional[typing.Literal["random", "response", "random edges"]]
     count: typing.Optional[int]
-    seed: typing.Optional[int]
 
-    def __init__(self, type_val: typing.Optional[typing.Literal["random", "response_small", "response_medium", "random edges"]] = None, count: typing.Optional[int] = None, seed: typing.Optional[int] = None):
+    def __init__(self, type_val: typing.Optional[typing.Literal["random", "response", "random edges"]] = None, count: typing.Optional[int] = None):
         self.type_val = type_val
         self.count = count
-        self.seed = seed
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.type_val is not None:
             payload["type"] = self.type_val
         if self.count is not None:
             payload["count"] = self.count
-        if self.seed is not None:
-            payload["seed"] = self.seed
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "type" in data:
             args["type_val"] = data["type"]
         if "count" in data:
-            args["count"] = data["count"]
-        if "seed" in data:
-            args["seed"] = data["seed"]        
+            args["count"] = data["count"]        
 
         return cls(**args)
 
 
 class USAQuery:
     mode: typing.Optional[str]
     period: typing.Optional[str]
@@ -357,21 +351,20 @@
     raw_frame_content: typing.Optional[str]
     series_count: typing.Optional[int]
     usa: typing.Optional['USAQuery']
     error_type: typing.Optional[typing.Literal["server_panic", "frontend_exception", "frontend_observable"]]
     span_count: typing.Optional[int]
     points: typing.Optional[list[list[typing.Union[str, int]]]]
     drop_percent: typing.Optional[float]
-    flamegraph_diff: typing.Optional[bool]
     ref_id: typing.Optional[str]
     hide: typing.Optional[bool]
     query_type: typing.Optional[str]
     datasource: typing.Optional[object]
 
-    def __init__(self, alias: typing.Optional[str] = None, scenario_id: typing.Optional['TestDataQueryType'] = None, string_input: typing.Optional[str] = None, stream: typing.Optional['StreamingQuery'] = None, pulse_wave: typing.Optional['PulseWaveQuery'] = None, sim: typing.Optional['SimulationQuery'] = None, csv_wave: typing.Optional[list['CSVWave']] = None, labels: typing.Optional[str] = None, lines: typing.Optional[int] = None, level_column: typing.Optional[bool] = None, channel: typing.Optional[str] = None, nodes: typing.Optional['NodesQuery'] = None, csv_file_name: typing.Optional[str] = None, csv_content: typing.Optional[str] = None, raw_frame_content: typing.Optional[str] = None, series_count: typing.Optional[int] = None, usa: typing.Optional['USAQuery'] = None, error_type: typing.Optional[typing.Literal["server_panic", "frontend_exception", "frontend_observable"]] = None, span_count: typing.Optional[int] = None, points: typing.Optional[list[list[typing.Union[str, int]]]] = None, drop_percent: typing.Optional[float] = None, flamegraph_diff: typing.Optional[bool] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None):
+    def __init__(self, alias: typing.Optional[str] = None, scenario_id: typing.Optional['TestDataQueryType'] = None, string_input: typing.Optional[str] = None, stream: typing.Optional['StreamingQuery'] = None, pulse_wave: typing.Optional['PulseWaveQuery'] = None, sim: typing.Optional['SimulationQuery'] = None, csv_wave: typing.Optional[list['CSVWave']] = None, labels: typing.Optional[str] = None, lines: typing.Optional[int] = None, level_column: typing.Optional[bool] = None, channel: typing.Optional[str] = None, nodes: typing.Optional['NodesQuery'] = None, csv_file_name: typing.Optional[str] = None, csv_content: typing.Optional[str] = None, raw_frame_content: typing.Optional[str] = None, series_count: typing.Optional[int] = None, usa: typing.Optional['USAQuery'] = None, error_type: typing.Optional[typing.Literal["server_panic", "frontend_exception", "frontend_observable"]] = None, span_count: typing.Optional[int] = None, points: typing.Optional[list[list[typing.Union[str, int]]]] = None, drop_percent: typing.Optional[float] = None, ref_id: typing.Optional[str] = None, hide: typing.Optional[bool] = None, query_type: typing.Optional[str] = None, datasource: typing.Optional[object] = None):
         self.alias = alias
         self.scenario_id = scenario_id if scenario_id is not None else TestDataQueryType.RANDOM_WALK
         self.string_input = string_input
         self.stream = stream
         self.pulse_wave = pulse_wave
         self.sim = sim
         self.csv_wave = csv_wave
@@ -385,15 +378,14 @@
         self.raw_frame_content = raw_frame_content
         self.series_count = series_count
         self.usa = usa
         self.error_type = error_type
         self.span_count = span_count
         self.points = points
         self.drop_percent = drop_percent
-        self.flamegraph_diff = flamegraph_diff
         self.ref_id = ref_id
         self.hide = hide
         self.query_type = query_type
         self.datasource = datasource
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
@@ -436,16 +428,14 @@
             payload["errorType"] = self.error_type
         if self.span_count is not None:
             payload["spanCount"] = self.span_count
         if self.points is not None:
             payload["points"] = self.points
         if self.drop_percent is not None:
             payload["dropPercent"] = self.drop_percent
-        if self.flamegraph_diff is not None:
-            payload["flamegraphDiff"] = self.flamegraph_diff
         if self.ref_id is not None:
             payload["refId"] = self.ref_id
         if self.hide is not None:
             payload["hide"] = self.hide
         if self.query_type is not None:
             payload["queryType"] = self.query_type
         if self.datasource is not None:
@@ -494,16 +484,14 @@
             args["error_type"] = data["errorType"]
         if "spanCount" in data:
             args["span_count"] = data["spanCount"]
         if "points" in data:
             args["points"] = data["points"]
         if "dropPercent" in data:
             args["drop_percent"] = data["dropPercent"]
-        if "flamegraphDiff" in data:
-            args["flamegraph_diff"] = data["flamegraphDiff"]
         if "refId" in data:
             args["ref_id"] = data["refId"]
         if "hide" in data:
             args["hide"] = data["hide"]
         if "queryType" in data:
             args["query_type"] = data["queryType"]
         if "datasource" in data:
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/text.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/text.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/timeseries.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/timeseries.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/trend.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/trend.py`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/grafana_foundation_sdk/models/xychart.py` & `grafana_foundation_sdk-1713478332!10.1.0/grafana_foundation_sdk/models/xychart.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,33 +3,25 @@
 import enum
 import typing
 from ..models import common
 from ..cog import runtime as cogruntime
 
 
 class SeriesMapping(enum.StrEnum):
-    """
-    Auto is "table" in the UI
-    """
-
     AUTO = "auto"
     MANUAL = "manual"
 
 
 class ScatterShow(enum.StrEnum):
     POINTS = "points"
     LINES = "lines"
     POINTS_AND_LINES = "points+lines"
 
 
 class XYDimensionConfig:
-    """
-    Configuration for the Table/Auto mode
-    """
-
     frame: int
     x: typing.Optional[str]
     exclude: typing.Optional[list[str]]
 
     def __init__(self, frame: int = 0, x: typing.Optional[str] = None, exclude: typing.Optional[list[str]] = None):
         self.frame = frame
         self.x = x
@@ -72,19 +64,18 @@
     axis_color_mode: typing.Optional[common.AxisColorMode]
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional[common.ScaleDistributionConfig]
-    axis_centered_zero: typing.Optional[bool]
     label_value: typing.Optional[common.TextDimensionConfig]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
 
-    def __init__(self, show: typing.Optional['ScatterShow'] = None, point_size: typing.Optional[common.ScaleDimensionConfig] = None, point_color: typing.Optional[common.ColorDimensionConfig] = None, line_color: typing.Optional[common.ColorDimensionConfig] = None, line_width: typing.Optional[int] = None, line_style: typing.Optional[common.LineStyle] = None, label: typing.Optional[common.VisibilityMode] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, axis_centered_zero: typing.Optional[bool] = None, label_value: typing.Optional[common.TextDimensionConfig] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, show: typing.Optional['ScatterShow'] = None, point_size: typing.Optional[common.ScaleDimensionConfig] = None, point_color: typing.Optional[common.ColorDimensionConfig] = None, line_color: typing.Optional[common.ColorDimensionConfig] = None, line_width: typing.Optional[int] = None, line_style: typing.Optional[common.LineStyle] = None, label: typing.Optional[common.VisibilityMode] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, label_value: typing.Optional[common.TextDimensionConfig] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.show = show if show is not None else ScatterShow.POINTS
         self.point_size = point_size
         self.point_color = point_color
         self.line_color = line_color
         self.line_width = line_width
         self.line_style = line_style
         self.label = label if label is not None else common.VisibilityMode.AUTO
@@ -93,17 +84,16 @@
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
         self.label_value = label_value
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.show is not None:
             payload["show"] = self.show
         if self.point_size is not None:
@@ -132,20 +122,18 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
         if self.label_value is not None:
             payload["labelValue"] = self.label_value
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "show" in data:
@@ -176,28 +164,25 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = common.ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
         if "labelValue" in data:
             args["label_value"] = common.TextDimensionConfig.from_json(data["labelValue"])
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
 
 
 class ScatterSeriesConfig:
     x: typing.Optional[str]
     y: typing.Optional[str]
-    name: typing.Optional[str]
     show: typing.Optional['ScatterShow']
     point_size: typing.Optional[common.ScaleDimensionConfig]
     point_color: typing.Optional[common.ColorDimensionConfig]
     line_color: typing.Optional[common.ColorDimensionConfig]
     line_width: typing.Optional[int]
     line_style: typing.Optional[common.LineStyle]
     label: typing.Optional[common.VisibilityMode]
@@ -206,23 +191,21 @@
     axis_color_mode: typing.Optional[common.AxisColorMode]
     axis_label: typing.Optional[str]
     axis_width: typing.Optional[float]
     axis_soft_min: typing.Optional[float]
     axis_soft_max: typing.Optional[float]
     axis_grid_show: typing.Optional[bool]
     scale_distribution: typing.Optional[common.ScaleDistributionConfig]
-    axis_centered_zero: typing.Optional[bool]
-    frame: typing.Optional[float]
+    name: typing.Optional[str]
     label_value: typing.Optional[common.TextDimensionConfig]
-    axis_border_show: typing.Optional[bool]
+    axis_centered_zero: typing.Optional[bool]
 
-    def __init__(self, x: typing.Optional[str] = None, y: typing.Optional[str] = None, name: typing.Optional[str] = None, show: typing.Optional['ScatterShow'] = None, point_size: typing.Optional[common.ScaleDimensionConfig] = None, point_color: typing.Optional[common.ColorDimensionConfig] = None, line_color: typing.Optional[common.ColorDimensionConfig] = None, line_width: typing.Optional[int] = None, line_style: typing.Optional[common.LineStyle] = None, label: typing.Optional[common.VisibilityMode] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, axis_centered_zero: typing.Optional[bool] = None, frame: typing.Optional[float] = None, label_value: typing.Optional[common.TextDimensionConfig] = None, axis_border_show: typing.Optional[bool] = None):
+    def __init__(self, x: typing.Optional[str] = None, y: typing.Optional[str] = None, show: typing.Optional['ScatterShow'] = None, point_size: typing.Optional[common.ScaleDimensionConfig] = None, point_color: typing.Optional[common.ColorDimensionConfig] = None, line_color: typing.Optional[common.ColorDimensionConfig] = None, line_width: typing.Optional[int] = None, line_style: typing.Optional[common.LineStyle] = None, label: typing.Optional[common.VisibilityMode] = None, hide_from: typing.Optional[common.HideSeriesConfig] = None, axis_placement: typing.Optional[common.AxisPlacement] = None, axis_color_mode: typing.Optional[common.AxisColorMode] = None, axis_label: typing.Optional[str] = None, axis_width: typing.Optional[float] = None, axis_soft_min: typing.Optional[float] = None, axis_soft_max: typing.Optional[float] = None, axis_grid_show: typing.Optional[bool] = None, scale_distribution: typing.Optional[common.ScaleDistributionConfig] = None, name: typing.Optional[str] = None, label_value: typing.Optional[common.TextDimensionConfig] = None, axis_centered_zero: typing.Optional[bool] = None):
         self.x = x
         self.y = y
-        self.name = name
         self.show = show if show is not None else ScatterShow.POINTS
         self.point_size = point_size
         self.point_color = point_color
         self.line_color = line_color
         self.line_width = line_width
         self.line_style = line_style
         self.label = label if label is not None else common.VisibilityMode.AUTO
@@ -231,28 +214,25 @@
         self.axis_color_mode = axis_color_mode
         self.axis_label = axis_label
         self.axis_width = axis_width
         self.axis_soft_min = axis_soft_min
         self.axis_soft_max = axis_soft_max
         self.axis_grid_show = axis_grid_show
         self.scale_distribution = scale_distribution
-        self.axis_centered_zero = axis_centered_zero
-        self.frame = frame
+        self.name = name
         self.label_value = label_value
-        self.axis_border_show = axis_border_show
+        self.axis_centered_zero = axis_centered_zero
 
     def to_json(self) -> dict[str, object]:
         payload: dict[str, object] = {
         }
         if self.x is not None:
             payload["x"] = self.x
         if self.y is not None:
             payload["y"] = self.y
-        if self.name is not None:
-            payload["name"] = self.name
         if self.show is not None:
             payload["show"] = self.show
         if self.point_size is not None:
             payload["pointSize"] = self.point_size
         if self.point_color is not None:
             payload["pointColor"] = self.point_color
         if self.line_color is not None:
@@ -277,34 +257,30 @@
             payload["axisSoftMin"] = self.axis_soft_min
         if self.axis_soft_max is not None:
             payload["axisSoftMax"] = self.axis_soft_max
         if self.axis_grid_show is not None:
             payload["axisGridShow"] = self.axis_grid_show
         if self.scale_distribution is not None:
             payload["scaleDistribution"] = self.scale_distribution
-        if self.axis_centered_zero is not None:
-            payload["axisCenteredZero"] = self.axis_centered_zero
-        if self.frame is not None:
-            payload["frame"] = self.frame
+        if self.name is not None:
+            payload["name"] = self.name
         if self.label_value is not None:
             payload["labelValue"] = self.label_value
-        if self.axis_border_show is not None:
-            payload["axisBorderShow"] = self.axis_border_show
+        if self.axis_centered_zero is not None:
+            payload["axisCenteredZero"] = self.axis_centered_zero
         return payload
 
     @classmethod
     def from_json(cls, data: dict[str, typing.Any]) -> typing.Self:
         args: dict[str, typing.Any] = {}
         
         if "x" in data:
             args["x"] = data["x"]
         if "y" in data:
             args["y"] = data["y"]
-        if "name" in data:
-            args["name"] = data["name"]
         if "show" in data:
             args["show"] = data["show"]
         if "pointSize" in data:
             args["point_size"] = common.ScaleDimensionConfig.from_json(data["pointSize"])
         if "pointColor" in data:
             args["point_color"] = common.ColorDimensionConfig.from_json(data["pointColor"])
         if "lineColor" in data:
@@ -329,33 +305,29 @@
             args["axis_soft_min"] = data["axisSoftMin"]
         if "axisSoftMax" in data:
             args["axis_soft_max"] = data["axisSoftMax"]
         if "axisGridShow" in data:
             args["axis_grid_show"] = data["axisGridShow"]
         if "scaleDistribution" in data:
             args["scale_distribution"] = common.ScaleDistributionConfig.from_json(data["scaleDistribution"])
-        if "axisCenteredZero" in data:
-            args["axis_centered_zero"] = data["axisCenteredZero"]
-        if "frame" in data:
-            args["frame"] = data["frame"]
+        if "name" in data:
+            args["name"] = data["name"]
         if "labelValue" in data:
             args["label_value"] = common.TextDimensionConfig.from_json(data["labelValue"])
-        if "axisBorderShow" in data:
-            args["axis_border_show"] = data["axisBorderShow"]        
+        if "axisCenteredZero" in data:
+            args["axis_centered_zero"] = data["axisCenteredZero"]        
 
         return cls(**args)
 
 
 class Options:
     series_mapping: typing.Optional['SeriesMapping']
-    # Table Mode (auto)
     dims: 'XYDimensionConfig'
     legend: common.VizLegendOptions
     tooltip: common.VizTooltipOptions
-    # Manual Mode
     series: list['ScatterSeriesConfig']
 
     def __init__(self, series_mapping: typing.Optional['SeriesMapping'] = None, dims: typing.Optional['XYDimensionConfig'] = None, legend: typing.Optional[common.VizLegendOptions] = None, tooltip: typing.Optional[common.VizTooltipOptions] = None, series: typing.Optional[list['ScatterSeriesConfig']] = None):
         self.series_mapping = series_mapping
         self.dims = dims if dims is not None else XYDimensionConfig()
         self.legend = legend if legend is not None else common.VizLegendOptions()
         self.tooltip = tooltip if tooltip is not None else common.VizTooltipOptions()
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/LICENSE.md` & `grafana_foundation_sdk-1713478332!10.1.0/LICENSE.md`

 * *Files identical despite different names*

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/README.md` & `grafana_foundation_sdk-1713478332!10.1.0/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 # Grafana Foundation SDK – Python
 
 A set of tools, types and *builder libraries* for building and manipulating Grafana objects in Python.
 
 > [!NOTE]
-> This branch contains **types and builders generated for Grafana v10.4.x.**
+> This branch contains **types and builders generated for Grafana v10.1.x.**
 > Other supported versions of Grafana can be found at [this repository's root](https://github.com/grafana/grafana-foundation-sdk/).
 
 ## Installing
 
 ```shell
-python3 -m pip install 'grafana_foundation_sdk==1713437340!10.4.0'
+python3 -m pip install 'grafana_foundation_sdk==1713478332!10.1.0'
 ```
 
 ## Example usage
 
 ### Building a dashboard
 
 ```python
@@ -133,29 +133,29 @@
         # datasource plugin ID
         identifier="custom-query",
         from_json_hook=CustomQuery.from_json,
     )
 
 
 class CustomQueryBuilder(builder.Builder[CustomQuery]):
-    __internal: CustomQuery
+    _internal: CustomQuery
 
     def __init__(self, query: str):
-        self.__internal = CustomQuery(query=query)
+        self._internal = CustomQuery(query=query)
 
     def build(self) -> CustomQuery:
-        return self.__internal
+        return self._internal
 
     def ref_id(self, ref_id: str) -> Self:
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
 
         return self
 
     def hide(self, hide: bool) -> Self:
-        self.__internal.hide = hide
+        self._internal.hide = hide
 
         return self
 ```
 
 Register the type with cog, and use it as usual to build a dashboard:
 
 ```python
@@ -203,14 +203,15 @@
 
 ```python
 # src/custompanel.py
 from typing import Any, Self
 
 from grafana_foundation_sdk.cog import builder
 from grafana_foundation_sdk.cog import runtime as cogruntime
+from grafana_foundation_sdk.builders.dashboard import Panel as PanelBuilder
 from grafana_foundation_sdk.models import dashboard
 
 
 class CustomPanelOptions:
     make_beautiful: bool
 
     def __init__(self, make_beautiful: bool = False):
@@ -235,36 +236,27 @@
     return cogruntime.PanelCfgConfig(
         # plugin ID
         identifier="custom-panel",
         options_from_json_hook=CustomPanelOptions.from_json,
     )
 
 
-class CustomPanelBuilder(builder.Builder[dashboard.Panel]):
-    __internal: dashboard.Panel
-
+class CustomPanelBuilder(PanelBuilder, builder.Builder[dashboard.Panel]):
     def __init__(self):
-        self.__internal = dashboard.Panel()
-
-    def build(self) -> dashboard.Panel:
-        return self.__internal
-
-    def title(self, title: str) -> Self:
-        self.__internal.title = title
-        return self
-
-    # [other panel options omitted for brevity]
+        super().__init__()
+        # plugin ID
+        self._internal.type_val = "custom-panel"
 
     def make_beautiful(self) -> Self:
-        if self.__internal.options is None:
-            self.__internal.options = CustomPanelOptions()
+        if self._internal.options is None:
+            self._internal.options = CustomPanelOptions()
 
-        assert isinstance(self.__internal.options, CustomPanelOptions)
+        assert isinstance(self._internal.options, CustomPanelOptions)
 
-        self.__internal.options.make_beautiful = True
+        self._internal.options.make_beautiful = True
 
         return self
 ```
 
 Register the type with cog, and use it as usual to build a dashboard:
 
 ```python
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/pyproject.toml` & `grafana_foundation_sdk-1713478332!10.1.0/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
     "observability",
     "sdk",
     "grafana",
     "logs",
     "traces",
     "metrics"
 ]
-version = "1713437340!10.4.0"
+version = "1713478332!10.1.0"
 dependencies = []
 requires-python = ">=3.11"
 classifiers = [
     "Development Status :: 3 - Alpha",
     "Intended Audience :: Developers",
     "Intended Audience :: System Administrators",
     "License :: OSI Approved :: Apache Software License",
```

### Comparing `grafana_foundation_sdk-1713437340!10.4.0/PKG-INFO` & `grafana_foundation_sdk-1713478332!10.1.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: grafana_foundation_sdk
-Version: 1713437340!10.4.0
+Version: 1713478332!10.1.0
 Summary: A set of tools, types and libraries for building and manipulating Grafana objects.
 Project-URL: Homepage, https://github.com/grafana/grafana-foundation-sdk
 Project-URL: Repository, https://github.com/grafana/grafana-foundation-sdk.git
 Project-URL: Issues, https://github.com/grafana/grafana-foundation-sdk/issues
 Author: Grafana Labs
 License-File: LICENSE.md
 Keywords: grafana,logs,metrics,observability,sdk,traces
@@ -21,21 +21,21 @@
 Description-Content-Type: text/markdown
 
 # Grafana Foundation SDK – Python
 
 A set of tools, types and *builder libraries* for building and manipulating Grafana objects in Python.
 
 > [!NOTE]
-> This branch contains **types and builders generated for Grafana v10.4.x.**
+> This branch contains **types and builders generated for Grafana v10.1.x.**
 > Other supported versions of Grafana can be found at [this repository's root](https://github.com/grafana/grafana-foundation-sdk/).
 
 ## Installing
 
 ```shell
-python3 -m pip install 'grafana_foundation_sdk==1713437340!10.4.0'
+python3 -m pip install 'grafana_foundation_sdk==1713478332!10.1.0'
 ```
 
 ## Example usage
 
 ### Building a dashboard
 
 ```python
@@ -155,29 +155,29 @@
         # datasource plugin ID
         identifier="custom-query",
         from_json_hook=CustomQuery.from_json,
     )
 
 
 class CustomQueryBuilder(builder.Builder[CustomQuery]):
-    __internal: CustomQuery
+    _internal: CustomQuery
 
     def __init__(self, query: str):
-        self.__internal = CustomQuery(query=query)
+        self._internal = CustomQuery(query=query)
 
     def build(self) -> CustomQuery:
-        return self.__internal
+        return self._internal
 
     def ref_id(self, ref_id: str) -> Self:
-        self.__internal.ref_id = ref_id
+        self._internal.ref_id = ref_id
 
         return self
 
     def hide(self, hide: bool) -> Self:
-        self.__internal.hide = hide
+        self._internal.hide = hide
 
         return self
 ```
 
 Register the type with cog, and use it as usual to build a dashboard:
 
 ```python
@@ -225,14 +225,15 @@
 
 ```python
 # src/custompanel.py
 from typing import Any, Self
 
 from grafana_foundation_sdk.cog import builder
 from grafana_foundation_sdk.cog import runtime as cogruntime
+from grafana_foundation_sdk.builders.dashboard import Panel as PanelBuilder
 from grafana_foundation_sdk.models import dashboard
 
 
 class CustomPanelOptions:
     make_beautiful: bool
 
     def __init__(self, make_beautiful: bool = False):
@@ -257,36 +258,27 @@
     return cogruntime.PanelCfgConfig(
         # plugin ID
         identifier="custom-panel",
         options_from_json_hook=CustomPanelOptions.from_json,
     )
 
 
-class CustomPanelBuilder(builder.Builder[dashboard.Panel]):
-    __internal: dashboard.Panel
-
+class CustomPanelBuilder(PanelBuilder, builder.Builder[dashboard.Panel]):
     def __init__(self):
-        self.__internal = dashboard.Panel()
-
-    def build(self) -> dashboard.Panel:
-        return self.__internal
-
-    def title(self, title: str) -> Self:
-        self.__internal.title = title
-        return self
-
-    # [other panel options omitted for brevity]
+        super().__init__()
+        # plugin ID
+        self._internal.type_val = "custom-panel"
 
     def make_beautiful(self) -> Self:
-        if self.__internal.options is None:
-            self.__internal.options = CustomPanelOptions()
+        if self._internal.options is None:
+            self._internal.options = CustomPanelOptions()
 
-        assert isinstance(self.__internal.options, CustomPanelOptions)
+        assert isinstance(self._internal.options, CustomPanelOptions)
 
-        self.__internal.options.make_beautiful = True
+        self._internal.options.make_beautiful = True
 
         return self
 ```
 
 Register the type with cog, and use it as usual to build a dashboard:
 
 ```python
```

